/* scroller-view.c generated by valac, the Vala compiler
 * generated from scroller-view.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; c-basic-offset: 2; tab-width: 2 -*- */
/*
 * Copyright (C) 2010 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Gordon Allott <gord.allott@canonical.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <clutk/clutk.h>
#include <clutter/clutter.h>
#include <unity.h>
#include <gee.h>
#include <string.h>
#include <stdlib.h>
#include <gobject/gvaluecollector.h>


#define UNITY_LAUNCHER_TYPE_SCROLLER_PHASE (unity_launcher_scroller_phase_get_type ())

#define UNITY_LAUNCHER_TYPE_SCROLLER_VIEW_TYPE (unity_launcher_scroller_view_type_get_type ())

#define UNITY_LAUNCHER_TYPE_CHILD_TRANSITION (unity_launcher_child_transition_get_type ())
#define UNITY_LAUNCHER_CHILD_TRANSITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_CHILD_TRANSITION, UnityLauncherChildTransition))
#define UNITY_LAUNCHER_CHILD_TRANSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_CHILD_TRANSITION, UnityLauncherChildTransitionClass))
#define UNITY_LAUNCHER_IS_CHILD_TRANSITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_CHILD_TRANSITION))
#define UNITY_LAUNCHER_IS_CHILD_TRANSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_CHILD_TRANSITION))
#define UNITY_LAUNCHER_CHILD_TRANSITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_CHILD_TRANSITION, UnityLauncherChildTransitionClass))

typedef struct _UnityLauncherChildTransition UnityLauncherChildTransition;
typedef struct _UnityLauncherChildTransitionClass UnityLauncherChildTransitionClass;
typedef struct _UnityLauncherChildTransitionPrivate UnityLauncherChildTransitionPrivate;
typedef struct _UnityLauncherParamSpecChildTransition UnityLauncherParamSpecChildTransition;

#define UNITY_LAUNCHER_TYPE_SCROLLER_VIEW (unity_launcher_scroller_view_get_type ())
#define UNITY_LAUNCHER_SCROLLER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerView))
#define UNITY_LAUNCHER_SCROLLER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerViewClass))
#define UNITY_LAUNCHER_IS_SCROLLER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW))
#define UNITY_LAUNCHER_IS_SCROLLER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW))
#define UNITY_LAUNCHER_SCROLLER_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerViewClass))

typedef struct _UnityLauncherScrollerView UnityLauncherScrollerView;
typedef struct _UnityLauncherScrollerViewClass UnityLauncherScrollerViewClass;
typedef struct _UnityLauncherScrollerViewPrivate UnityLauncherScrollerViewPrivate;

#define UNITY_LAUNCHER_TYPE_SCROLLER_MODEL (unity_launcher_scroller_model_get_type ())
#define UNITY_LAUNCHER_SCROLLER_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, UnityLauncherScrollerModel))
#define UNITY_LAUNCHER_SCROLLER_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, UnityLauncherScrollerModelClass))
#define UNITY_LAUNCHER_IS_SCROLLER_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL))
#define UNITY_LAUNCHER_IS_SCROLLER_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL))
#define UNITY_LAUNCHER_SCROLLER_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, UnityLauncherScrollerModelClass))

typedef struct _UnityLauncherScrollerModel UnityLauncherScrollerModel;
typedef struct _UnityLauncherScrollerModelClass UnityLauncherScrollerModelClass;

#define UNITY_LAUNCHER_TYPE_SCROLLER_CHILD (unity_launcher_scroller_child_get_type ())
#define UNITY_LAUNCHER_SCROLLER_CHILD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, UnityLauncherScrollerChild))
#define UNITY_LAUNCHER_SCROLLER_CHILD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, UnityLauncherScrollerChildClass))
#define UNITY_LAUNCHER_IS_SCROLLER_CHILD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD))
#define UNITY_LAUNCHER_IS_SCROLLER_CHILD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD))
#define UNITY_LAUNCHER_SCROLLER_CHILD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, UnityLauncherScrollerChildClass))

typedef struct _UnityLauncherScrollerChild UnityLauncherScrollerChild;
typedef struct _UnityLauncherScrollerChildClass UnityLauncherScrollerChildClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR (unity_launcher_scroller_model_iterator_get_type ())
#define UNITY_LAUNCHER_SCROLLER_MODEL_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR, UnityLauncherScrollerModelIterator))
#define UNITY_LAUNCHER_SCROLLER_MODEL_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR, UnityLauncherScrollerModelIteratorClass))
#define UNITY_LAUNCHER_SCROLLER_MODEL_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR))
#define UNITY_LAUNCHER_SCROLLER_MODEL_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR))
#define UNITY_LAUNCHER_SCROLLER_MODEL_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR, UnityLauncherScrollerModelIteratorClass))

typedef struct _UnityLauncherScrollerModelIterator UnityLauncherScrollerModelIterator;
typedef struct _UnityLauncherScrollerModelIteratorClass UnityLauncherScrollerModelIteratorClass;
#define _unity_launcher_scroller_model_iterator_unref0(var) ((var == NULL) ? NULL : (var = (unity_launcher_scroller_model_iterator_unref (var), NULL)))

#define UNITY_LAUNCHER_TYPE_SCROLLER_CHILD_CONTROLLER (unity_launcher_scroller_child_controller_get_type ())
#define UNITY_LAUNCHER_SCROLLER_CHILD_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD_CONTROLLER, UnityLauncherScrollerChildController))
#define UNITY_LAUNCHER_SCROLLER_CHILD_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD_CONTROLLER, UnityLauncherScrollerChildControllerClass))
#define UNITY_LAUNCHER_IS_SCROLLER_CHILD_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD_CONTROLLER))
#define UNITY_LAUNCHER_IS_SCROLLER_CHILD_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD_CONTROLLER))
#define UNITY_LAUNCHER_SCROLLER_CHILD_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD_CONTROLLER, UnityLauncherScrollerChildControllerClass))

typedef struct _UnityLauncherScrollerChildController UnityLauncherScrollerChildController;
typedef struct _UnityLauncherScrollerChildControllerClass UnityLauncherScrollerChildControllerClass;
#define __g_slist_free_g_free0(var) ((var == NULL) ? NULL : (var = (_g_slist_free_g_free (var), NULL)))
typedef struct _Block10Data Block10Data;

#define TYPE_MENU_MANAGER (menu_manager_get_type ())
#define MENU_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MENU_MANAGER, MenuManager))
#define MENU_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MENU_MANAGER, MenuManagerClass))
#define IS_MENU_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MENU_MANAGER))
#define IS_MENU_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MENU_MANAGER))
#define MENU_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MENU_MANAGER, MenuManagerClass))

typedef struct _MenuManager MenuManager;
typedef struct _MenuManagerClass MenuManagerClass;
#define _unity_launcher_child_transition_unref0(var) ((var == NULL) ? NULL : (var = (unity_launcher_child_transition_unref (var), NULL)))

#define UNITY_TESTING_TYPE_OBJECT_REGISTRY (unity_testing_object_registry_get_type ())
#define UNITY_TESTING_OBJECT_REGISTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TESTING_TYPE_OBJECT_REGISTRY, UnityTestingObjectRegistry))
#define UNITY_TESTING_OBJECT_REGISTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TESTING_TYPE_OBJECT_REGISTRY, UnityTestingObjectRegistryClass))
#define UNITY_TESTING_IS_OBJECT_REGISTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TESTING_TYPE_OBJECT_REGISTRY))
#define UNITY_TESTING_IS_OBJECT_REGISTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TESTING_TYPE_OBJECT_REGISTRY))
#define UNITY_TESTING_OBJECT_REGISTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TESTING_TYPE_OBJECT_REGISTRY, UnityTestingObjectRegistryClass))

typedef struct _UnityTestingObjectRegistry UnityTestingObjectRegistry;
typedef struct _UnityTestingObjectRegistryClass UnityTestingObjectRegistryClass;
#define _unity_testing_object_registry_unref0(var) ((var == NULL) ? NULL : (var = (unity_testing_object_registry_unref (var), NULL)))

typedef enum  {
	UNITY_LAUNCHER_SCROLLER_PHASE_PANNING,
	UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING,
	UNITY_LAUNCHER_SCROLLER_PHASE_REORDERING,
	UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG,
	UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE,
	UNITY_LAUNCHER_SCROLLER_PHASE_NONE
} UnityLauncherScrollerPhase;

typedef enum  {
	UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED,
	UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED
} UnityLauncherScrollerViewType;

struct _UnityLauncherChildTransition {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityLauncherChildTransitionPrivate * priv;
	float position;
	float rotation;
};

struct _UnityLauncherChildTransitionClass {
	GTypeClass parent_class;
	void (*finalize) (UnityLauncherChildTransition *self);
};

struct _UnityLauncherParamSpecChildTransition {
	GParamSpec parent_instance;
};

struct _UnityLauncherScrollerView {
	CtkActor parent_instance;
	UnityLauncherScrollerViewPrivate * priv;
	gint spacing;
	gint drag_sensitivity;
	float friction;
	gboolean is_animating;
	ClutterTimeline* fling_timeline;
};

struct _UnityLauncherScrollerViewClass {
	CtkActorClass parent_class;
};

struct _UnityLauncherScrollerViewPrivate {
	gboolean disable_child_events;
	UnityLauncherScrollerModel* _model;
	CtkEffectCache* _cache;
	UnityThemeImage* bgtex;
	UnityThemeImage* top_shadow;
	gboolean button_down;
	float total_child_height;
	UnityLauncherScrollerPhase current_phase;
	guint last_motion_event_time;
	UnityLauncherScrollerViewType view_type;
	float last_known_pointer_x;
	gboolean is_scrolling;
	float scroll_position;
	float settle_position;
	gboolean _is_autoscrolling;
	gboolean autoscroll_anim_active;
	gint autoscroll_direction;
	float previous_y_position;
	guint previous_y_time;
	guint stored_delta;
	float scroll_speed;
	float contract_icon_degrees;
	float contract_icon_partial_degrees;
	gint focused_launcher;
	GeeArrayList* draw_ftb;
	GeeArrayList* draw_btf;
	ClutterText* keyboard_indicator_1;
	ClutterText* keyboard_indicator_2;
	ClutterText* keyboard_indicator_3;
	ClutterText* keyboard_indicator_4;
	ClutterText* keyboard_indicator_5;
	ClutterText* keyboard_indicator_6;
	ClutterText* keyboard_indicator_7;
	ClutterText* keyboard_indicator_8;
	ClutterText* keyboard_indicator_9;
	ClutterText* keyboard_indicator_0;
	GeeArrayList* child_refs;
	ClutterActor* last_picked_actor;
	float last_scroll_position;
	guint queue_contract_launcher;
	float autoscroll_mouse_pos_cache;
};

struct _Block10Data {
	int _ref_count_;
	UnityLauncherScrollerView * self;
	UnityLauncherScrollerChild* child;
};


static gpointer unity_launcher_child_transition_parent_class = NULL;
static gpointer unity_launcher_scroller_view_parent_class = NULL;

GType unity_launcher_scroller_phase_get_type (void) G_GNUC_CONST;
GType unity_launcher_scroller_view_type_get_type (void) G_GNUC_CONST;
gpointer unity_launcher_child_transition_ref (gpointer instance);
void unity_launcher_child_transition_unref (gpointer instance);
GParamSpec* unity_launcher_param_spec_child_transition (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_launcher_value_set_child_transition (GValue* value, gpointer v_object);
void unity_launcher_value_take_child_transition (GValue* value, gpointer v_object);
gpointer unity_launcher_value_get_child_transition (const GValue* value);
GType unity_launcher_child_transition_get_type (void) G_GNUC_CONST;
enum  {
	UNITY_LAUNCHER_CHILD_TRANSITION_DUMMY_PROPERTY
};
UnityLauncherChildTransition* unity_launcher_child_transition_new (void);
UnityLauncherChildTransition* unity_launcher_child_transition_construct (GType object_type);
static void unity_launcher_child_transition_finalize (UnityLauncherChildTransition* obj);
GType unity_launcher_scroller_view_get_type (void) G_GNUC_CONST;
GType unity_launcher_scroller_model_get_type (void) G_GNUC_CONST;
GType unity_launcher_scroller_child_get_type (void) G_GNUC_CONST;
#define UNITY_LAUNCHER_SCROLLER_VIEW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerViewPrivate))
enum  {
	UNITY_LAUNCHER_SCROLLER_VIEW_DUMMY_PROPERTY,
	UNITY_LAUNCHER_SCROLLER_VIEW_MODEL,
	UNITY_LAUNCHER_SCROLLER_VIEW_CACHE,
	UNITY_LAUNCHER_SCROLLER_VIEW_IS_AUTOSCROLLING
};
UnityLauncherScrollerView* unity_launcher_scroller_view_new (UnityLauncherScrollerModel* _model, CtkEffectCache* _cache);
UnityLauncherScrollerView* unity_launcher_scroller_view_construct (GType object_type, UnityLauncherScrollerModel* _model, CtkEffectCache* _cache);
UnityLauncherScrollerModel* unity_launcher_scroller_view_get_model (UnityLauncherScrollerView* self);
gpointer unity_launcher_scroller_model_iterator_ref (gpointer instance);
void unity_launcher_scroller_model_iterator_unref (gpointer instance);
GParamSpec* unity_launcher_scroller_model_param_spec_iterator (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_launcher_scroller_model_value_set_iterator (GValue* value, gpointer v_object);
void unity_launcher_scroller_model_value_take_iterator (GValue* value, gpointer v_object);
gpointer unity_launcher_scroller_model_value_get_iterator (const GValue* value);
GType unity_launcher_scroller_model_iterator_get_type (void) G_GNUC_CONST;
UnityLauncherScrollerModelIterator* unity_launcher_scroller_model_iterator (UnityLauncherScrollerModel* self);
gboolean unity_launcher_scroller_model_iterator_next (UnityLauncherScrollerModelIterator* self);
UnityLauncherScrollerChild* unity_launcher_scroller_model_iterator_get (UnityLauncherScrollerModelIterator* self);
static ClutterActor* unity_launcher_scroller_view_handle_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean unity_launcher_scroller_view_on_enter_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean unity_launcher_scroller_view_on_leave_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean unity_launcher_scroller_view_on_motion_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean unity_launcher_scroller_view_passthrough_motion_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_passthrough_motion_event_clutter_actor_motion_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean unity_launcher_scroller_view_passthrough_button_press_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_passthrough_button_press_event_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean unity_launcher_scroller_view_passthrough_button_release_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_passthrough_button_release_event_clutter_actor_button_release_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
gint unity_launcher_scroller_model_get_size (UnityLauncherScrollerModel* self);
gboolean unity_launcher_scroller_child_get_active (UnityLauncherScrollerChild* self);
gint unity_launcher_scroller_model_index_of (UnityLauncherScrollerModel* self, UnityLauncherScrollerChild* child);
static void unity_launcher_scroller_view_contract_launcher (UnityLauncherScrollerView* self);
static void unity_launcher_scroller_view_move_scroll_position (UnityLauncherScrollerView* self, float pixels, gboolean check_bounds);
static void unity_launcher_scroller_view_expand_launcher (UnityLauncherScrollerView* self, float absolute_y);
void unity_launcher_scroller_view_enable_keyboard_selection_mode (UnityLauncherScrollerView* self, gboolean choice);
float unity_launcher_scroller_child_get_position (UnityLauncherScrollerChild* self);
static float* _float_dup (float* self);
void unity_launcher_scroller_child_set_position (UnityLauncherScrollerChild* self, float value);
gint unity_launcher_scroller_view_get_model_index_at_y_pos (UnityLauncherScrollerView* self, float y, gboolean return_minus_if_fail);
GType unity_launcher_scroller_child_controller_get_type (void) G_GNUC_CONST;
UnityLauncherScrollerChild* unity_launcher_scroller_child_controller_get_child (UnityLauncherScrollerChildController* self);
gint unity_launcher_scroller_model_clamp (UnityLauncherScrollerModel* self, UnityLauncherScrollerChild* child, gint value);
static void _g_slist_free_g_free (GSList* self);
gint unity_launcher_scroller_view_get_model_index_at_y_pos_no_anim (UnityLauncherScrollerView* self, float y, gboolean return_minus_if_fail);
UnityLauncherScrollerChild* unity_launcher_scroller_model_get (UnityLauncherScrollerModel* self, gint i);
static void unity_launcher_scroller_view_load_textures (UnityLauncherScrollerView* self);
static float unity_launcher_scroller_view_get_total_children_height (UnityLauncherScrollerView* self);
static float unity_launcher_scroller_view_get_available_height (UnityLauncherScrollerView* self);
static void unity_launcher_scroller_view_order_children (UnityLauncherScrollerView* self, gboolean immediate);
static void unity_launcher_scroller_view_disable_animations_on_children (UnityLauncherScrollerView* self, ClutterEvent* event);
void unity_launcher_scroller_view_set_is_autoscrolling (UnityLauncherScrollerView* self, gboolean value);
static void _lambda54_ (UnityLauncherScrollerView* self);
static void __lambda54__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void unity_launcher_scroller_view_model_child_added (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child);
#define UNITY_LAUNCHER_SHORT_DELAY ((guint) 400)
static void _lambda55_ (Block10Data* _data10_);
static void __lambda55__clutter_animation_completed (ClutterAnimation* _sender, gpointer self);
static Block10Data* block10_data_ref (Block10Data* _data10_);
static void block10_data_unref (Block10Data* _data10_);
static void unity_launcher_scroller_view_model_child_removed (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child);
static void unity_launcher_scroller_view_model_order_changed (UnityLauncherScrollerView* self);
gboolean unity_launcher_scroller_view_get_is_autoscrolling (UnityLauncherScrollerView* self);
static gboolean _lambda56_ (UnityLauncherScrollerView* self);
static gboolean __lambda56__gsource_func (gpointer self);
static void unity_launcher_scroller_view_on_auto_scrolling_state_change (UnityLauncherScrollerView* self);
static gboolean unity_launcher_scroller_view_on_button_release_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean unity_launcher_scroller_view_on_button_press_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static float unity_launcher_scroller_view_get_aligned_settle_position (UnityLauncherScrollerView* self);
GType menu_manager_get_type (void) G_GNUC_CONST;
MenuManager* menu_manager_get_default (void);
void menu_manager_popdown_current_menu (MenuManager* self);
static gboolean unity_launcher_scroller_view_on_queue_contract_launcher (UnityLauncherScrollerView* self);
static gboolean _unity_launcher_scroller_view_on_queue_contract_launcher_gsource_func (gpointer self);
static gboolean unity_launcher_scroller_view_do_queue_contract_launcher (UnityLauncherScrollerView* self);
static gboolean unity_launcher_scroller_view_on_autoscroll_motion_check (UnityLauncherScrollerView* self, float y);
static void unity_launcher_scroller_view_on_drag_motion_event (UnityLauncherScrollerView* self, UnityDragModel* model, float x, float y);
static void unity_launcher_scroller_view_do_anim_settle (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_do_anim_fling (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_do_anim_bounce (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
CtkEffectCache* unity_launcher_scroller_view_get_cache (UnityLauncherScrollerView* self);
static void unity_launcher_scroller_view_on_scroller_frame (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_real_get_preferred_width (ClutterActor* base, float for_height, float* minimum_width, float* natural_width);
static void unity_launcher_scroller_view_real_get_preferred_height (ClutterActor* base, float for_width, float* minimum_height, float* natural_height);
static GeeArrayList* unity_launcher_scroller_view_order_children_expanded (UnityLauncherScrollerView* self);
static GeeArrayList* unity_launcher_scroller_view_order_children_contracted (UnityLauncherScrollerView* self);
void unity_launcher_scroller_child_force_rotation_jump (UnityLauncherScrollerChild* self, float degrees);
void unity_launcher_scroller_child_set_rotation (UnityLauncherScrollerChild* self, float value);
static void unity_launcher_scroller_view_real_allocate (ClutterActor* base, const ClutterActorBox* box, ClutterAllocationFlags flags);
static void unity_launcher_scroller_view_real_pick (ClutterActor* base, const ClutterColor* color);
static void unity_launcher_scroller_view_real_paint (ClutterActor* base);
static void unity_launcher_scroller_view_real_map (ClutterActor* base);
static void unity_launcher_scroller_view_real_unmap (ClutterActor* base);
static void unity_launcher_scroller_view_set_model (UnityLauncherScrollerView* self, UnityLauncherScrollerModel* value);
static void unity_launcher_scroller_view_set_cache (UnityLauncherScrollerView* self, CtkEffectCache* value);
gpointer unity_testing_object_registry_ref (gpointer instance);
void unity_testing_object_registry_unref (gpointer instance);
GParamSpec* unity_testing_param_spec_object_registry (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_testing_value_set_object_registry (GValue* value, gpointer v_object);
void unity_testing_value_take_object_registry (GValue* value, gpointer v_object);
gpointer unity_testing_value_get_object_registry (const GValue* value);
GType unity_testing_object_registry_get_type (void) G_GNUC_CONST;
UnityTestingObjectRegistry* unity_testing_object_registry_get_default (void);
void unity_testing_object_registry_register (UnityTestingObjectRegistry* self, const char* name, GObject* object);
static void _unity_launcher_scroller_view_model_child_added_unity_launcher_scroller_model_child_added (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self);
static void _unity_launcher_scroller_view_model_child_removed_unity_launcher_scroller_model_child_removed (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self);
static void _unity_launcher_scroller_view_model_order_changed_unity_launcher_scroller_model_order_changed (UnityLauncherScrollerModel* _sender, gpointer self);
static gboolean _unity_launcher_scroller_view_on_button_press_event_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static void _unity_launcher_scroller_view_on_auto_scrolling_state_change_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void _unity_launcher_scroller_view_on_drag_motion_event_unity_drag_controller_drag_motion (UnityDragController* _sender, UnityDragModel* model, float x, float y, gpointer self);
static void _unity_launcher_scroller_view_on_scroller_frame_clutter_timeline_new_frame (ClutterTimeline* _sender, gint msecs, gpointer self);
static void _lambda57_ (UnityLauncherScrollerView* self);
static void __lambda57__clutter_timeline_started (ClutterTimeline* _sender, gpointer self);
static gboolean _lambda59_ (UnityLauncherScrollerView* self);
static gboolean __lambda59__gsource_func (gpointer self);
static void _lambda58_ (UnityLauncherScrollerView* self);
static void __lambda58__clutter_timeline_completed (ClutterTimeline* _sender, gpointer self);
static void _lambda60_ (UnityLauncherScrollerView* self);
static void __lambda60__unity_drag_controller_drag_start (UnityDragController* _sender, UnityDragModel* model, gpointer self);
static void _lambda61_ (UnityLauncherScrollerView* self);
static void __lambda61__unity_drag_controller_drag_drop (UnityDragController* _sender, UnityDragModel* model, float x, float y, gpointer self);
static gboolean _lambda62_ (UnityLauncherScrollerView* self);
static gboolean __lambda62__gsource_func (gpointer self);
static GObject * unity_launcher_scroller_view_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_launcher_scroller_view_finalize (GObject* obj);
static void unity_launcher_scroller_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_launcher_scroller_view_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);



GType unity_launcher_scroller_phase_get_type (void) {
	static volatile gsize unity_launcher_scroller_phase_type_id__volatile = 0;
	if (g_once_init_enter (&unity_launcher_scroller_phase_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_LAUNCHER_SCROLLER_PHASE_PANNING, "UNITY_LAUNCHER_SCROLLER_PHASE_PANNING", "panning"}, {UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING, "UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING", "settling"}, {UNITY_LAUNCHER_SCROLLER_PHASE_REORDERING, "UNITY_LAUNCHER_SCROLLER_PHASE_REORDERING", "reordering"}, {UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG, "UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG", "flung"}, {UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE, "UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE", "bounce"}, {UNITY_LAUNCHER_SCROLLER_PHASE_NONE, "UNITY_LAUNCHER_SCROLLER_PHASE_NONE", "none"}, {0, NULL, NULL}};
		GType unity_launcher_scroller_phase_type_id;
		unity_launcher_scroller_phase_type_id = g_enum_register_static ("UnityLauncherScrollerPhase", values);
		g_once_init_leave (&unity_launcher_scroller_phase_type_id__volatile, unity_launcher_scroller_phase_type_id);
	}
	return unity_launcher_scroller_phase_type_id__volatile;
}


GType unity_launcher_scroller_view_type_get_type (void) {
	static volatile gsize unity_launcher_scroller_view_type_type_id__volatile = 0;
	if (g_once_init_enter (&unity_launcher_scroller_view_type_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED, "UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED", "expanded"}, {UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED, "UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED", "contracted"}, {0, NULL, NULL}};
		GType unity_launcher_scroller_view_type_type_id;
		unity_launcher_scroller_view_type_type_id = g_enum_register_static ("UnityLauncherScrollerViewType", values);
		g_once_init_leave (&unity_launcher_scroller_view_type_type_id__volatile, unity_launcher_scroller_view_type_type_id);
	}
	return unity_launcher_scroller_view_type_type_id__volatile;
}


UnityLauncherChildTransition* unity_launcher_child_transition_construct (GType object_type) {
	UnityLauncherChildTransition* self;
	self = (UnityLauncherChildTransition*) g_type_create_instance (object_type);
	return self;
}


UnityLauncherChildTransition* unity_launcher_child_transition_new (void) {
	return unity_launcher_child_transition_construct (UNITY_LAUNCHER_TYPE_CHILD_TRANSITION);
}


static void unity_launcher_value_child_transition_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void unity_launcher_value_child_transition_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		unity_launcher_child_transition_unref (value->data[0].v_pointer);
	}
}


static void unity_launcher_value_child_transition_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = unity_launcher_child_transition_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer unity_launcher_value_child_transition_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* unity_launcher_value_child_transition_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		UnityLauncherChildTransition* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = unity_launcher_child_transition_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* unity_launcher_value_child_transition_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	UnityLauncherChildTransition** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = unity_launcher_child_transition_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* unity_launcher_param_spec_child_transition (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	UnityLauncherParamSpecChildTransition* spec;
	g_return_val_if_fail (g_type_is_a (object_type, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer unity_launcher_value_get_child_transition (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION), NULL);
	return value->data[0].v_pointer;
}


void unity_launcher_value_set_child_transition (GValue* value, gpointer v_object) {
	UnityLauncherChildTransition* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		unity_launcher_child_transition_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_launcher_child_transition_unref (old);
	}
}


void unity_launcher_value_take_child_transition (GValue* value, gpointer v_object) {
	UnityLauncherChildTransition* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_launcher_child_transition_unref (old);
	}
}


static void unity_launcher_child_transition_class_init (UnityLauncherChildTransitionClass * klass) {
	unity_launcher_child_transition_parent_class = g_type_class_peek_parent (klass);
	UNITY_LAUNCHER_CHILD_TRANSITION_CLASS (klass)->finalize = unity_launcher_child_transition_finalize;
}


static void unity_launcher_child_transition_instance_init (UnityLauncherChildTransition * self) {
	self->ref_count = 1;
}


static void unity_launcher_child_transition_finalize (UnityLauncherChildTransition* obj) {
	UnityLauncherChildTransition * self;
	self = UNITY_LAUNCHER_CHILD_TRANSITION (obj);
}


GType unity_launcher_child_transition_get_type (void) {
	static volatile gsize unity_launcher_child_transition_type_id__volatile = 0;
	if (g_once_init_enter (&unity_launcher_child_transition_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { unity_launcher_value_child_transition_init, unity_launcher_value_child_transition_free_value, unity_launcher_value_child_transition_copy_value, unity_launcher_value_child_transition_peek_pointer, "p", unity_launcher_value_child_transition_collect_value, "p", unity_launcher_value_child_transition_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UnityLauncherChildTransitionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_launcher_child_transition_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityLauncherChildTransition), 0, (GInstanceInitFunc) unity_launcher_child_transition_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType unity_launcher_child_transition_type_id;
		unity_launcher_child_transition_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UnityLauncherChildTransition", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&unity_launcher_child_transition_type_id__volatile, unity_launcher_child_transition_type_id);
	}
	return unity_launcher_child_transition_type_id__volatile;
}


gpointer unity_launcher_child_transition_ref (gpointer instance) {
	UnityLauncherChildTransition* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void unity_launcher_child_transition_unref (gpointer instance) {
	UnityLauncherChildTransition* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UNITY_LAUNCHER_CHILD_TRANSITION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


UnityLauncherScrollerView* unity_launcher_scroller_view_construct (GType object_type, UnityLauncherScrollerModel* _model, CtkEffectCache* _cache) {
	UnityLauncherScrollerView * self;
	g_return_val_if_fail (_model != NULL, NULL);
	g_return_val_if_fail (_cache != NULL, NULL);
	self = (UnityLauncherScrollerView*) g_object_new (object_type, "model", _model, "cache", _cache, NULL);
	return self;
}


UnityLauncherScrollerView* unity_launcher_scroller_view_new (UnityLauncherScrollerModel* _model, CtkEffectCache* _cache) {
	return unity_launcher_scroller_view_construct (UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, _model, _cache);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static ClutterActor* unity_launcher_scroller_view_handle_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	ClutterActor* result = NULL;
	float x = 0.0F;
	float y = 0.0F;
	ClutterActor* _tmp1_;
	ClutterActor* picked_actor;
	ClutterActor* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	if (self->priv->disable_child_events) {
		result = NULL;
		return result;
	}
	if (CLUTTER_IS_ACTOR (self->priv->last_picked_actor) == FALSE) {
		ClutterActor* _tmp0_;
		self->priv->last_picked_actor = (_tmp0_ = NULL, _g_object_unref0 (self->priv->last_picked_actor), _tmp0_);
	}
	{
		UnityLauncherScrollerModelIterator* _actor_it;
		_actor_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			ClutterActor* actor;
			if (!unity_launcher_scroller_model_iterator_next (_actor_it)) {
				break;
			}
			actor = (ClutterActor*) unity_launcher_scroller_model_iterator_get (_actor_it);
			clutter_actor_set_reactive (actor, TRUE);
			_g_object_unref0 (actor);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_actor_it);
	}
	clutter_event_get_coords (event, &x, &y);
	picked_actor = _g_object_ref0 (clutter_stage_get_actor_at_pos ((_tmp1_ = clutter_actor_get_stage ((ClutterActor*) self), CLUTTER_IS_STAGE (_tmp1_) ? ((ClutterStage*) _tmp1_) : NULL), CLUTTER_PICK_REACTIVE, (gint) x, (gint) y));
	{
		UnityLauncherScrollerModelIterator* _actor_it;
		_actor_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			ClutterActor* actor;
			if (!unity_launcher_scroller_model_iterator_next (_actor_it)) {
				break;
			}
			actor = (ClutterActor*) unity_launcher_scroller_model_iterator_get (_actor_it);
			clutter_actor_set_reactive (actor, FALSE);
			_g_object_unref0 (actor);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_actor_it);
	}
	if (CLUTTER_IS_ACTOR (picked_actor)) {
		if (self->priv->last_picked_actor != picked_actor) {
			ClutterEvent _tmp2_ = {0};
			ClutterEvent crossing_event;
			ClutterActor* _tmp3_;
			crossing_event = (_tmp2_.type = 0, _tmp2_);
			crossing_event.type = CLUTTER_LEAVE;
			crossing_event.crossing.x = x;
			crossing_event.crossing.y = y;
			crossing_event.crossing.stage = (_tmp3_ = clutter_actor_get_stage ((ClutterActor*) self), CLUTTER_IS_STAGE (_tmp3_) ? ((ClutterStage*) _tmp3_) : NULL);
			crossing_event.crossing.flags = CLUTTER_EVENT_FLAG_SYNTHETIC;
			if (CLUTTER_IS_ACTOR (self->priv->last_picked_actor)) {
				clutter_actor_event (self->priv->last_picked_actor, &crossing_event, FALSE);
			}
			crossing_event.type = CLUTTER_ENTER;
			clutter_actor_event (picked_actor, &crossing_event, FALSE);
		}
	} else {
		if (CLUTTER_IS_ACTOR (self->priv->last_picked_actor)) {
			ClutterEvent _tmp4_ = {0};
			ClutterEvent crossing_event;
			ClutterActor* _tmp5_;
			crossing_event = (_tmp4_.type = 0, _tmp4_);
			crossing_event.type = CLUTTER_LEAVE;
			crossing_event.crossing.x = x;
			crossing_event.crossing.y = y;
			crossing_event.crossing.stage = (_tmp5_ = clutter_actor_get_stage ((ClutterActor*) self), CLUTTER_IS_STAGE (_tmp5_) ? ((ClutterStage*) _tmp5_) : NULL);
			crossing_event.crossing.flags = CLUTTER_EVENT_FLAG_SYNTHETIC;
			clutter_actor_event (self->priv->last_picked_actor, &crossing_event, FALSE);
		}
	}
	self->priv->last_picked_actor = (_tmp6_ = _g_object_ref0 (picked_actor), _g_object_unref0 (self->priv->last_picked_actor), _tmp6_);
	result = picked_actor;
	return result;
}


static gboolean _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_enter_event (self, event);
	return result;
}


static gboolean _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_leave_event (self, event);
	return result;
}


static gboolean _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_motion_event (self, event);
	return result;
}


static gboolean _unity_launcher_scroller_view_passthrough_motion_event_clutter_actor_motion_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_passthrough_motion_event (self, event);
	return result;
}


static gboolean unity_launcher_scroller_view_passthrough_motion_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	UnityDragController* drag_controller;
	guint _tmp0_;
	guint _tmp1_;
	guint _tmp2_;
	guint _tmp3_;
	ClutterActor* picked_actor;
	g_return_val_if_fail (self != NULL, FALSE);
	drag_controller = _g_object_ref0 (unity_drag_controller_get_default ());
	if (unity_drag_controller_get_is_dragging (drag_controller)) {
		result = FALSE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	if (self->priv->is_scrolling) {
		result = FALSE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	g_signal_parse_name ("enter-event", CLUTTER_TYPE_ACTOR, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((ClutterActor*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event, self);
	g_signal_parse_name ("leave-event", CLUTTER_TYPE_ACTOR, &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((ClutterActor*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event, self);
	g_signal_parse_name ("motion-event", CLUTTER_TYPE_ACTOR, &_tmp2_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((ClutterActor*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self);
	g_signal_parse_name ("motion-event", CLUTTER_TYPE_ACTOR, &_tmp3_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((ClutterActor*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) _unity_launcher_scroller_view_passthrough_motion_event_clutter_actor_motion_event, self);
	picked_actor = unity_launcher_scroller_view_handle_event (self, event);
	if (CLUTTER_IS_ACTOR (picked_actor)) {
		clutter_actor_event (picked_actor, event, FALSE);
	}
	g_signal_connect_object ((ClutterActor*) self, "enter-event", (GCallback) _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event, self, 0);
	g_signal_connect_object ((ClutterActor*) self, "leave-event", (GCallback) _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event, self, 0);
	g_signal_connect_object ((ClutterActor*) self, "motion-event", (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self, 0);
	g_signal_connect_object ((ClutterActor*) self, "motion-event", (GCallback) _unity_launcher_scroller_view_passthrough_motion_event_clutter_actor_motion_event, self, 0);
	result = FALSE;
	_g_object_unref0 (picked_actor);
	_g_object_unref0 (drag_controller);
	return result;
}


static gboolean _unity_launcher_scroller_view_passthrough_button_press_event_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_passthrough_button_press_event (self, event);
	return result;
}


static gboolean unity_launcher_scroller_view_passthrough_button_press_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	UnityDragController* drag_controller;
	guint _tmp0_;
	guint _tmp1_;
	guint _tmp2_;
	ClutterActor* picked_actor;
	g_return_val_if_fail (self != NULL, FALSE);
	drag_controller = _g_object_ref0 (unity_drag_controller_get_default ());
	if (unity_drag_controller_get_is_dragging (drag_controller)) {
		result = FALSE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	if (self->priv->is_scrolling) {
		result = FALSE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	g_signal_parse_name ("enter-event", CLUTTER_TYPE_ACTOR, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((ClutterActor*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event, self);
	g_signal_parse_name ("leave-event", CLUTTER_TYPE_ACTOR, &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((ClutterActor*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event, self);
	g_signal_parse_name ("button-press-event", CLUTTER_TYPE_ACTOR, &_tmp2_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((ClutterActor*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _unity_launcher_scroller_view_passthrough_button_press_event_clutter_actor_button_press_event, self);
	picked_actor = unity_launcher_scroller_view_handle_event (self, event);
	if (CLUTTER_IS_ACTOR (picked_actor)) {
		clutter_actor_event (picked_actor, event, FALSE);
	}
	g_signal_connect_object ((ClutterActor*) self, "enter-event", (GCallback) _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event, self, 0);
	g_signal_connect_object ((ClutterActor*) self, "leave-event", (GCallback) _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event, self, 0);
	g_signal_connect_object ((ClutterActor*) self, "button-press-event", (GCallback) _unity_launcher_scroller_view_passthrough_button_press_event_clutter_actor_button_press_event, self, 0);
	result = FALSE;
	_g_object_unref0 (picked_actor);
	_g_object_unref0 (drag_controller);
	return result;
}


static gboolean _unity_launcher_scroller_view_passthrough_button_release_event_clutter_actor_button_release_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_passthrough_button_release_event (self, event);
	return result;
}


static gboolean unity_launcher_scroller_view_passthrough_button_release_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	UnityDragController* drag_controller;
	guint _tmp0_;
	guint _tmp1_;
	guint _tmp2_;
	ClutterActor* picked_actor;
	g_return_val_if_fail (self != NULL, FALSE);
	drag_controller = _g_object_ref0 (unity_drag_controller_get_default ());
	if (unity_drag_controller_get_is_dragging (drag_controller)) {
		result = FALSE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	if (self->priv->is_scrolling) {
		result = FALSE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	g_signal_parse_name ("enter-event", CLUTTER_TYPE_ACTOR, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((ClutterActor*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event, self);
	g_signal_parse_name ("leave-event", CLUTTER_TYPE_ACTOR, &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((ClutterActor*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event, self);
	g_signal_parse_name ("button-release-event", CLUTTER_TYPE_ACTOR, &_tmp2_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((ClutterActor*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _unity_launcher_scroller_view_passthrough_button_release_event_clutter_actor_button_release_event, self);
	picked_actor = unity_launcher_scroller_view_handle_event (self, event);
	if (CLUTTER_IS_ACTOR (picked_actor)) {
		clutter_actor_event (picked_actor, event, FALSE);
	}
	g_signal_connect_object ((ClutterActor*) self, "enter-event", (GCallback) _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event, self, 0);
	g_signal_connect_object ((ClutterActor*) self, "leave-event", (GCallback) _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event, self, 0);
	g_signal_connect_object ((ClutterActor*) self, "button-release-event", (GCallback) _unity_launcher_scroller_view_passthrough_button_release_event_clutter_actor_button_release_event, self, 0);
	result = FALSE;
	_g_object_unref0 (picked_actor);
	_g_object_unref0 (drag_controller);
	return result;
}


void unity_launcher_scroller_view_enable_keyboard_selection_mode (UnityLauncherScrollerView* self, gboolean choice) {
	gint _tmp0_ = 0;
	guint8 new_opacity;
	g_return_if_fail (self != NULL);
	if (choice) {
		self->priv->last_scroll_position = self->priv->scroll_position;
	}
	if (choice) {
		_tmp0_ = 0xff;
	} else {
		_tmp0_ = 0x00;
	}
	new_opacity = (guint8) _tmp0_;
	clutter_actor_animate ((ClutterActor*) self->priv->keyboard_indicator_1, (gulong) CLUTTER_EASE_OUT_SINE, (guint) 150, "opacity", new_opacity, NULL);
	if (unity_launcher_scroller_model_get_size (self->priv->_model) < 2) {
		new_opacity = (guint8) 0x00;
	}
	clutter_actor_animate ((ClutterActor*) self->priv->keyboard_indicator_2, (gulong) CLUTTER_EASE_OUT_SINE, (guint) 150, "opacity", new_opacity, NULL);
	if (unity_launcher_scroller_model_get_size (self->priv->_model) < 3) {
		new_opacity = (guint8) 0x00;
	}
	clutter_actor_animate ((ClutterActor*) self->priv->keyboard_indicator_3, (gulong) CLUTTER_EASE_OUT_SINE, (guint) 150, "opacity", new_opacity, NULL);
	if (unity_launcher_scroller_model_get_size (self->priv->_model) < 4) {
		new_opacity = (guint8) 0x00;
	}
	clutter_actor_animate ((ClutterActor*) self->priv->keyboard_indicator_4, (gulong) CLUTTER_EASE_OUT_SINE, (guint) 150, "opacity", new_opacity, NULL);
	if (unity_launcher_scroller_model_get_size (self->priv->_model) < 5) {
		new_opacity = (guint8) 0x00;
	}
	clutter_actor_animate ((ClutterActor*) self->priv->keyboard_indicator_5, (gulong) CLUTTER_EASE_OUT_SINE, (guint) 150, "opacity", new_opacity, NULL);
	if (unity_launcher_scroller_model_get_size (self->priv->_model) < 6) {
		new_opacity = (guint8) 0x00;
	}
	clutter_actor_animate ((ClutterActor*) self->priv->keyboard_indicator_6, (gulong) CLUTTER_EASE_OUT_SINE, (guint) 150, "opacity", new_opacity, NULL);
	if (unity_launcher_scroller_model_get_size (self->priv->_model) < 7) {
		new_opacity = (guint8) 0x00;
	}
	clutter_actor_animate ((ClutterActor*) self->priv->keyboard_indicator_7, (gulong) CLUTTER_EASE_OUT_SINE, (guint) 150, "opacity", new_opacity, NULL);
	if (unity_launcher_scroller_model_get_size (self->priv->_model) < 8) {
		new_opacity = (guint8) 0x00;
	}
	clutter_actor_animate ((ClutterActor*) self->priv->keyboard_indicator_8, (gulong) CLUTTER_EASE_OUT_SINE, (guint) 150, "opacity", new_opacity, NULL);
	if (unity_launcher_scroller_model_get_size (self->priv->_model) < 9) {
		new_opacity = (guint8) 0x00;
	}
	clutter_actor_animate ((ClutterActor*) self->priv->keyboard_indicator_9, (gulong) CLUTTER_EASE_OUT_SINE, (guint) 150, "opacity", new_opacity, NULL);
	if (unity_launcher_scroller_model_get_size (self->priv->_model) < 10) {
		new_opacity = (guint8) 0x00;
	}
	clutter_actor_animate ((ClutterActor*) self->priv->keyboard_indicator_0, (gulong) CLUTTER_EASE_OUT_SINE, (guint) 150, "opacity", new_opacity, NULL);
	if (!choice) {
		gboolean _tmp1_ = FALSE;
		if (self->priv->view_type != UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED) {
			_tmp1_ = self->priv->last_known_pointer_x >= clutter_actor_get_width ((ClutterActor*) self);
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			{
				UnityLauncherScrollerModelIterator* _child_it;
				_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
				while (TRUE) {
					UnityLauncherScrollerChild* child;
					if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
						break;
					}
					child = unity_launcher_scroller_model_iterator_get (_child_it);
					if (unity_launcher_scroller_child_get_active (child)) {
						self->priv->focused_launcher = unity_launcher_scroller_model_index_of (self->priv->_model, child);
						_g_object_unref0 (child);
						break;
					}
					_g_object_unref0 (child);
				}
				_unity_launcher_scroller_model_iterator_unref0 (_child_it);
			}
			unity_launcher_scroller_view_contract_launcher (self);
		} else {
			if (self->priv->last_known_pointer_x < clutter_actor_get_width ((ClutterActor*) self)) {
				unity_launcher_scroller_view_move_scroll_position (self, self->priv->last_scroll_position - self->priv->scroll_position, FALSE);
			}
		}
	} else {
		unity_launcher_scroller_view_expand_launcher (self, (float) 0);
	}
}


static float* _float_dup (float* self) {
	float* dup;
	dup = g_new0 (float, 1);
	memcpy (dup, self, sizeof (float));
	return dup;
}


static gpointer __float_dup0 (gpointer self) {
	return self ? _float_dup (self) : NULL;
}


static void _g_slist_free_g_free (GSList* self) {
	g_slist_foreach (self, (GFunc) g_free, NULL);
	g_slist_free (self);
}


gint unity_launcher_scroller_view_get_model_index_at_y_pos_no_anim (UnityLauncherScrollerView* self, float y, gboolean return_minus_if_fail) {
	gint result = 0;
	GSList* positions;
	gint value;
	GSList* list;
	UnityLauncherScrollerChildController* _tmp2_;
	UnityDragModel* _tmp1_;
	UnityLauncherScrollerChild* _tmp3_;
	UnityLauncherScrollerChild* child;
	g_return_val_if_fail (self != NULL, 0);
	positions = NULL;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			float _tmp0_;
			GValue value = {0};
			ClutterAnimation* anim;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			positions = g_slist_append (positions, __float_dup0 ((_tmp0_ = unity_launcher_scroller_child_get_position (child), &_tmp0_)));
			g_value_init (&value, G_TYPE_FLOAT);
			anim = _g_object_ref0 (clutter_actor_get_animation ((ClutterActor*) child));
			if (CLUTTER_IS_ANIMATION (anim)) {
				ClutterInterval* interval;
				interval = _g_object_ref0 (clutter_animation_get_interval (anim, "position"));
				if (CLUTTER_IS_INTERVAL (interval)) {
					clutter_interval_get_final_value (interval, &value);
					unity_launcher_scroller_child_set_position (child, g_value_get_float (&value));
				}
				_g_object_unref0 (interval);
			}
			_g_object_unref0 (anim);
			G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	value = unity_launcher_scroller_view_get_model_index_at_y_pos (self, y, return_minus_if_fail);
	list = positions;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			unity_launcher_scroller_child_set_position (child, (float) (*((float*) list->data)));
			list = list->next;
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	child = (_tmp3_ = _g_object_ref0 (unity_launcher_scroller_child_controller_get_child (_tmp2_ = (_tmp1_ = unity_drag_controller_get_drag_model (unity_drag_controller_get_default ()), UNITY_LAUNCHER_IS_SCROLLER_CHILD_CONTROLLER (_tmp1_) ? ((UnityLauncherScrollerChildController*) _tmp1_) : NULL))), _g_object_unref0 (_tmp2_), _tmp3_);
	value = unity_launcher_scroller_model_clamp (self->priv->_model, child, value);
	result = value;
	_g_object_unref0 (child);
	__g_slist_free_g_free0 (positions);
	return result;
}


gint unity_launcher_scroller_view_get_model_index_at_y_pos (UnityLauncherScrollerView* self, float y, gboolean return_minus_if_fail) {
	gint result = 0;
	gint iy;
	ClutterActor* _tmp0_;
	ClutterActor* picked_actor;
	gint ret_val;
	g_return_val_if_fail (self != NULL, 0);
	iy = (gint) y;
	{
		UnityLauncherScrollerModelIterator* _actor_it;
		_actor_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			ClutterActor* actor;
			if (!unity_launcher_scroller_model_iterator_next (_actor_it)) {
				break;
			}
			actor = (ClutterActor*) unity_launcher_scroller_model_iterator_get (_actor_it);
			clutter_actor_set_reactive (actor, TRUE);
			_g_object_unref0 (actor);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_actor_it);
	}
	picked_actor = _g_object_ref0 (clutter_stage_get_actor_at_pos ((_tmp0_ = clutter_actor_get_stage ((ClutterActor*) self), CLUTTER_IS_STAGE (_tmp0_) ? ((ClutterStage*) _tmp0_) : NULL), CLUTTER_PICK_REACTIVE, 25, iy));
	ret_val = -200;
	if (UNITY_LAUNCHER_IS_SCROLLER_CHILD (picked_actor) == FALSE) {
		ClutterActor* _tmp2_;
		ClutterActor* _tmp1_;
		picked_actor = (_tmp2_ = _g_object_ref0 (clutter_stage_get_actor_at_pos ((_tmp1_ = clutter_actor_get_stage ((ClutterActor*) self), CLUTTER_IS_STAGE (_tmp1_) ? ((ClutterStage*) _tmp1_) : NULL), CLUTTER_PICK_REACTIVE, 25, iy - self->spacing)), _g_object_unref0 (picked_actor), _tmp2_);
		if (UNITY_LAUNCHER_IS_SCROLLER_CHILD (picked_actor) == FALSE) {
			ClutterActor* _tmp4_;
			ClutterActor* _tmp3_;
			picked_actor = (_tmp4_ = _g_object_ref0 (clutter_stage_get_actor_at_pos ((_tmp3_ = clutter_actor_get_stage ((ClutterActor*) self), CLUTTER_IS_STAGE (_tmp3_) ? ((ClutterStage*) _tmp3_) : NULL), CLUTTER_PICK_REACTIVE, 25, iy + self->spacing)), _g_object_unref0 (picked_actor), _tmp4_);
			if (UNITY_LAUNCHER_IS_SCROLLER_CHILD (picked_actor) == FALSE) {
				gint _tmp5_ = 0;
				UnityLauncherScrollerChild* _tmp7_;
				CtkPadding _tmp6_ = {0};
				gboolean _tmp8_;
				if (return_minus_if_fail) {
					ret_val = -1;
				}
				if ((_tmp8_ = y < (((ctk_actor_get_padding ((CtkActor*) self, &_tmp6_), _tmp6_.top) + clutter_actor_get_height ((ClutterActor*) (_tmp7_ = unity_launcher_scroller_model_get (self->priv->_model, 0)))) + self->spacing), _g_object_unref0 (_tmp7_), _tmp8_)) {
					_tmp5_ = 0;
				} else {
					_tmp5_ = unity_launcher_scroller_model_get_size (self->priv->_model) - 1;
				}
				ret_val = _tmp5_;
			}
		}
	}
	if (ret_val < (-1)) {
		ClutterActor* _tmp9_;
		ret_val = unity_launcher_scroller_model_index_of (self->priv->_model, (_tmp9_ = picked_actor, UNITY_LAUNCHER_IS_SCROLLER_CHILD (_tmp9_) ? ((UnityLauncherScrollerChild*) _tmp9_) : NULL));
	}
	{
		UnityLauncherScrollerModelIterator* _actor_it;
		_actor_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			ClutterActor* actor;
			if (!unity_launcher_scroller_model_iterator_next (_actor_it)) {
				break;
			}
			actor = (ClutterActor*) unity_launcher_scroller_model_iterator_get (_actor_it);
			clutter_actor_set_reactive (actor, FALSE);
			_g_object_unref0 (actor);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_actor_it);
	}
	result = ret_val;
	_g_object_unref0 (picked_actor);
	return result;
}


static void unity_launcher_scroller_view_load_textures (UnityLauncherScrollerView* self) {
	UnityThemeImage* _tmp0_;
	UnityThemeImage* _tmp1_;
	ClutterColor _tmp2_ = {0};
	ClutterColor color;
	ClutterText* _tmp3_;
	ClutterText* _tmp4_;
	ClutterText* _tmp5_;
	ClutterText* _tmp6_;
	ClutterText* _tmp7_;
	ClutterText* _tmp8_;
	ClutterText* _tmp9_;
	ClutterText* _tmp10_;
	ClutterText* _tmp11_;
	ClutterText* _tmp12_;
	g_return_if_fail (self != NULL);
	self->priv->bgtex = (_tmp0_ = g_object_ref_sink (unity_theme_image_new ("launcher_background_middle")), _g_object_unref0 (self->priv->bgtex), _tmp0_);
	clutter_texture_set_repeat ((ClutterTexture*) self->priv->bgtex, TRUE, TRUE);
	clutter_actor_set_parent ((ClutterActor*) self->priv->bgtex, (ClutterActor*) self);
	self->priv->top_shadow = (_tmp1_ = g_object_ref_sink (unity_theme_image_new ("overflow_top")), _g_object_unref0 (self->priv->top_shadow), _tmp1_);
	clutter_texture_set_repeat ((ClutterTexture*) self->priv->top_shadow, TRUE, FALSE);
	clutter_actor_set_parent ((ClutterActor*) self->priv->top_shadow, (ClutterActor*) self);
	color = (memset (&_tmp2_, 0, sizeof (ClutterColor)), _tmp2_.red = (guint8) 0xff, _tmp2_.green = (guint8) 0xff, _tmp2_.blue = (guint8) 0xff, _tmp2_.alpha = (guint8) 0xff, _tmp2_);
	self->priv->keyboard_indicator_1 = (_tmp3_ = g_object_ref_sink ((ClutterText*) clutter_text_new_full ("Mono Bold 24px", "1", &color)), _g_object_unref0 (self->priv->keyboard_indicator_1), _tmp3_);
	clutter_actor_set_parent ((ClutterActor*) self->priv->keyboard_indicator_1, (ClutterActor*) self);
	clutter_actor_set_opacity ((ClutterActor*) self->priv->keyboard_indicator_1, (guint8) 0x00);
	self->priv->keyboard_indicator_2 = (_tmp4_ = g_object_ref_sink ((ClutterText*) clutter_text_new_full ("Mono Bold 24px", "2", &color)), _g_object_unref0 (self->priv->keyboard_indicator_2), _tmp4_);
	clutter_actor_set_parent ((ClutterActor*) self->priv->keyboard_indicator_2, (ClutterActor*) self);
	clutter_actor_set_opacity ((ClutterActor*) self->priv->keyboard_indicator_2, (guint8) 0x00);
	self->priv->keyboard_indicator_3 = (_tmp5_ = g_object_ref_sink ((ClutterText*) clutter_text_new_full ("Mono Bold 24px", "3", &color)), _g_object_unref0 (self->priv->keyboard_indicator_3), _tmp5_);
	clutter_actor_set_parent ((ClutterActor*) self->priv->keyboard_indicator_3, (ClutterActor*) self);
	clutter_actor_set_opacity ((ClutterActor*) self->priv->keyboard_indicator_3, (guint8) 0x00);
	self->priv->keyboard_indicator_4 = (_tmp6_ = g_object_ref_sink ((ClutterText*) clutter_text_new_full ("Mono Bold 24px", "4", &color)), _g_object_unref0 (self->priv->keyboard_indicator_4), _tmp6_);
	clutter_actor_set_parent ((ClutterActor*) self->priv->keyboard_indicator_4, (ClutterActor*) self);
	clutter_actor_set_opacity ((ClutterActor*) self->priv->keyboard_indicator_4, (guint8) 0x00);
	self->priv->keyboard_indicator_5 = (_tmp7_ = g_object_ref_sink ((ClutterText*) clutter_text_new_full ("Mono Bold 24px", "5", &color)), _g_object_unref0 (self->priv->keyboard_indicator_5), _tmp7_);
	clutter_actor_set_parent ((ClutterActor*) self->priv->keyboard_indicator_5, (ClutterActor*) self);
	clutter_actor_set_opacity ((ClutterActor*) self->priv->keyboard_indicator_5, (guint8) 0x00);
	self->priv->keyboard_indicator_6 = (_tmp8_ = g_object_ref_sink ((ClutterText*) clutter_text_new_full ("Mono Bold 24px", "6", &color)), _g_object_unref0 (self->priv->keyboard_indicator_6), _tmp8_);
	clutter_actor_set_parent ((ClutterActor*) self->priv->keyboard_indicator_6, (ClutterActor*) self);
	clutter_actor_set_opacity ((ClutterActor*) self->priv->keyboard_indicator_6, (guint8) 0x00);
	self->priv->keyboard_indicator_7 = (_tmp9_ = g_object_ref_sink ((ClutterText*) clutter_text_new_full ("Mono Bold 24px", "7", &color)), _g_object_unref0 (self->priv->keyboard_indicator_7), _tmp9_);
	clutter_actor_set_parent ((ClutterActor*) self->priv->keyboard_indicator_7, (ClutterActor*) self);
	clutter_actor_set_opacity ((ClutterActor*) self->priv->keyboard_indicator_7, (guint8) 0x00);
	self->priv->keyboard_indicator_8 = (_tmp10_ = g_object_ref_sink ((ClutterText*) clutter_text_new_full ("Mono Bold 24px", "8", &color)), _g_object_unref0 (self->priv->keyboard_indicator_8), _tmp10_);
	clutter_actor_set_parent ((ClutterActor*) self->priv->keyboard_indicator_8, (ClutterActor*) self);
	clutter_actor_set_opacity ((ClutterActor*) self->priv->keyboard_indicator_8, (guint8) 0x00);
	self->priv->keyboard_indicator_9 = (_tmp11_ = g_object_ref_sink ((ClutterText*) clutter_text_new_full ("Mono Bold 24px", "9", &color)), _g_object_unref0 (self->priv->keyboard_indicator_9), _tmp11_);
	clutter_actor_set_parent ((ClutterActor*) self->priv->keyboard_indicator_9, (ClutterActor*) self);
	clutter_actor_set_opacity ((ClutterActor*) self->priv->keyboard_indicator_9, (guint8) 0x00);
	self->priv->keyboard_indicator_0 = (_tmp12_ = g_object_ref_sink ((ClutterText*) clutter_text_new_full ("Mono Bold 24px", "0", &color)), _g_object_unref0 (self->priv->keyboard_indicator_0), _tmp12_);
	clutter_actor_set_parent ((ClutterActor*) self->priv->keyboard_indicator_0, (ClutterActor*) self);
	clutter_actor_set_opacity ((ClutterActor*) self->priv->keyboard_indicator_0, (guint8) 0x00);
}


static void unity_launcher_scroller_view_move_scroll_position (UnityLauncherScrollerView* self, float pixels, gboolean check_bounds) {
	g_return_if_fail (self != NULL);
	self->priv->scroll_position = self->priv->scroll_position + pixels;
	if (check_bounds) {
		self->priv->scroll_position = fminf (self->priv->scroll_position, (float) 0);
		self->priv->scroll_position = fmaxf (self->priv->scroll_position, -(unity_launcher_scroller_view_get_total_children_height (self) - unity_launcher_scroller_view_get_available_height (self)));
	}
	unity_launcher_scroller_view_order_children (self, TRUE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static void unity_launcher_scroller_view_disable_animations_on_children (UnityLauncherScrollerView* self, ClutterEvent* event) {
	ClutterEvent _tmp0_ = {0};
	ClutterEvent e;
	g_return_if_fail (self != NULL);
	self->priv->disable_child_events = TRUE;
	e = (_tmp0_.type = 0, _tmp0_);
	e.type = CLUTTER_LEAVE;
	e.crossing.time = (*event).motion.time;
	e.crossing.flags = (*event).motion.flags;
	e.crossing.stage = (*event).motion.stage;
	e.crossing.x = (*event).motion.x;
	e.crossing.y = (*event).motion.y;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			if (CLUTTER_IS_ACTOR (child)) {
				e.crossing.source = (ClutterActor*) child;
				clutter_actor_event ((ClutterActor*) child, &e, FALSE);
			}
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


static void unity_launcher_scroller_view_expand_launcher (UnityLauncherScrollerView* self, float absolute_y) {
	g_return_if_fail (self != NULL);
	if (self->priv->view_type == UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED) {
		return;
	}
	self->priv->view_type = UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED;
	if (unity_launcher_scroller_view_get_total_children_height (self) > unity_launcher_scroller_view_get_available_height (self)) {
		gint index;
		UnityLauncherScrollerChild* _tmp0_;
		float _tmp1_;
		float contracted_position;
		float old_scroll_position;
		UnityLauncherScrollerChild* _tmp2_;
		float _tmp3_;
		float new_scroll_position;
		index = unity_launcher_scroller_view_get_model_index_at_y_pos (self, absolute_y, FALSE);
		contracted_position = (_tmp1_ = unity_launcher_scroller_child_get_position (_tmp0_ = unity_launcher_scroller_model_get (self->priv->_model, index)), _g_object_unref0 (_tmp0_), _tmp1_);
		old_scroll_position = self->priv->scroll_position;
		self->priv->scroll_position = (float) 0;
		unity_launcher_scroller_view_order_children (self, TRUE);
		new_scroll_position = (_tmp3_ = -(unity_launcher_scroller_child_get_position (_tmp2_ = unity_launcher_scroller_model_get (self->priv->_model, index)) - contracted_position), _g_object_unref0 (_tmp2_), _tmp3_);
		self->priv->view_type = UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED;
		self->priv->scroll_position = old_scroll_position;
		unity_launcher_scroller_view_order_children (self, TRUE);
		self->priv->view_type = UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED;
		self->priv->scroll_position = new_scroll_position;
		unity_launcher_scroller_view_order_children (self, FALSE);
		clutter_actor_queue_relayout ((ClutterActor*) self);
	}
}


static void unity_launcher_scroller_view_contract_launcher (UnityLauncherScrollerView* self) {
	g_return_if_fail (self != NULL);
	if (self->priv->view_type == UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED) {
		return;
	}
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			if (unity_launcher_scroller_child_get_active (child)) {
				self->priv->focused_launcher = unity_launcher_scroller_model_index_of (self->priv->_model, child);
			}
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	self->priv->view_type = UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED;
	unity_launcher_scroller_view_order_children (self, FALSE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
	unity_launcher_scroller_view_set_is_autoscrolling (self, FALSE);
}


static void _lambda54_ (UnityLauncherScrollerView* self) {
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static void __lambda54__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_lambda54_ (self);
}


static void unity_launcher_scroller_view_model_child_added (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (child != NULL);
	clutter_actor_unparent ((ClutterActor*) child);
	clutter_actor_set_parent ((ClutterActor*) child, (ClutterActor*) self);
	if (unity_launcher_scroller_model_index_of (self->priv->_model, child) == (unity_launcher_scroller_model_get_size (self->priv->_model) - 1)) {
		unity_launcher_scroller_view_order_children (self, TRUE);
	} else {
		unity_launcher_scroller_view_order_children (self, FALSE);
	}
	clutter_actor_queue_relayout ((ClutterActor*) self);
	g_signal_connect_object ((GObject*) child, "notify::position", (GCallback) __lambda54__g_object_notify, self, 0);
	clutter_actor_set_reactive ((ClutterActor*) child, FALSE);
}


static void _lambda55_ (Block10Data* _data10_) {
	UnityLauncherScrollerView * self;
	self = _data10_->self;
	clutter_actor_unparent ((ClutterActor*) _data10_->child);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->child_refs, _data10_->child);
}


static void __lambda55__clutter_animation_completed (ClutterAnimation* _sender, gpointer self) {
	_lambda55_ (self);
}


static Block10Data* block10_data_ref (Block10Data* _data10_) {
	g_atomic_int_inc (&_data10_->_ref_count_);
	return _data10_;
}


static void block10_data_unref (Block10Data* _data10_) {
	if (g_atomic_int_dec_and_test (&_data10_->_ref_count_)) {
		_g_object_unref0 (_data10_->self);
		_g_object_unref0 (_data10_->child);
		g_slice_free (Block10Data, _data10_);
	}
}


static void unity_launcher_scroller_view_model_child_removed (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child) {
	Block10Data* _data10_;
	ClutterAnimation* anim;
	g_return_if_fail (self != NULL);
	g_return_if_fail (child != NULL);
	_data10_ = g_slice_new0 (Block10Data);
	_data10_->_ref_count_ = 1;
	_data10_->self = g_object_ref (self);
	_data10_->child = _g_object_ref0 (child);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->child_refs, _data10_->child);
	anim = _g_object_ref0 (clutter_actor_animate ((ClutterActor*) _data10_->child, (gulong) CLUTTER_EASE_OUT_QUAD, UNITY_LAUNCHER_SHORT_DELAY, "opacity", 0, NULL));
	g_signal_connect_data (anim, "completed", (GCallback) __lambda55__clutter_animation_completed, block10_data_ref (_data10_), (GClosureNotify) block10_data_unref, 0);
	unity_launcher_scroller_view_order_children (self, FALSE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
	_g_object_unref0 (anim);
	block10_data_unref (_data10_);
}


static void unity_launcher_scroller_view_model_order_changed (UnityLauncherScrollerView* self) {
	g_return_if_fail (self != NULL);
	unity_launcher_scroller_view_order_children (self, FALSE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static gboolean _lambda56_ (UnityLauncherScrollerView* self) {
	gboolean result = FALSE;
	float speed;
	speed = 12.0f - self->priv->autoscroll_mouse_pos_cache;
	speed = speed / 12.0f;
	speed = speed * ((float) self->priv->autoscroll_direction);
	unity_launcher_scroller_view_move_scroll_position (self, speed, TRUE);
	self->priv->autoscroll_anim_active = self->priv->_is_autoscrolling;
	result = self->priv->_is_autoscrolling;
	return result;
}


static gboolean __lambda56__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda56_ (self);
	return result;
}


static void unity_launcher_scroller_view_on_auto_scrolling_state_change (UnityLauncherScrollerView* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	if (self->priv->autoscroll_anim_active == FALSE) {
		_tmp0_ = self->priv->_is_autoscrolling;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 33, __lambda56__gsource_func, g_object_ref (self), g_object_unref);
	}
}


static gboolean _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_button_release_event (self, event);
	return result;
}


static gboolean unity_launcher_scroller_view_on_button_press_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if ((*event).button.button != 1) {
		result = FALSE;
		return result;
	}
	self->priv->button_down = TRUE;
	self->priv->previous_y_position = (*event).button.y;
	self->priv->previous_y_time = (guint) (*event).button.time;
	g_signal_connect_object (clutter_actor_get_stage ((ClutterActor*) self), "button-release-event", (GCallback) _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event, self, 0);
	result = FALSE;
	return result;
}


static gboolean unity_launcher_scroller_view_on_button_release_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	guint _tmp0_;
	MenuManager* manager;
	g_return_val_if_fail (self != NULL, FALSE);
	if ((*event).button.button != 1) {
		result = FALSE;
		return result;
	}
	self->priv->button_down = FALSE;
	g_signal_parse_name ("button-release-event", CLUTTER_TYPE_ACTOR, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (clutter_actor_get_stage ((ClutterActor*) self), G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event, self);
	unity_shell_remove_fullscreen_request (unity_global_shell, (GObject*) self);
	if (self->priv->is_scrolling) {
		guint _tmp1_;
		self->priv->is_scrolling = FALSE;
		clutter_ungrab_pointer ();
		g_signal_parse_name ("motion-event", CLUTTER_TYPE_ACTOR, &_tmp1_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (clutter_actor_get_stage ((ClutterActor*) self), G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self);
		if (((*event).button.time - self->priv->last_motion_event_time) > 120) {
			self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING;
			self->priv->settle_position = unity_launcher_scroller_view_get_aligned_settle_position (self);
		} else {
			self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG;
		}
		self->priv->disable_child_events = TRUE;
		clutter_timeline_start (self->fling_timeline);
	}
	manager = menu_manager_get_default ();
	menu_manager_popdown_current_menu (manager);
	result = FALSE;
	_g_object_unref0 (manager);
	return result;
}


static gboolean unity_launcher_scroller_view_on_enter_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->queue_contract_launcher != 0) {
		g_source_remove (self->priv->queue_contract_launcher);
		self->priv->queue_contract_launcher = (guint) 0;
	}
	unity_launcher_scroller_view_expand_launcher (self, (*event).crossing.y);
	result = FALSE;
	return result;
}


static gboolean unity_launcher_scroller_view_on_queue_contract_launcher (UnityLauncherScrollerView* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->queue_contract_launcher != 0) {
		unity_launcher_scroller_view_contract_launcher (self);
	}
	self->priv->queue_contract_launcher = (guint) 0;
	result = FALSE;
	return result;
}


static gboolean _unity_launcher_scroller_view_on_queue_contract_launcher_gsource_func (gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_queue_contract_launcher (self);
	return result;
}


static gboolean unity_launcher_scroller_view_do_queue_contract_launcher (UnityLauncherScrollerView* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	self->priv->queue_contract_launcher = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 250, _unity_launcher_scroller_view_on_queue_contract_launcher_gsource_func, g_object_ref (self), g_object_unref);
	result = FALSE;
	return result;
}


static gboolean unity_launcher_scroller_view_on_leave_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	self->priv->last_known_pointer_x = (float) 200;
	if (self->priv->is_scrolling) {
		result = FALSE;
		return result;
	}
	unity_launcher_scroller_view_do_queue_contract_launcher (self);
	if (CLUTTER_IS_ACTOR (self->priv->last_picked_actor)) {
		_tmp0_ = self->priv->last_picked_actor != CLUTTER_ACTOR (self);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		ClutterActor* _tmp1_;
		clutter_actor_event (self->priv->last_picked_actor, event, FALSE);
		self->priv->last_picked_actor = (_tmp1_ = NULL, _g_object_unref0 (self->priv->last_picked_actor), _tmp1_);
	}
	result = FALSE;
	return result;
}


static gboolean unity_launcher_scroller_view_on_autoscroll_motion_check (UnityLauncherScrollerView* self, float y) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (unity_launcher_scroller_view_get_total_children_height (self) < unity_launcher_scroller_view_get_available_height (self)) {
		unity_launcher_scroller_view_set_is_autoscrolling (self, FALSE);
	} else {
		float pos_x = 0.0F;
		float pos_y = 0.0F;
		float transformed_y;
		gboolean _tmp0_ = FALSE;
		clutter_actor_get_transformed_position ((ClutterActor*) self, &pos_x, &pos_y);
		transformed_y = y - pos_y;
		self->priv->autoscroll_mouse_pos_cache = transformed_y;
		if (transformed_y > (clutter_actor_get_height ((ClutterActor*) self) / 2)) {
			self->priv->autoscroll_direction = -1;
			self->priv->autoscroll_mouse_pos_cache = self->priv->autoscroll_mouse_pos_cache - clutter_actor_get_height ((ClutterActor*) self);
		} else {
			self->priv->autoscroll_direction = 1;
		}
		if (transformed_y < 12) {
			_tmp0_ = TRUE;
		} else {
			_tmp0_ = transformed_y > (clutter_actor_get_height ((ClutterActor*) self) - 12);
		}
		if (_tmp0_) {
			unity_launcher_scroller_view_set_is_autoscrolling (self, TRUE);
		} else {
			unity_launcher_scroller_view_set_is_autoscrolling (self, FALSE);
		}
	}
	result = FALSE;
	return result;
}


static void unity_launcher_scroller_view_on_drag_motion_event (UnityLauncherScrollerView* self, UnityDragModel* model, float x, float y) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (model != NULL);
	unity_launcher_scroller_view_on_autoscroll_motion_check (self, y);
}


static gboolean unity_launcher_scroller_view_on_motion_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	UnityDragController* drag_controller;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	unity_launcher_scroller_view_on_autoscroll_motion_check (self, (*event).motion.y);
	drag_controller = _g_object_ref0 (unity_drag_controller_get_default ());
	if (unity_drag_controller_get_is_dragging (drag_controller)) {
		result = FALSE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	self->priv->last_motion_event_time = (guint) (*event).motion.time;
	if (self->priv->button_down) {
		_tmp1_ = self->priv->is_scrolling == FALSE;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = self->priv->view_type != UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		float diff;
		diff = (*event).motion.y - self->priv->previous_y_position;
		if (fabsf (diff) > self->drag_sensitivity) {
			self->priv->is_scrolling = TRUE;
			unity_shell_add_fullscreen_request (unity_global_shell, (GObject*) self);
			clutter_grab_pointer ((ClutterActor*) self);
			g_signal_connect_object (clutter_actor_get_stage ((ClutterActor*) self), "motion-event", (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self, 0);
		}
	}
	if (self->priv->is_scrolling) {
		float pixel_diff;
		guint time_diff;
		unity_launcher_scroller_view_disable_animations_on_children (self, event);
		pixel_diff = (*event).motion.y - self->priv->previous_y_position;
		time_diff = (guint) ((*event).motion.time - self->priv->previous_y_time);
		self->priv->scroll_speed = pixel_diff / (time_diff / 1000.0f);
		self->priv->previous_y_position = (*event).motion.y;
		self->priv->previous_y_time = (guint) (*event).motion.time;
		unity_launcher_scroller_view_move_scroll_position (self, pixel_diff, FALSE);
		result = TRUE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (drag_controller);
	return result;
}


static void unity_launcher_scroller_view_on_scroller_frame (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	guint delta;
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	delta = clutter_timeline_get_delta (timeline);
	delta = delta + self->priv->stored_delta;
	if (delta <= 16) {
		self->priv->stored_delta = delta;
		return;
	}
	while (TRUE) {
		if (!(delta > 16)) {
			break;
		}
		self->is_animating = TRUE;
		delta = delta - ((guint) 16);
		switch (self->priv->current_phase) {
			case UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING:
			{
				unity_launcher_scroller_view_do_anim_settle (self, timeline, msecs);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG:
			{
				unity_launcher_scroller_view_do_anim_fling (self, timeline, msecs);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE:
			{
				unity_launcher_scroller_view_do_anim_bounce (self, timeline, msecs);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_PHASE_NONE:
			{
				{
					clutter_timeline_stop (timeline);
					self->priv->scroll_speed = 0.0f;
					self->is_animating = FALSE;
					self->priv->disable_child_events = FALSE;
				}
				break;
			}
			default:
			{
				g_assert_not_reached ();
			}
		}
	}
	if (self->priv->current_phase == UNITY_LAUNCHER_SCROLLER_PHASE_NONE) {
		ctk_effect_cache_update_texture_cache (self->priv->_cache);
	} else {
		ctk_effect_cache_invalidate_texture_cache (self->priv->_cache);
	}
	self->priv->stored_delta = delta;
}


static void unity_launcher_scroller_view_do_anim_settle (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	float distance;
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	distance = self->priv->settle_position - self->priv->scroll_position;
	unity_launcher_scroller_view_move_scroll_position (self, distance * 0.2f, FALSE);
	if (fabs ((double) distance) < 1) {
		self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_NONE;
	}
}


static void unity_launcher_scroller_view_do_anim_fling (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	float scroll_move_amount;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	self->priv->scroll_speed = self->priv->scroll_speed * self->friction;
	scroll_move_amount = self->priv->scroll_speed / 60.0f;
	unity_launcher_scroller_view_move_scroll_position (self, scroll_move_amount, FALSE);
	if (scroll_move_amount <= (-1.0)) {
		_tmp1_ = (-self->priv->scroll_position) > (self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self));
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp2_ = FALSE;
		if (scroll_move_amount >= 1.0) {
			_tmp2_ = self->priv->scroll_position > 0;
		} else {
			_tmp2_ = FALSE;
		}
		_tmp0_ = _tmp2_;
	}
	if (_tmp0_) {
		self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE;
	}
	if (fabsf (scroll_move_amount) < 1.0) {
		gboolean _tmp4_ = FALSE;
		if (self->priv->scroll_position > 0) {
			_tmp4_ = TRUE;
		} else {
			_tmp4_ = (-self->priv->scroll_position) > (self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self));
		}
		_tmp3_ = _tmp4_;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		self->priv->settle_position = unity_launcher_scroller_view_get_aligned_settle_position (self);
		self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING;
	} else {
		if (fabsf (scroll_move_amount) < 1.0) {
			self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_NONE;
		}
	}
}


static void unity_launcher_scroller_view_do_anim_bounce (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	self->priv->scroll_speed = self->priv->scroll_speed * 0.5f;
	unity_launcher_scroller_view_move_scroll_position (self, self->priv->scroll_speed / 60.0f, FALSE);
	self->priv->settle_position = -unity_launcher_scroller_view_get_aligned_settle_position (self);
	self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING;
}


static float unity_launcher_scroller_view_get_aligned_settle_position (UnityLauncherScrollerView* self) {
	float result = 0.0F;
	float final_position;
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	g_return_val_if_fail (self != NULL, 0.0F);
	final_position = self->priv->scroll_position;
	if (self->priv->total_child_height < ((clutter_actor_get_height ((ClutterActor*) self) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.top)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom))) {
		final_position = (float) 0;
	} else {
		if (self->priv->scroll_position > 0) {
			final_position = (float) 0;
		} else {
			CtkPadding _tmp2_ = {0};
			CtkPadding _tmp3_ = {0};
			if ((-self->priv->scroll_position) > (((self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.top)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.bottom))) {
				CtkPadding _tmp4_ = {0};
				final_position = (self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self)) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp4_), _tmp4_.bottom);
			}
		}
	}
	result = final_position;
	return result;
}


static void unity_launcher_scroller_view_real_get_preferred_width (ClutterActor* base, float for_height, float* minimum_width, float* natural_width) {
	UnityLauncherScrollerView * self;
	float pmin_width;
	float pnat_width;
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	CtkPadding _tmp2_ = {0};
	CtkPadding _tmp3_ = {0};
	self = (UnityLauncherScrollerView*) base;
	*minimum_width = (float) 0;
	*natural_width = (float) 0;
	pmin_width = 0.0f;
	pnat_width = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			float cmin_width;
			float cnat_width;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			cmin_width = 0.0f;
			cnat_width = 0.0f;
			clutter_actor_get_preferred_width ((ClutterActor*) child, for_height, &cmin_width, &cnat_width);
			pmin_width = MAX (pmin_width, cmin_width);
			pnat_width = MAX (pnat_width, cnat_width);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	pmin_width = pmin_width + ((ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.left) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.right));
	pnat_width = pnat_width + ((ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.left) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.right));
	*minimum_width = pmin_width;
	*natural_width = pnat_width;
}


static void unity_launcher_scroller_view_real_get_preferred_height (ClutterActor* base, float for_width, float* minimum_height, float* natural_height) {
	UnityLauncherScrollerView * self;
	float cnat_height;
	float cmin_height;
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	CtkPadding _tmp2_ = {0};
	CtkPadding _tmp3_ = {0};
	self = (UnityLauncherScrollerView*) base;
	*minimum_height = 0.0f;
	*natural_height = 0.0f;
	cnat_height = 0.0f;
	cmin_height = 0.0f;
	self->priv->total_child_height = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			cnat_height = 0.0f;
			cmin_height = 0.0f;
			clutter_actor_get_preferred_height ((ClutterActor*) child, for_width, &cmin_height, &cnat_height);
			self->priv->total_child_height = self->priv->total_child_height + (cnat_height + self->spacing);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	*minimum_height = (self->priv->total_child_height + (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.top)) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom);
	*natural_height = (self->priv->total_child_height + (ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.top)) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.bottom);
	return;
}


static void unity_launcher_scroller_view_order_children (UnityLauncherScrollerView* self, gboolean immediate) {
	GeeArrayList* transitions;
	g_return_if_fail (self != NULL);
	transitions = NULL;
	if (unity_launcher_scroller_view_get_total_children_height (self) < unity_launcher_scroller_view_get_available_height (self)) {
		GeeArrayList* _tmp0_;
		transitions = (_tmp0_ = unity_launcher_scroller_view_order_children_expanded (self), _g_object_unref0 (transitions), _tmp0_);
	} else {
		switch (self->priv->view_type) {
			case UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED:
			{
				GeeArrayList* _tmp1_;
				transitions = (_tmp1_ = unity_launcher_scroller_view_order_children_contracted (self), _g_object_unref0 (transitions), _tmp1_);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED:
			{
				GeeArrayList* _tmp2_;
				transitions = (_tmp2_ = unity_launcher_scroller_view_order_children_expanded (self), _g_object_unref0 (transitions), _tmp2_);
				break;
			}
			default:
			{
				g_assert_not_reached ();
			}
		}
	}
	{
		gint index;
		index = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				if (!_tmp3_) {
					index++;
				}
				_tmp3_ = FALSE;
				if (!(index < unity_launcher_scroller_model_get_size (self->priv->_model))) {
					break;
				}
				child = unity_launcher_scroller_model_get (self->priv->_model, index);
				if (immediate) {
					UnityLauncherChildTransition* _tmp4_;
					UnityLauncherChildTransition* _tmp5_;
					unity_launcher_scroller_child_set_position (child, (_tmp4_ = (UnityLauncherChildTransition*) gee_abstract_list_get ((GeeAbstractList*) transitions, index))->position);
					_unity_launcher_child_transition_unref0 (_tmp4_);
					unity_launcher_scroller_child_force_rotation_jump (child, (_tmp5_ = (UnityLauncherChildTransition*) gee_abstract_list_get ((GeeAbstractList*) transitions, index))->rotation);
					_unity_launcher_child_transition_unref0 (_tmp5_);
				} else {
					gboolean do_new_position;
					UnityLauncherChildTransition* _tmp8_;
					do_new_position = TRUE;
					if (CLUTTER_IS_ANIMATION (clutter_actor_get_animation ((ClutterActor*) child))) {
						GValue value = {0};
						ClutterInterval* interval;
						UnityLauncherChildTransition* _tmp6_;
						gboolean _tmp7_;
						g_value_init (&value, G_TYPE_FLOAT);
						interval = _g_object_ref0 (clutter_animation_get_interval (clutter_actor_get_animation ((ClutterActor*) child), "position"));
						if (CLUTTER_IS_INTERVAL (interval)) {
							clutter_interval_get_final_value (interval, &value);
						}
						if ((_tmp7_ = g_value_get_float (&value) != (_tmp6_ = (UnityLauncherChildTransition*) gee_abstract_list_get ((GeeAbstractList*) transitions, index))->position, _unity_launcher_child_transition_unref0 (_tmp6_), _tmp7_)) {
							float current_pos;
							current_pos = unity_launcher_scroller_child_get_position (child);
							clutter_animation_completed (clutter_actor_get_animation ((ClutterActor*) child));
							unity_launcher_scroller_child_set_position (child, current_pos);
						} else {
							do_new_position = FALSE;
						}
						_g_object_unref0 (interval);
						G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
					}
					unity_launcher_scroller_child_set_rotation (child, (_tmp8_ = (UnityLauncherChildTransition*) gee_abstract_list_get ((GeeAbstractList*) transitions, index))->rotation);
					_unity_launcher_child_transition_unref0 (_tmp8_);
					if (do_new_position) {
						UnityLauncherChildTransition* _tmp9_;
						clutter_actor_animate ((ClutterActor*) child, (gulong) CLUTTER_EASE_IN_OUT_QUAD, (guint) 300, "position", (_tmp9_ = (UnityLauncherChildTransition*) gee_abstract_list_get ((GeeAbstractList*) transitions, index))->position, NULL);
						_unity_launcher_child_transition_unref0 (_tmp9_);
					}
				}
				_g_object_unref0 (child);
			}
		}
	}
	_g_object_unref0 (transitions);
}


static GeeArrayList* unity_launcher_scroller_view_order_children_expanded (UnityLauncherScrollerView* self) {
	GeeArrayList* result = NULL;
	GeeArrayList* ret_transitions;
	float h;
	float min_height = 0.0F;
	float nat_height = 0.0F;
	GeeArrayList* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	ret_transitions = gee_array_list_new (UNITY_LAUNCHER_TYPE_CHILD_TRANSITION, (GBoxedCopyFunc) unity_launcher_child_transition_ref, unity_launcher_child_transition_unref, NULL);
	h = 0.0f;
	if (!GEE_IS_ARRAY_LIST (self->priv->draw_ftb)) {
		GeeArrayList* _tmp0_;
		self->priv->draw_ftb = (_tmp0_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->draw_ftb), _tmp0_);
	}
	self->priv->draw_btf = (_tmp1_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->draw_btf), _tmp1_);
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			UnityLauncherChildTransition* transition;
			gboolean _tmp2_ = FALSE;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_get_preferred_height ((ClutterActor*) child, clutter_actor_get_width ((ClutterActor*) self), &min_height, &nat_height);
			transition = unity_launcher_child_transition_new ();
			transition->position = h + self->priv->scroll_position;
			transition->rotation = 0.0f;
			gee_abstract_collection_add ((GeeAbstractCollection*) ret_transitions, transition);
			if (gee_abstract_collection_contains ((GeeAbstractCollection*) self->priv->draw_ftb, child)) {
				_tmp2_ = TRUE;
			} else {
				_tmp2_ = gee_abstract_collection_contains ((GeeAbstractCollection*) self->priv->draw_ftb, child);
			}
			if (!_tmp2_) {
				gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->draw_ftb, child);
			}
			h = h + (nat_height + self->spacing);
			_unity_launcher_child_transition_unref0 (transition);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	result = ret_transitions;
	return result;
}


static GeeArrayList* unity_launcher_scroller_view_order_children_contracted (UnityLauncherScrollerView* self) {
	GeeArrayList* result = NULL;
	GeeArrayList* ret_transitions;
	float h;
	float min_height = 0.0F;
	float nat_height = 0.0F;
	gint num_launchers;
	float total_child_height;
	gint num_children_handled;
	gint index_start_flat = 0;
	gint index_end_flat;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	ret_transitions = gee_array_list_new (UNITY_LAUNCHER_TYPE_CHILD_TRANSITION, (GBoxedCopyFunc) unity_launcher_child_transition_ref, unity_launcher_child_transition_unref, NULL);
	h = 0.0f;
	num_launchers = 0;
	total_child_height = unity_launcher_scroller_view_get_total_children_height (self);
	if (total_child_height > unity_launcher_scroller_view_get_available_height (self)) {
		num_launchers = (gint) floorf ((unity_launcher_scroller_view_get_available_height (self) - (self->spacing * 2)) / (48.0f + self->spacing));
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				float flat_space;
				float contracted_space;
				if (!_tmp0_) {
					num_launchers--;
				}
				_tmp0_ = FALSE;
				if (!(num_launchers >= 1)) {
					break;
				}
				flat_space = num_launchers * (48.0f + self->spacing);
				contracted_space = 0.0f;
				contracted_space = (float) ((unity_launcher_scroller_model_get_size (self->priv->_model) - num_launchers) * (8 + self->spacing));
				if (((flat_space + self->spacing) + contracted_space) < (unity_launcher_scroller_view_get_available_height (self) - (self->spacing * 2))) {
					break;
				}
			}
		}
		num_launchers = MAX (num_launchers, 1);
	} else {
		num_launchers = unity_launcher_scroller_model_get_size (self->priv->_model);
	}
	num_children_handled = 0;
	index_end_flat = 0;
	if (self->priv->focused_launcher < (unity_launcher_scroller_model_get_size (self->priv->_model) - (num_launchers - (num_launchers / 2)))) {
		index_start_flat = MAX (0, self->priv->focused_launcher - (num_launchers / 2));
		index_end_flat = index_start_flat + num_launchers;
	} else {
		index_end_flat = unity_launcher_scroller_model_get_size (self->priv->_model);
		index_start_flat = index_end_flat - num_launchers;
	}
	self->priv->draw_ftb = (_tmp1_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->draw_ftb), _tmp1_);
	self->priv->draw_btf = (_tmp2_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->draw_btf), _tmp2_);
	{
		gint index;
		index = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				UnityLauncherChildTransition* transition;
				gboolean _tmp4_ = FALSE;
				if (!_tmp3_) {
					index++;
				}
				_tmp3_ = FALSE;
				if (!(index < unity_launcher_scroller_model_get_size (self->priv->_model))) {
					break;
				}
				child = unity_launcher_scroller_model_get (self->priv->_model, index);
				transition = unity_launcher_child_transition_new ();
				clutter_actor_get_preferred_height ((ClutterActor*) child, clutter_actor_get_width ((ClutterActor*) self), &min_height, &nat_height);
				if (index >= index_start_flat) {
					_tmp4_ = index < index_end_flat;
				} else {
					_tmp4_ = FALSE;
				}
				if (_tmp4_) {
					transition->position = h;
					h = h + (nat_height + self->spacing);
					num_children_handled++;
					transition->rotation = 0.0f;
					if (index == index_start_flat) {
						gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->draw_ftb, child);
					} else {
						gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->draw_btf, child);
					}
				} else {
					if (index == index_end_flat) {
						h = h - ((nat_height * 0.3333f) - self->spacing);
					}
					if (num_children_handled < index_start_flat) {
						if (num_children_handled == (index_start_flat - 1)) {
							transition->rotation = -self->priv->contract_icon_partial_degrees;
							h = h + ((float) self->spacing);
						} else {
							transition->rotation = -self->priv->contract_icon_degrees;
						}
						transition->position = h;
						gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->draw_ftb, child);
					} else {
						transition->position = h;
						if (index == index_end_flat) {
							transition->rotation = self->priv->contract_icon_partial_degrees;
							h = h + ((float) self->spacing);
						} else {
							transition->rotation = self->priv->contract_icon_degrees;
						}
						gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->draw_btf, child);
					}
					h = h + ((float) (8 + self->spacing));
					num_children_handled++;
					if ((index + 1) == index_start_flat) {
						h = h + ((float) 30);
					}
				}
				gee_abstract_collection_add ((GeeAbstractCollection*) ret_transitions, transition);
				_unity_launcher_child_transition_unref0 (transition);
				_g_object_unref0 (child);
			}
		}
	}
	result = ret_transitions;
	return result;
}


static float unity_launcher_scroller_view_get_total_children_height (UnityLauncherScrollerView* self) {
	float result = 0.0F;
	float h;
	float min_height = 0.0F;
	float nat_height = 0.0F;
	g_return_val_if_fail (self != NULL, 0.0F);
	h = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_get_preferred_height ((ClutterActor*) child, clutter_actor_get_width ((ClutterActor*) self), &min_height, &nat_height);
			h = h + (nat_height + self->spacing);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	result = h;
	return result;
}


static float unity_launcher_scroller_view_get_available_height (UnityLauncherScrollerView* self) {
	float result = 0.0F;
	ClutterActorBox box = {0};
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	g_return_val_if_fail (self != NULL, 0.0F);
	ctk_actor_get_stored_allocation ((CtkActor*) self, &box);
	result = (clutter_actor_box_get_height (&box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.top)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom);
	return result;
}


static void unity_launcher_scroller_view_real_allocate (ClutterActor* base, const ClutterActorBox* box, ClutterAllocationFlags flags) {
	UnityLauncherScrollerView * self;
	ClutterActorBox child_box = {0};
	CtkPadding _tmp0_ = {0};
	float current_width;
	CtkPadding _tmp1_ = {0};
	float available_height;
	CtkPadding _tmp2_ = {0};
	float available_width;
	guint index;
	gint bg_height = 0;
	gint bg_width = 0;
	float bg_offset;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->allocate ((ClutterActor*) CTK_ACTOR (self), box, flags);
	memset (&child_box, 0, sizeof (ClutterActorBox));
	current_width = (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.left);
	available_height = clutter_actor_box_get_height (box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom);
	available_width = clutter_actor_box_get_width (box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.right);
	self->priv->total_child_height = 0.0f;
	index = (guint) 0;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			float child_height = 0.0F;
			float child_width = 0.0F;
			float natural = 0.0F;
			float min = 0.0F;
			CtkPadding _tmp3_ = {0};
			CtkPadding _tmp4_ = {0};
			gboolean _tmp5_ = FALSE;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_get_preferred_width ((ClutterActor*) child, available_height, &min, &natural);
			child_width = fmaxf (min, fminf (natural, available_width));
			clutter_actor_get_preferred_height ((ClutterActor*) child, child_width, &min, &natural);
			child_height = fmaxf (min, fminf (natural, available_height));
			child_box.x1 = current_width;
			child_box.x2 = clutter_actor_box_get_width (box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.right);
			child_box.y1 = unity_launcher_scroller_child_get_position (child) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp4_), _tmp4_.top);
			child_box.y2 = child_box.y1 + child_height;
			clutter_actor_allocate ((ClutterActor*) child, &child_box, flags);
			clutter_actor_remove_clip ((ClutterActor*) child);
			if (child_box.y1 < 0) {
				clutter_actor_set_clip ((ClutterActor*) child, (float) 0, fabsf (child_box.y1), clutter_actor_box_get_width (&child_box), clutter_actor_box_get_height (&child_box) - child_box.y1);
			}
			self->priv->total_child_height = self->priv->total_child_height + (child_height + self->spacing);
			if (index >= 0) {
				_tmp5_ = index <= 9;
			} else {
				_tmp5_ = FALSE;
			}
			if (_tmp5_) {
				ClutterActor* keyboard_indicator;
				keyboard_indicator = NULL;
				if (index == 0) {
					ClutterActor* _tmp6_;
					keyboard_indicator = (_tmp6_ = _g_object_ref0 ((ClutterActor*) self->priv->keyboard_indicator_1), _g_object_unref0 (keyboard_indicator), _tmp6_);
				} else {
					if (index == 1) {
						ClutterActor* _tmp7_;
						keyboard_indicator = (_tmp7_ = _g_object_ref0 ((ClutterActor*) self->priv->keyboard_indicator_2), _g_object_unref0 (keyboard_indicator), _tmp7_);
					} else {
						if (index == 2) {
							ClutterActor* _tmp8_;
							keyboard_indicator = (_tmp8_ = _g_object_ref0 ((ClutterActor*) self->priv->keyboard_indicator_3), _g_object_unref0 (keyboard_indicator), _tmp8_);
						} else {
							if (index == 3) {
								ClutterActor* _tmp9_;
								keyboard_indicator = (_tmp9_ = _g_object_ref0 ((ClutterActor*) self->priv->keyboard_indicator_4), _g_object_unref0 (keyboard_indicator), _tmp9_);
							} else {
								if (index == 4) {
									ClutterActor* _tmp10_;
									keyboard_indicator = (_tmp10_ = _g_object_ref0 ((ClutterActor*) self->priv->keyboard_indicator_5), _g_object_unref0 (keyboard_indicator), _tmp10_);
								} else {
									if (index == 5) {
										ClutterActor* _tmp11_;
										keyboard_indicator = (_tmp11_ = _g_object_ref0 ((ClutterActor*) self->priv->keyboard_indicator_6), _g_object_unref0 (keyboard_indicator), _tmp11_);
									} else {
										if (index == 6) {
											ClutterActor* _tmp12_;
											keyboard_indicator = (_tmp12_ = _g_object_ref0 ((ClutterActor*) self->priv->keyboard_indicator_7), _g_object_unref0 (keyboard_indicator), _tmp12_);
										} else {
											if (index == 7) {
												ClutterActor* _tmp13_;
												keyboard_indicator = (_tmp13_ = _g_object_ref0 ((ClutterActor*) self->priv->keyboard_indicator_8), _g_object_unref0 (keyboard_indicator), _tmp13_);
											} else {
												if (index == 8) {
													ClutterActor* _tmp14_;
													keyboard_indicator = (_tmp14_ = _g_object_ref0 ((ClutterActor*) self->priv->keyboard_indicator_9), _g_object_unref0 (keyboard_indicator), _tmp14_);
												} else {
													if (index == 9) {
														ClutterActor* _tmp15_;
														keyboard_indicator = (_tmp15_ = _g_object_ref0 ((ClutterActor*) self->priv->keyboard_indicator_0), _g_object_unref0 (keyboard_indicator), _tmp15_);
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				if (CLUTTER_IS_ACTOR (keyboard_indicator)) {
					CtkPadding _tmp16_ = {0};
					CtkPadding _tmp17_ = {0};
					child_box.x1 = (clutter_actor_box_get_width (box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp16_), _tmp16_.right)) - clutter_actor_get_width (keyboard_indicator);
					child_box.x2 = child_box.x1 + clutter_actor_get_width (keyboard_indicator);
					child_box.y1 = ((unity_launcher_scroller_child_get_position (child) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp17_), _tmp17_.top)) + child_height) - clutter_actor_get_height (keyboard_indicator);
					child_box.y2 = child_box.y1 + clutter_actor_get_height (keyboard_indicator);
					clutter_actor_allocate (keyboard_indicator, &child_box, flags);
				}
				index = index + ((guint) 1);
				_g_object_unref0 (keyboard_indicator);
			}
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	child_box.x1 = (float) 0;
	child_box.x2 = clutter_actor_box_get_width (box);
	clutter_texture_get_base_size ((ClutterTexture*) self->priv->bgtex, &bg_width, &bg_height);
	bg_offset = fmodf (self->priv->scroll_position + 1000000, (float) bg_height);
	child_box.y1 = bg_offset - (bg_height - 1);
	child_box.y2 = (bg_offset + (bg_height - 1)) + clutter_actor_box_get_height (box);
	clutter_actor_allocate ((ClutterActor*) self->priv->bgtex, &child_box, flags);
	clutter_texture_get_base_size ((ClutterTexture*) self->priv->top_shadow, &bg_width, &bg_height);
	child_box.y1 = (float) (-1);
	child_box.y2 = (float) (bg_height - 1);
	clutter_actor_allocate ((ClutterActor*) self->priv->top_shadow, &child_box, flags);
}


static void unity_launcher_scroller_view_real_pick (ClutterActor* base, const ClutterColor* color) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->pick ((ClutterActor*) CTK_ACTOR (self), color);
	{
		gint index;
		index = gee_collection_get_size ((GeeCollection*) self->priv->draw_btf) - 1;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				gboolean _tmp1_ = FALSE;
				if (!_tmp0_) {
					index--;
				}
				_tmp0_ = FALSE;
				if (!(index >= 0)) {
					break;
				}
				child = (UnityLauncherScrollerChild*) gee_abstract_list_get ((GeeAbstractList*) self->priv->draw_btf, index);
				if (UNITY_LAUNCHER_IS_SCROLLER_CHILD (child)) {
					_tmp1_ = clutter_actor_get_opacity ((ClutterActor*) child) > 0;
				} else {
					_tmp1_ = FALSE;
				}
				if (_tmp1_) {
					UnityLauncherScrollerChild* _tmp2_;
					clutter_actor_paint ((ClutterActor*) (_tmp2_ = child, UNITY_LAUNCHER_IS_SCROLLER_CHILD (_tmp2_) ? ((UnityLauncherScrollerChild*) _tmp2_) : NULL));
				}
				_g_object_unref0 (child);
			}
		}
	}
	{
		GeeIterator* _child_it;
		_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->draw_ftb);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			gboolean _tmp3_ = FALSE;
			if (!gee_iterator_next (_child_it)) {
				break;
			}
			child = (UnityLauncherScrollerChild*) gee_iterator_get (_child_it);
			if (UNITY_LAUNCHER_IS_SCROLLER_CHILD (child)) {
				_tmp3_ = clutter_actor_get_opacity ((ClutterActor*) child) > 0;
			} else {
				_tmp3_ = FALSE;
			}
			if (_tmp3_) {
				UnityLauncherScrollerChild* _tmp4_;
				clutter_actor_paint ((ClutterActor*) (_tmp4_ = child, UNITY_LAUNCHER_IS_SCROLLER_CHILD (_tmp4_) ? ((UnityLauncherScrollerChild*) _tmp4_) : NULL));
			}
			_g_object_unref0 (child);
		}
		_g_object_unref0 (_child_it);
	}
	{
		GeeIterator* _child_it;
		_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->child_refs);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!gee_iterator_next (_child_it)) {
				break;
			}
			child = (UnityLauncherScrollerChild*) gee_iterator_get (_child_it);
			clutter_actor_paint ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_g_object_unref0 (_child_it);
	}
}


static void unity_launcher_scroller_view_real_paint (ClutterActor* base) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	clutter_actor_paint ((ClutterActor*) self->priv->bgtex);
	{
		gint index;
		index = gee_collection_get_size ((GeeCollection*) self->priv->draw_btf) - 1;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				gboolean _tmp1_ = FALSE;
				if (!_tmp0_) {
					index--;
				}
				_tmp0_ = FALSE;
				if (!(index >= 0)) {
					break;
				}
				child = (UnityLauncherScrollerChild*) gee_abstract_list_get ((GeeAbstractList*) self->priv->draw_btf, index);
				if (UNITY_LAUNCHER_IS_SCROLLER_CHILD (child)) {
					_tmp1_ = clutter_actor_get_opacity ((ClutterActor*) child) > 0;
				} else {
					_tmp1_ = FALSE;
				}
				if (_tmp1_) {
					UnityLauncherScrollerChild* _tmp2_;
					clutter_actor_paint ((ClutterActor*) (_tmp2_ = child, UNITY_LAUNCHER_IS_SCROLLER_CHILD (_tmp2_) ? ((UnityLauncherScrollerChild*) _tmp2_) : NULL));
				}
				_g_object_unref0 (child);
			}
		}
	}
	{
		GeeIterator* _child_it;
		_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->draw_ftb);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			gboolean _tmp3_ = FALSE;
			if (!gee_iterator_next (_child_it)) {
				break;
			}
			child = (UnityLauncherScrollerChild*) gee_iterator_get (_child_it);
			if (UNITY_LAUNCHER_IS_SCROLLER_CHILD (child)) {
				_tmp3_ = clutter_actor_get_opacity ((ClutterActor*) child) > 0;
			} else {
				_tmp3_ = FALSE;
			}
			if (_tmp3_) {
				UnityLauncherScrollerChild* _tmp4_;
				clutter_actor_paint ((ClutterActor*) (_tmp4_ = child, UNITY_LAUNCHER_IS_SCROLLER_CHILD (_tmp4_) ? ((UnityLauncherScrollerChild*) _tmp4_) : NULL));
			}
			_g_object_unref0 (child);
		}
		_g_object_unref0 (_child_it);
	}
	{
		GeeIterator* _child_it;
		_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->child_refs);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!gee_iterator_next (_child_it)) {
				break;
			}
			child = (UnityLauncherScrollerChild*) gee_iterator_get (_child_it);
			clutter_actor_paint ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_g_object_unref0 (_child_it);
	}
	clutter_actor_paint ((ClutterActor*) self->priv->keyboard_indicator_1);
	clutter_actor_paint ((ClutterActor*) self->priv->keyboard_indicator_2);
	clutter_actor_paint ((ClutterActor*) self->priv->keyboard_indicator_3);
	clutter_actor_paint ((ClutterActor*) self->priv->keyboard_indicator_4);
	clutter_actor_paint ((ClutterActor*) self->priv->keyboard_indicator_5);
	clutter_actor_paint ((ClutterActor*) self->priv->keyboard_indicator_6);
	clutter_actor_paint ((ClutterActor*) self->priv->keyboard_indicator_7);
	clutter_actor_paint ((ClutterActor*) self->priv->keyboard_indicator_8);
	clutter_actor_paint ((ClutterActor*) self->priv->keyboard_indicator_9);
	clutter_actor_paint ((ClutterActor*) self->priv->keyboard_indicator_0);
	clutter_actor_paint ((ClutterActor*) self->priv->top_shadow);
}


static void unity_launcher_scroller_view_real_map (ClutterActor* base) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->map ((ClutterActor*) CTK_ACTOR (self));
	clutter_actor_map ((ClutterActor*) self->priv->bgtex);
	clutter_actor_map ((ClutterActor*) self->priv->top_shadow);
	clutter_actor_map ((ClutterActor*) self->priv->keyboard_indicator_1);
	clutter_actor_map ((ClutterActor*) self->priv->keyboard_indicator_2);
	clutter_actor_map ((ClutterActor*) self->priv->keyboard_indicator_3);
	clutter_actor_map ((ClutterActor*) self->priv->keyboard_indicator_4);
	clutter_actor_map ((ClutterActor*) self->priv->keyboard_indicator_5);
	clutter_actor_map ((ClutterActor*) self->priv->keyboard_indicator_6);
	clutter_actor_map ((ClutterActor*) self->priv->keyboard_indicator_7);
	clutter_actor_map ((ClutterActor*) self->priv->keyboard_indicator_8);
	clutter_actor_map ((ClutterActor*) self->priv->keyboard_indicator_9);
	clutter_actor_map ((ClutterActor*) self->priv->keyboard_indicator_0);
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_map ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


static void unity_launcher_scroller_view_real_unmap (ClutterActor* base) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->unmap ((ClutterActor*) CTK_ACTOR (self));
	clutter_actor_map ((ClutterActor*) self->priv->bgtex);
	clutter_actor_map ((ClutterActor*) self->priv->top_shadow);
	clutter_actor_unmap ((ClutterActor*) self->priv->keyboard_indicator_1);
	clutter_actor_unmap ((ClutterActor*) self->priv->keyboard_indicator_2);
	clutter_actor_unmap ((ClutterActor*) self->priv->keyboard_indicator_3);
	clutter_actor_unmap ((ClutterActor*) self->priv->keyboard_indicator_4);
	clutter_actor_unmap ((ClutterActor*) self->priv->keyboard_indicator_5);
	clutter_actor_unmap ((ClutterActor*) self->priv->keyboard_indicator_6);
	clutter_actor_unmap ((ClutterActor*) self->priv->keyboard_indicator_7);
	clutter_actor_unmap ((ClutterActor*) self->priv->keyboard_indicator_8);
	clutter_actor_unmap ((ClutterActor*) self->priv->keyboard_indicator_9);
	clutter_actor_unmap ((ClutterActor*) self->priv->keyboard_indicator_0);
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_unmap ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


UnityLauncherScrollerModel* unity_launcher_scroller_view_get_model (UnityLauncherScrollerView* self) {
	UnityLauncherScrollerModel* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_model;
	return result;
}


static void unity_launcher_scroller_view_set_model (UnityLauncherScrollerView* self, UnityLauncherScrollerModel* value) {
	UnityLauncherScrollerModel* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_model = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_model), _tmp0_);
	g_object_notify ((GObject *) self, "model");
}


CtkEffectCache* unity_launcher_scroller_view_get_cache (UnityLauncherScrollerView* self) {
	CtkEffectCache* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_cache;
	return result;
}


static void unity_launcher_scroller_view_set_cache (UnityLauncherScrollerView* self, CtkEffectCache* value) {
	CtkEffectCache* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_cache = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_cache), _tmp0_);
	g_object_notify ((GObject *) self, "cache");
}


gboolean unity_launcher_scroller_view_get_is_autoscrolling (UnityLauncherScrollerView* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_autoscrolling;
	return result;
}


void unity_launcher_scroller_view_set_is_autoscrolling (UnityLauncherScrollerView* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_is_autoscrolling = value;
	g_object_notify ((GObject *) self, "is-autoscrolling");
}


static void _unity_launcher_scroller_view_model_child_added_unity_launcher_scroller_model_child_added (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self) {
	unity_launcher_scroller_view_model_child_added (self, child);
}


static void _unity_launcher_scroller_view_model_child_removed_unity_launcher_scroller_model_child_removed (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self) {
	unity_launcher_scroller_view_model_child_removed (self, child);
}


static void _unity_launcher_scroller_view_model_order_changed_unity_launcher_scroller_model_order_changed (UnityLauncherScrollerModel* _sender, gpointer self) {
	unity_launcher_scroller_view_model_order_changed (self);
}


static gboolean _unity_launcher_scroller_view_on_button_press_event_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_button_press_event (self, event);
	return result;
}


static void _unity_launcher_scroller_view_on_auto_scrolling_state_change_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	unity_launcher_scroller_view_on_auto_scrolling_state_change (self);
}


static void _unity_launcher_scroller_view_on_drag_motion_event_unity_drag_controller_drag_motion (UnityDragController* _sender, UnityDragModel* model, float x, float y, gpointer self) {
	unity_launcher_scroller_view_on_drag_motion_event (self, model, x, y);
}


static void _unity_launcher_scroller_view_on_scroller_frame_clutter_timeline_new_frame (ClutterTimeline* _sender, gint msecs, gpointer self) {
	unity_launcher_scroller_view_on_scroller_frame (self, _sender, msecs);
}


static void _lambda57_ (UnityLauncherScrollerView* self) {
	ctk_effect_cache_invalidate_texture_cache (self->priv->_cache);
}


static void __lambda57__clutter_timeline_started (ClutterTimeline* _sender, gpointer self) {
	_lambda57_ (self);
}


static gboolean _lambda59_ (UnityLauncherScrollerView* self) {
	gboolean result = FALSE;
	ctk_effect_cache_update_texture_cache (self->priv->_cache);
	result = FALSE;
	return result;
}


static gboolean __lambda59__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda59_ (self);
	return result;
}


static void _lambda58_ (UnityLauncherScrollerView* self) {
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 0, __lambda59__gsource_func, g_object_ref (self), g_object_unref);
}


static void __lambda58__clutter_timeline_completed (ClutterTimeline* _sender, gpointer self) {
	_lambda58_ (self);
}


static void _lambda60_ (UnityLauncherScrollerView* self) {
	self->priv->is_scrolling = FALSE;
	self->priv->button_down = FALSE;
}


static void __lambda60__unity_drag_controller_drag_start (UnityDragController* _sender, UnityDragModel* model, gpointer self) {
	_lambda60_ (self);
}


static void _lambda61_ (UnityLauncherScrollerView* self) {
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			ClutterActor* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = (ClutterActor*) unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_set_reactive (child, FALSE);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


static void __lambda61__unity_drag_controller_drag_drop (UnityDragController* _sender, UnityDragModel* model, float x, float y, gpointer self) {
	_lambda61_ (self);
}


static gboolean _lambda62_ (UnityLauncherScrollerView* self) {
	gboolean result = FALSE;
	unity_launcher_scroller_view_order_children (self, TRUE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static gboolean __lambda62__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda62_ (self);
	return result;
}


static GObject * unity_launcher_scroller_view_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityLauncherScrollerView * self;
	parent_class = G_OBJECT_CLASS (unity_launcher_scroller_view_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_LAUNCHER_SCROLLER_VIEW (obj);
	{
		UnityTestingObjectRegistry* _tmp0_;
		CtkPadding _tmp1_ = {0};
		CtkPadding mypadding;
		ClutterTimeline* _tmp2_;
		UnityDragController* drag_controller;
		GeeArrayList* _tmp3_;
		g_signal_connect_object ((ClutterActor*) self, "motion-event", (GCallback) _unity_launcher_scroller_view_passthrough_motion_event_clutter_actor_motion_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "button-press-event", (GCallback) _unity_launcher_scroller_view_passthrough_button_press_event_clutter_actor_button_press_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "button-release-event", (GCallback) _unity_launcher_scroller_view_passthrough_button_release_event_clutter_actor_button_release_event, self, 0);
		unity_testing_object_registry_register (_tmp0_ = unity_testing_object_registry_get_default (), "LauncherScrollerView", (GObject*) self);
		_unity_testing_object_registry_unref0 (_tmp0_);
		mypadding = (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_);
		mypadding.left = 0.0f;
		mypadding.right = 0.0f;
		mypadding.top = 10.0f;
		mypadding.bottom = 5.0f;
		ctk_actor_set_padding ((CtkActor*) self, &mypadding);
		unity_launcher_scroller_view_load_textures (self);
		g_signal_connect_object (self->priv->_model, "child-added", (GCallback) _unity_launcher_scroller_view_model_child_added_unity_launcher_scroller_model_child_added, self, 0);
		g_signal_connect_object (self->priv->_model, "child-removed", (GCallback) _unity_launcher_scroller_view_model_child_removed_unity_launcher_scroller_model_child_removed, self, 0);
		g_signal_connect_object (self->priv->_model, "order-changed", (GCallback) _unity_launcher_scroller_view_model_order_changed_unity_launcher_scroller_model_order_changed, self, 0);
		{
			UnityLauncherScrollerModelIterator* _child_it;
			_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
					break;
				}
				child = unity_launcher_scroller_model_iterator_get (_child_it);
				unity_launcher_scroller_view_model_child_added (self, child);
				_g_object_unref0 (child);
			}
			_unity_launcher_scroller_model_iterator_unref0 (_child_it);
		}
		g_signal_connect_object ((ClutterActor*) self, "button-press-event", (GCallback) _unity_launcher_scroller_view_on_button_press_event_clutter_actor_button_press_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "button-release-event", (GCallback) _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "motion-event", (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "enter-event", (GCallback) _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "leave-event", (GCallback) _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event, self, 0);
		g_signal_connect_object ((GObject*) self, "notify::is-autoscrolling", (GCallback) _unity_launcher_scroller_view_on_auto_scrolling_state_change_g_object_notify, self, 0);
		g_signal_connect_object (unity_drag_controller_get_default (), "drag-motion", (GCallback) _unity_launcher_scroller_view_on_drag_motion_event_unity_drag_controller_drag_motion, self, 0);
		self->fling_timeline = (_tmp2_ = clutter_timeline_new ((guint) 1000), _g_object_unref0 (self->fling_timeline), _tmp2_);
		clutter_timeline_set_loop (self->fling_timeline, TRUE);
		g_signal_connect_object (self->fling_timeline, "new-frame", (GCallback) _unity_launcher_scroller_view_on_scroller_frame_clutter_timeline_new_frame, self, 0);
		g_signal_connect_object (self->fling_timeline, "started", (GCallback) __lambda57__clutter_timeline_started, self, 0);
		g_signal_connect_object (self->fling_timeline, "completed", (GCallback) __lambda58__clutter_timeline_completed, self, 0);
		drag_controller = _g_object_ref0 (unity_drag_controller_get_default ());
		g_signal_connect_object (drag_controller, "drag-start", (GCallback) __lambda60__unity_drag_controller_drag_start, self, 0);
		g_signal_connect_object (drag_controller, "drag-drop", (GCallback) __lambda61__unity_drag_controller_drag_drop, self, 0);
		clutter_actor_set_reactive ((ClutterActor*) self, TRUE);
		self->priv->child_refs = (_tmp3_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->child_refs), _tmp3_);
		unity_launcher_scroller_view_order_children (self, TRUE);
		clutter_actor_queue_relayout ((ClutterActor*) self);
		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, __lambda62__gsource_func, g_object_ref (self), g_object_unref);
		_g_object_unref0 (drag_controller);
	}
	return obj;
}


static void unity_launcher_scroller_view_class_init (UnityLauncherScrollerViewClass * klass) {
	unity_launcher_scroller_view_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityLauncherScrollerViewPrivate));
	CLUTTER_ACTOR_CLASS (klass)->get_preferred_width = unity_launcher_scroller_view_real_get_preferred_width;
	CLUTTER_ACTOR_CLASS (klass)->get_preferred_height = unity_launcher_scroller_view_real_get_preferred_height;
	CLUTTER_ACTOR_CLASS (klass)->allocate = unity_launcher_scroller_view_real_allocate;
	CLUTTER_ACTOR_CLASS (klass)->pick = unity_launcher_scroller_view_real_pick;
	CLUTTER_ACTOR_CLASS (klass)->paint = unity_launcher_scroller_view_real_paint;
	CLUTTER_ACTOR_CLASS (klass)->map = unity_launcher_scroller_view_real_map;
	CLUTTER_ACTOR_CLASS (klass)->unmap = unity_launcher_scroller_view_real_unmap;
	G_OBJECT_CLASS (klass)->get_property = unity_launcher_scroller_view_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_launcher_scroller_view_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_launcher_scroller_view_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_launcher_scroller_view_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_LAUNCHER_SCROLLER_VIEW_MODEL, g_param_spec_object ("model", "model", "model", UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_LAUNCHER_SCROLLER_VIEW_CACHE, g_param_spec_object ("cache", "cache", "cache", CTK_TYPE_EFFECT_CACHE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_LAUNCHER_SCROLLER_VIEW_IS_AUTOSCROLLING, g_param_spec_boolean ("is-autoscrolling", "is-autoscrolling", "is-autoscrolling", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void unity_launcher_scroller_view_instance_init (UnityLauncherScrollerView * self) {
	self->priv = UNITY_LAUNCHER_SCROLLER_VIEW_GET_PRIVATE (self);
	self->priv->disable_child_events = FALSE;
	self->spacing = 6;
	self->drag_sensitivity = 7;
	self->friction = 0.9f;
	self->is_animating = FALSE;
	self->priv->button_down = FALSE;
	self->priv->total_child_height = 0.0f;
	self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING;
	self->priv->last_motion_event_time = (guint) 0;
	self->priv->view_type = UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED;
	self->priv->last_known_pointer_x = 0.0f;
	self->priv->scroll_position = 0.0f;
	self->priv->settle_position = 0.0f;
	self->priv->autoscroll_anim_active = FALSE;
	self->priv->autoscroll_direction = 0;
	self->priv->previous_y_position = 0.0f;
	self->priv->previous_y_time = (guint) 0;
	self->priv->stored_delta = (guint) 0;
	self->priv->scroll_speed = 0.0f;
	self->priv->contract_icon_degrees = 70.0f;
	self->priv->contract_icon_partial_degrees = 30.0f;
	self->priv->focused_launcher = 0;
	self->priv->last_picked_actor = NULL;
	self->priv->last_scroll_position = 0.0f;
	self->priv->queue_contract_launcher = (guint) 0;
	self->priv->autoscroll_mouse_pos_cache = 0.0f;
}


static void unity_launcher_scroller_view_finalize (GObject* obj) {
	UnityLauncherScrollerView * self;
	self = UNITY_LAUNCHER_SCROLLER_VIEW (obj);
	_g_object_unref0 (self->priv->_model);
	_g_object_unref0 (self->priv->_cache);
	_g_object_unref0 (self->priv->bgtex);
	_g_object_unref0 (self->priv->top_shadow);
	_g_object_unref0 (self->fling_timeline);
	_g_object_unref0 (self->priv->draw_ftb);
	_g_object_unref0 (self->priv->draw_btf);
	_g_object_unref0 (self->priv->keyboard_indicator_1);
	_g_object_unref0 (self->priv->keyboard_indicator_2);
	_g_object_unref0 (self->priv->keyboard_indicator_3);
	_g_object_unref0 (self->priv->keyboard_indicator_4);
	_g_object_unref0 (self->priv->keyboard_indicator_5);
	_g_object_unref0 (self->priv->keyboard_indicator_6);
	_g_object_unref0 (self->priv->keyboard_indicator_7);
	_g_object_unref0 (self->priv->keyboard_indicator_8);
	_g_object_unref0 (self->priv->keyboard_indicator_9);
	_g_object_unref0 (self->priv->keyboard_indicator_0);
	_g_object_unref0 (self->priv->child_refs);
	_g_object_unref0 (self->priv->last_picked_actor);
	G_OBJECT_CLASS (unity_launcher_scroller_view_parent_class)->finalize (obj);
}


GType unity_launcher_scroller_view_get_type (void) {
	static volatile gsize unity_launcher_scroller_view_type_id__volatile = 0;
	if (g_once_init_enter (&unity_launcher_scroller_view_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityLauncherScrollerViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_launcher_scroller_view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityLauncherScrollerView), 0, (GInstanceInitFunc) unity_launcher_scroller_view_instance_init, NULL };
		GType unity_launcher_scroller_view_type_id;
		unity_launcher_scroller_view_type_id = g_type_register_static (CTK_TYPE_ACTOR, "UnityLauncherScrollerView", &g_define_type_info, 0);
		g_once_init_leave (&unity_launcher_scroller_view_type_id__volatile, unity_launcher_scroller_view_type_id);
	}
	return unity_launcher_scroller_view_type_id__volatile;
}


static void unity_launcher_scroller_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityLauncherScrollerView * self;
	self = UNITY_LAUNCHER_SCROLLER_VIEW (object);
	switch (property_id) {
		case UNITY_LAUNCHER_SCROLLER_VIEW_MODEL:
		g_value_set_object (value, unity_launcher_scroller_view_get_model (self));
		break;
		case UNITY_LAUNCHER_SCROLLER_VIEW_CACHE:
		g_value_set_object (value, unity_launcher_scroller_view_get_cache (self));
		break;
		case UNITY_LAUNCHER_SCROLLER_VIEW_IS_AUTOSCROLLING:
		g_value_set_boolean (value, unity_launcher_scroller_view_get_is_autoscrolling (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_launcher_scroller_view_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityLauncherScrollerView * self;
	self = UNITY_LAUNCHER_SCROLLER_VIEW (object);
	switch (property_id) {
		case UNITY_LAUNCHER_SCROLLER_VIEW_MODEL:
		unity_launcher_scroller_view_set_model (self, g_value_get_object (value));
		break;
		case UNITY_LAUNCHER_SCROLLER_VIEW_CACHE:
		unity_launcher_scroller_view_set_cache (self, g_value_get_object (value));
		break;
		case UNITY_LAUNCHER_SCROLLER_VIEW_IS_AUTOSCROLLING:
		unity_launcher_scroller_view_set_is_autoscrolling (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}




