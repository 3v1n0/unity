/* scroller-view.c generated by valac, the Vala compiler
 * generated from scroller-view.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; c-basic-offset: 2; tab-width: 2 -*- */
/*
 * Copyright (C) 2010 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Gordon Allott <gord.allott@canonical.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <clutk/clutk.h>
#include <float.h>
#include <math.h>
#include <unity.h>
#include <clutter/clutter.h>
#include <gee.h>
#include <string.h>
#include <stdlib.h>


#define UNITY_LAUNCHER_TYPE_SCROLLER_PHASE (unity_launcher_scroller_phase_get_type ())

#define UNITY_LAUNCHER_TYPE_SCROLLER_VIEW (unity_launcher_scroller_view_get_type ())
#define UNITY_LAUNCHER_SCROLLER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerView))
#define UNITY_LAUNCHER_SCROLLER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerViewClass))
#define UNITY_LAUNCHER_IS_SCROLLER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW))
#define UNITY_LAUNCHER_IS_SCROLLER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW))
#define UNITY_LAUNCHER_SCROLLER_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerViewClass))

typedef struct _UnityLauncherScrollerView UnityLauncherScrollerView;
typedef struct _UnityLauncherScrollerViewClass UnityLauncherScrollerViewClass;
typedef struct _UnityLauncherScrollerViewPrivate UnityLauncherScrollerViewPrivate;

#define UNITY_LAUNCHER_TYPE_SCROLLER_MODEL (unity_launcher_scroller_model_get_type ())
#define UNITY_LAUNCHER_SCROLLER_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, UnityLauncherScrollerModel))
#define UNITY_LAUNCHER_SCROLLER_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, UnityLauncherScrollerModelClass))
#define UNITY_LAUNCHER_IS_SCROLLER_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL))
#define UNITY_LAUNCHER_IS_SCROLLER_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL))
#define UNITY_LAUNCHER_SCROLLER_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, UnityLauncherScrollerModelClass))

typedef struct _UnityLauncherScrollerModel UnityLauncherScrollerModel;
typedef struct _UnityLauncherScrollerModelClass UnityLauncherScrollerModelClass;

#define UNITY_LAUNCHER_TYPE_SCROLLER_CHILD (unity_launcher_scroller_child_get_type ())
#define UNITY_LAUNCHER_SCROLLER_CHILD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, UnityLauncherScrollerChild))
#define UNITY_LAUNCHER_SCROLLER_CHILD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, UnityLauncherScrollerChildClass))
#define UNITY_LAUNCHER_IS_SCROLLER_CHILD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD))
#define UNITY_LAUNCHER_IS_SCROLLER_CHILD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD))
#define UNITY_LAUNCHER_SCROLLER_CHILD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, UnityLauncherScrollerChildClass))

typedef struct _UnityLauncherScrollerChild UnityLauncherScrollerChild;
typedef struct _UnityLauncherScrollerChildClass UnityLauncherScrollerChildClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR (unity_launcher_scroller_model_iterator_get_type ())
#define UNITY_LAUNCHER_SCROLLER_MODEL_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR, UnityLauncherScrollerModelIterator))
#define UNITY_LAUNCHER_SCROLLER_MODEL_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR, UnityLauncherScrollerModelIteratorClass))
#define UNITY_LAUNCHER_SCROLLER_MODEL_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR))
#define UNITY_LAUNCHER_SCROLLER_MODEL_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR))
#define UNITY_LAUNCHER_SCROLLER_MODEL_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR, UnityLauncherScrollerModelIteratorClass))

typedef struct _UnityLauncherScrollerModelIterator UnityLauncherScrollerModelIterator;
typedef struct _UnityLauncherScrollerModelIteratorClass UnityLauncherScrollerModelIteratorClass;
#define _unity_launcher_scroller_model_iterator_unref0(var) ((var == NULL) ? NULL : (var = (unity_launcher_scroller_model_iterator_unref (var), NULL)))
typedef struct _Block2Data Block2Data;

#define UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD (unity_launcher_launcher_child_get_type ())
#define UNITY_LAUNCHER_LAUNCHER_CHILD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD, UnityLauncherLauncherChild))
#define UNITY_LAUNCHER_LAUNCHER_CHILD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD, UnityLauncherLauncherChildClass))
#define UNITY_LAUNCHER_IS_LAUNCHER_CHILD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD))
#define UNITY_LAUNCHER_IS_LAUNCHER_CHILD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD))
#define UNITY_LAUNCHER_LAUNCHER_CHILD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD, UnityLauncherLauncherChildClass))

typedef struct _UnityLauncherLauncherChild UnityLauncherLauncherChild;
typedef struct _UnityLauncherLauncherChildClass UnityLauncherLauncherChildClass;

#define UNITY_TESTING_TYPE_OBJECT_REGISTRY (unity_testing_object_registry_get_type ())
#define UNITY_TESTING_OBJECT_REGISTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TESTING_TYPE_OBJECT_REGISTRY, UnityTestingObjectRegistry))
#define UNITY_TESTING_OBJECT_REGISTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TESTING_TYPE_OBJECT_REGISTRY, UnityTestingObjectRegistryClass))
#define UNITY_TESTING_IS_OBJECT_REGISTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TESTING_TYPE_OBJECT_REGISTRY))
#define UNITY_TESTING_IS_OBJECT_REGISTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TESTING_TYPE_OBJECT_REGISTRY))
#define UNITY_TESTING_OBJECT_REGISTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TESTING_TYPE_OBJECT_REGISTRY, UnityTestingObjectRegistryClass))

typedef struct _UnityTestingObjectRegistry UnityTestingObjectRegistry;
typedef struct _UnityTestingObjectRegistryClass UnityTestingObjectRegistryClass;
#define _unity_testing_object_registry_unref0(var) ((var == NULL) ? NULL : (var = (unity_testing_object_registry_unref (var), NULL)))

typedef enum  {
	UNITY_LAUNCHER_SCROLLER_PHASE_PANNING,
	UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING,
	UNITY_LAUNCHER_SCROLLER_PHASE_REORDERING,
	UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG,
	UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE,
	UNITY_LAUNCHER_SCROLLER_PHASE_NONE
} UnityLauncherScrollerPhase;

struct _UnityLauncherScrollerView {
	CtkActor parent_instance;
	UnityLauncherScrollerViewPrivate * priv;
	gint spacing;
	gint drag_sensitivity;
	float friction;
	gboolean is_animating;
};

struct _UnityLauncherScrollerViewClass {
	CtkActorClass parent_class;
};

struct _UnityLauncherScrollerViewPrivate {
	UnityLauncherScrollerModel* _model;
	UnityThemeImage* bgtex;
	UnityThemeImage* top_shadow;
	UnityThemeImage* bottom_fade;
	gboolean button_down;
	float total_child_height;
	UnityLauncherScrollerPhase current_phase;
	guint last_motion_event_time;
	gboolean is_scrolling;
	float scroll_position;
	float settle_position;
	ClutterTimeline* fling_timeline;
	float previous_y_position;
	guint previous_y_time;
	guint stored_delta;
	float scroll_speed;
	GeeArrayList* child_refs;
};

struct _Block2Data {
	int _ref_count_;
	UnityLauncherScrollerView * self;
	UnityLauncherScrollerChild* child;
};


static gpointer unity_launcher_scroller_view_parent_class = NULL;

GType unity_launcher_scroller_phase_get_type (void);
GType unity_launcher_scroller_view_get_type (void);
GType unity_launcher_scroller_model_get_type (void);
GType unity_launcher_scroller_child_get_type (void);
#define UNITY_LAUNCHER_SCROLLER_VIEW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerViewPrivate))
enum  {
	UNITY_LAUNCHER_SCROLLER_VIEW_DUMMY_PROPERTY,
	UNITY_LAUNCHER_SCROLLER_VIEW_MODEL
};
UnityLauncherScrollerView* unity_launcher_scroller_view_new (UnityLauncherScrollerModel* _model);
UnityLauncherScrollerView* unity_launcher_scroller_view_construct (GType object_type, UnityLauncherScrollerModel* _model);
UnityLauncherScrollerModel* unity_launcher_scroller_view_get_model (UnityLauncherScrollerView* self);
gpointer unity_launcher_scroller_model_iterator_ref (gpointer instance);
void unity_launcher_scroller_model_iterator_unref (gpointer instance);
GParamSpec* unity_launcher_scroller_model_param_spec_iterator (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_launcher_scroller_model_value_set_iterator (GValue* value, gpointer v_object);
void unity_launcher_scroller_model_value_take_iterator (GValue* value, gpointer v_object);
gpointer unity_launcher_scroller_model_value_get_iterator (const GValue* value);
GType unity_launcher_scroller_model_iterator_get_type (void);
UnityLauncherScrollerModelIterator* unity_launcher_scroller_model_iterator (UnityLauncherScrollerModel* self);
gboolean unity_launcher_scroller_model_iterator_next (UnityLauncherScrollerModelIterator* self);
UnityLauncherScrollerChild* unity_launcher_scroller_model_iterator_get (UnityLauncherScrollerModelIterator* self);
gint unity_launcher_scroller_view_get_model_index_at_y_pos (UnityLauncherScrollerView* self, float y);
static void unity_launcher_scroller_view_load_textures (UnityLauncherScrollerView* self);
static void unity_launcher_scroller_view_move_scroll_position (UnityLauncherScrollerView* self, float pixels);
static void unity_launcher_scroller_view_disable_animations_on_children (UnityLauncherScrollerView* self, ClutterEvent* event);
gint unity_launcher_scroller_model_index_of (UnityLauncherScrollerModel* self, UnityLauncherScrollerChild* child);
gint unity_launcher_scroller_model_get_size (UnityLauncherScrollerModel* self);
static void unity_launcher_scroller_view_order_children (UnityLauncherScrollerView* self, gboolean immediate);
static void _lambda14_ (UnityLauncherScrollerView* self);
static void __lambda14__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void unity_launcher_scroller_view_model_child_added (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child);
#define UNITY_LAUNCHER_SHORT_DELAY ((guint) 400)
static void _lambda15_ (Block2Data* _data2_);
static void __lambda15__clutter_animation_completed (ClutterAnimation* _sender, gpointer self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (Block2Data* _data2_);
static void unity_launcher_scroller_view_model_child_removed (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child);
static void unity_launcher_scroller_view_model_order_changed (UnityLauncherScrollerView* self);
static gboolean unity_launcher_scroller_view_on_button_release_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean unity_launcher_scroller_view_on_button_press_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean unity_launcher_scroller_view_on_motion_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static float unity_launcher_scroller_view_get_aligned_settle_position (UnityLauncherScrollerView* self);
static void unity_launcher_scroller_view_do_anim_settle (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_do_anim_fling (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_do_anim_bounce (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_on_scroller_frame (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_real_get_preferred_width (ClutterActor* base, float for_height, float* minimum_width, float* natural_width);
static void unity_launcher_scroller_view_real_get_preferred_height (ClutterActor* base, float for_width, float* minimum_height, float* natural_height);
float unity_launcher_scroller_child_get_position (UnityLauncherScrollerChild* self);
void unity_launcher_scroller_child_set_position (UnityLauncherScrollerChild* self, float value);
static void unity_launcher_scroller_view_real_allocate (ClutterActor* base, const ClutterActorBox* box, ClutterAllocationFlags flags);
static void unity_launcher_scroller_view_real_pick (ClutterActor* base, const ClutterColor* color);
GType unity_launcher_launcher_child_get_type (void);
static void unity_launcher_scroller_view_real_paint (ClutterActor* base);
static void unity_launcher_scroller_view_real_map (ClutterActor* base);
static void unity_launcher_scroller_view_real_unmap (ClutterActor* base);
static void unity_launcher_scroller_view_set_model (UnityLauncherScrollerView* self, UnityLauncherScrollerModel* value);
gpointer unity_testing_object_registry_ref (gpointer instance);
void unity_testing_object_registry_unref (gpointer instance);
GParamSpec* unity_testing_param_spec_object_registry (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_testing_value_set_object_registry (GValue* value, gpointer v_object);
void unity_testing_value_take_object_registry (GValue* value, gpointer v_object);
gpointer unity_testing_value_get_object_registry (const GValue* value);
GType unity_testing_object_registry_get_type (void);
UnityTestingObjectRegistry* unity_testing_object_registry_get_default (void);
void unity_testing_object_registry_register (UnityTestingObjectRegistry* self, const char* name, GObject* object);
static void _unity_launcher_scroller_view_model_child_added_unity_launcher_scroller_model_child_added (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self);
static void _unity_launcher_scroller_view_model_child_removed_unity_launcher_scroller_model_child_removed (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self);
static void _unity_launcher_scroller_view_model_order_changed_unity_launcher_scroller_model_order_changed (UnityLauncherScrollerModel* _sender, gpointer self);
static gboolean _unity_launcher_scroller_view_on_button_press_event_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static void _unity_launcher_scroller_view_on_scroller_frame_clutter_timeline_new_frame (ClutterTimeline* _sender, gint msecs, gpointer self);
static void _lambda16_ (UnityLauncherScrollerView* self);
static void __lambda16__unity_drag_controller_drag_start (UnityDragController* _sender, UnityDragModel* model, gpointer self);
static GObject * unity_launcher_scroller_view_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_launcher_scroller_view_finalize (GObject* obj);
static void unity_launcher_scroller_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_launcher_scroller_view_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);



GType unity_launcher_scroller_phase_get_type (void) {
	static volatile gsize unity_launcher_scroller_phase_type_id__volatile = 0;
	if (g_once_init_enter (&unity_launcher_scroller_phase_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_LAUNCHER_SCROLLER_PHASE_PANNING, "UNITY_LAUNCHER_SCROLLER_PHASE_PANNING", "panning"}, {UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING, "UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING", "settling"}, {UNITY_LAUNCHER_SCROLLER_PHASE_REORDERING, "UNITY_LAUNCHER_SCROLLER_PHASE_REORDERING", "reordering"}, {UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG, "UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG", "flung"}, {UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE, "UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE", "bounce"}, {UNITY_LAUNCHER_SCROLLER_PHASE_NONE, "UNITY_LAUNCHER_SCROLLER_PHASE_NONE", "none"}, {0, NULL, NULL}};
		GType unity_launcher_scroller_phase_type_id;
		unity_launcher_scroller_phase_type_id = g_enum_register_static ("UnityLauncherScrollerPhase", values);
		g_once_init_leave (&unity_launcher_scroller_phase_type_id__volatile, unity_launcher_scroller_phase_type_id);
	}
	return unity_launcher_scroller_phase_type_id__volatile;
}


UnityLauncherScrollerView* unity_launcher_scroller_view_construct (GType object_type, UnityLauncherScrollerModel* _model) {
	UnityLauncherScrollerView * self;
	g_return_val_if_fail (_model != NULL, NULL);
	self = (UnityLauncherScrollerView*) g_object_new (object_type, "model", _model, NULL);
	return self;
}


UnityLauncherScrollerView* unity_launcher_scroller_view_new (UnityLauncherScrollerModel* _model) {
	return unity_launcher_scroller_view_construct (UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, _model);
}


gint unity_launcher_scroller_view_get_model_index_at_y_pos (UnityLauncherScrollerView* self, float y) {
	gint result = 0;
	float h;
	float min_height = 0.0F;
	float nat_height = 0.0F;
	gint i;
	g_return_val_if_fail (self != NULL, 0);
	h = 0.0f;
	i = 0;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			CtkPadding _tmp0_ = {0};
			float transformed_pos;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			transformed_pos = (h + self->priv->scroll_position) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.top);
			if (transformed_pos > y) {
				result = i;
				_g_object_unref0 (child);
				_unity_launcher_scroller_model_iterator_unref0 (_child_it);
				return result;
			}
			clutter_actor_get_preferred_height ((ClutterActor*) child, clutter_actor_get_width ((ClutterActor*) self), &min_height, &nat_height);
			h = h + (nat_height + self->spacing);
			i++;
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	result = MAX (i, 0);
	return result;
}


static void unity_launcher_scroller_view_load_textures (UnityLauncherScrollerView* self) {
	UnityThemeImage* _tmp0_;
	UnityThemeImage* _tmp1_;
	UnityThemeImage* _tmp2_;
	g_return_if_fail (self != NULL);
	self->priv->bgtex = (_tmp0_ = g_object_ref_sink (unity_theme_image_new ("launcher_background_middle")), _g_object_unref0 (self->priv->bgtex), _tmp0_);
	clutter_texture_set_repeat ((ClutterTexture*) self->priv->bgtex, TRUE, TRUE);
	clutter_actor_set_parent ((ClutterActor*) self->priv->bgtex, (ClutterActor*) self);
	self->priv->top_shadow = (_tmp1_ = g_object_ref_sink (unity_theme_image_new ("overflow_top")), _g_object_unref0 (self->priv->top_shadow), _tmp1_);
	clutter_texture_set_repeat ((ClutterTexture*) self->priv->top_shadow, TRUE, FALSE);
	clutter_actor_set_parent ((ClutterActor*) self->priv->top_shadow, (ClutterActor*) self);
	self->priv->bottom_fade = (_tmp2_ = g_object_ref_sink (unity_theme_image_new ("overflow_bottom")), _g_object_unref0 (self->priv->bottom_fade), _tmp2_);
	clutter_texture_set_repeat ((ClutterTexture*) self->priv->bottom_fade, TRUE, FALSE);
	clutter_actor_set_parent ((ClutterActor*) self->priv->bottom_fade, (ClutterActor*) self);
}


static void unity_launcher_scroller_view_move_scroll_position (UnityLauncherScrollerView* self, float pixels) {
	g_return_if_fail (self != NULL);
	self->priv->scroll_position = self->priv->scroll_position + pixels;
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static void unity_launcher_scroller_view_disable_animations_on_children (UnityLauncherScrollerView* self, ClutterEvent* event) {
	ClutterEvent _tmp0_ = {0};
	ClutterEvent e;
	g_return_if_fail (self != NULL);
	e = (_tmp0_.type = 0, _tmp0_);
	e.type = CLUTTER_LEAVE;
	e.crossing.time = (*event).motion.time;
	e.crossing.flags = (*event).motion.flags;
	e.crossing.stage = (*event).motion.stage;
	e.crossing.x = (*event).motion.x;
	e.crossing.y = (*event).motion.y;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			if (CLUTTER_IS_ACTOR (child)) {
				e.crossing.source = (ClutterActor*) child;
				clutter_actor_event ((ClutterActor*) child, &e, FALSE);
			}
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


static void _lambda14_ (UnityLauncherScrollerView* self) {
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static void __lambda14__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_lambda14_ (self);
}


static void unity_launcher_scroller_view_model_child_added (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (child != NULL);
	clutter_actor_unparent ((ClutterActor*) child);
	clutter_actor_set_parent ((ClutterActor*) child, (ClutterActor*) self);
	if (unity_launcher_scroller_model_index_of (self->priv->_model, child) == (unity_launcher_scroller_model_get_size (self->priv->_model) - 1)) {
		unity_launcher_scroller_view_order_children (self, TRUE);
	} else {
		unity_launcher_scroller_view_order_children (self, FALSE);
	}
	clutter_actor_queue_relayout ((ClutterActor*) self);
	g_signal_connect_object ((GObject*) child, "notify::position", (GCallback) __lambda14__g_object_notify, self, 0);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _lambda15_ (Block2Data* _data2_) {
	UnityLauncherScrollerView * self;
	self = _data2_->self;
	clutter_actor_unparent ((ClutterActor*) _data2_->child);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->child_refs, _data2_->child);
}


static void __lambda15__clutter_animation_completed (ClutterAnimation* _sender, gpointer self) {
	_lambda15_ (self);
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	++_data2_->_ref_count_;
	return _data2_;
}


static void block2_data_unref (Block2Data* _data2_) {
	if ((--_data2_->_ref_count_) == 0) {
		_g_object_unref0 (_data2_->self);
		_g_object_unref0 (_data2_->child);
		g_slice_free (Block2Data, _data2_);
	}
}


static void unity_launcher_scroller_view_model_child_removed (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child) {
	Block2Data* _data2_;
	ClutterAnimation* anim;
	g_return_if_fail (self != NULL);
	g_return_if_fail (child != NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = g_object_ref (self);
	_data2_->child = _g_object_ref0 (child);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->child_refs, _data2_->child);
	anim = _g_object_ref0 (clutter_actor_animate ((ClutterActor*) _data2_->child, (gulong) CLUTTER_EASE_OUT_QUAD, UNITY_LAUNCHER_SHORT_DELAY, "opacity", 0, NULL));
	g_signal_connect_data (anim, "completed", (GCallback) __lambda15__clutter_animation_completed, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	unity_launcher_scroller_view_order_children (self, FALSE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
	_g_object_unref0 (anim);
	block2_data_unref (_data2_);
}


static void unity_launcher_scroller_view_model_order_changed (UnityLauncherScrollerView* self) {
	g_return_if_fail (self != NULL);
	unity_launcher_scroller_view_order_children (self, FALSE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static gboolean _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_button_release_event (self, event);
	return result;
}


static gboolean unity_launcher_scroller_view_on_button_press_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if ((*event).button.button != 1) {
		result = FALSE;
		return result;
	}
	self->priv->button_down = TRUE;
	self->priv->previous_y_position = (*event).button.y;
	self->priv->previous_y_time = (guint) (*event).button.time;
	g_signal_connect_object (clutter_actor_get_stage ((ClutterActor*) self), "button-release-event", (GCallback) _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event, self, 0);
	result = TRUE;
	return result;
}


static gboolean _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_motion_event (self, event);
	return result;
}


static gboolean unity_launcher_scroller_view_on_button_release_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	guint _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	if ((*event).button.button != 1) {
		result = FALSE;
		return result;
	}
	self->priv->button_down = FALSE;
	g_signal_parse_name ("button-release-event", CLUTTER_TYPE_ACTOR, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (clutter_actor_get_stage ((ClutterActor*) self), G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event, self);
	unity_shell_remove_fullscreen_request (unity_global_shell, (GObject*) self);
	if (self->priv->is_scrolling) {
		guint _tmp1_;
		self->priv->is_scrolling = FALSE;
		clutter_ungrab_pointer ();
		g_signal_parse_name ("motion-event", CLUTTER_TYPE_ACTOR, &_tmp1_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (clutter_actor_get_stage ((ClutterActor*) self), G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self);
		if (((*event).button.time - self->priv->last_motion_event_time) > 120) {
			self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING;
			self->priv->settle_position = unity_launcher_scroller_view_get_aligned_settle_position (self);
		} else {
			self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG;
		}
		{
			UnityLauncherScrollerModelIterator* _child_it;
			_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
					break;
				}
				child = unity_launcher_scroller_model_iterator_get (_child_it);
				clutter_actor_set_reactive ((ClutterActor*) child, FALSE);
				_g_object_unref0 (child);
			}
			_unity_launcher_scroller_model_iterator_unref0 (_child_it);
		}
		clutter_timeline_start (self->priv->fling_timeline);
	}
	result = TRUE;
	return result;
}


static gboolean unity_launcher_scroller_view_on_motion_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	UnityDragController* drag_controller;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	drag_controller = _g_object_ref0 (unity_drag_controller_get_default ());
	if (unity_drag_controller_get_is_dragging (drag_controller)) {
		result = FALSE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	self->priv->last_motion_event_time = (guint) (*event).motion.time;
	if (self->priv->button_down) {
		_tmp0_ = self->priv->is_scrolling == FALSE;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		float diff;
		diff = (*event).motion.y - self->priv->previous_y_position;
		if (fabsf (diff) > self->drag_sensitivity) {
			self->priv->is_scrolling = TRUE;
			unity_shell_add_fullscreen_request (unity_global_shell, (GObject*) self);
			clutter_grab_pointer ((ClutterActor*) self);
			g_signal_connect_object (clutter_actor_get_stage ((ClutterActor*) self), "motion-event", (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self, 0);
		}
	}
	if (self->priv->is_scrolling) {
		float pixel_diff;
		guint time_diff;
		unity_launcher_scroller_view_disable_animations_on_children (self, event);
		pixel_diff = (*event).motion.y - self->priv->previous_y_position;
		time_diff = (guint) ((*event).motion.time - self->priv->previous_y_time);
		self->priv->scroll_speed = pixel_diff / (time_diff / 1000.0f);
		self->priv->previous_y_position = (*event).motion.y;
		self->priv->previous_y_time = (guint) (*event).motion.time;
		unity_launcher_scroller_view_move_scroll_position (self, pixel_diff);
		result = TRUE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (drag_controller);
	return result;
}


static void unity_launcher_scroller_view_on_scroller_frame (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	guint delta;
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	delta = clutter_timeline_get_delta (timeline);
	delta = delta + self->priv->stored_delta;
	if (delta <= 16) {
		self->priv->stored_delta = delta;
		return;
	}
	while (TRUE) {
		if (!(delta > 16)) {
			break;
		}
		self->is_animating = TRUE;
		delta = delta - ((guint) 16);
		switch (self->priv->current_phase) {
			case UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING:
			{
				unity_launcher_scroller_view_do_anim_settle (self, timeline, msecs);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG:
			{
				unity_launcher_scroller_view_do_anim_fling (self, timeline, msecs);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE:
			{
				unity_launcher_scroller_view_do_anim_bounce (self, timeline, msecs);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_PHASE_NONE:
			{
				clutter_timeline_stop (timeline);
				self->priv->scroll_speed = 0.0f;
				self->is_animating = FALSE;
				{
					UnityLauncherScrollerModelIterator* _child_it;
					_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
					while (TRUE) {
						UnityLauncherScrollerChild* child;
						if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
							break;
						}
						child = unity_launcher_scroller_model_iterator_get (_child_it);
						clutter_actor_set_reactive ((ClutterActor*) child, TRUE);
						_g_object_unref0 (child);
					}
					_unity_launcher_scroller_model_iterator_unref0 (_child_it);
				}
				break;
			}
			default:
			{
				g_assert_not_reached ();
			}
		}
	}
	self->priv->stored_delta = delta;
}


static void unity_launcher_scroller_view_do_anim_settle (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	float distance;
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	distance = self->priv->settle_position - self->priv->scroll_position;
	unity_launcher_scroller_view_move_scroll_position (self, distance * 0.2f);
	if (fabs ((double) distance) < 1) {
		self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_NONE;
	}
}


static void unity_launcher_scroller_view_do_anim_fling (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	float scroll_move_amount;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	self->priv->scroll_speed = self->priv->scroll_speed * self->friction;
	scroll_move_amount = self->priv->scroll_speed / 60.0f;
	unity_launcher_scroller_view_move_scroll_position (self, scroll_move_amount);
	if (scroll_move_amount <= (-1.0)) {
		_tmp1_ = (-self->priv->scroll_position) > (self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self));
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp2_ = FALSE;
		if (scroll_move_amount >= 1.0) {
			_tmp2_ = self->priv->scroll_position > 0;
		} else {
			_tmp2_ = FALSE;
		}
		_tmp0_ = _tmp2_;
	}
	if (_tmp0_) {
		self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE;
	}
	if (fabsf (scroll_move_amount) < 1.0) {
		gboolean _tmp4_ = FALSE;
		if (self->priv->scroll_position > 0) {
			_tmp4_ = TRUE;
		} else {
			_tmp4_ = (-self->priv->scroll_position) > (self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self));
		}
		_tmp3_ = _tmp4_;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		self->priv->settle_position = unity_launcher_scroller_view_get_aligned_settle_position (self);
		self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING;
	} else {
		if (fabsf (scroll_move_amount) < 1.0) {
			self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_NONE;
		}
	}
}


static void unity_launcher_scroller_view_do_anim_bounce (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	self->priv->scroll_speed = self->priv->scroll_speed * 0.5f;
	unity_launcher_scroller_view_move_scroll_position (self, self->priv->scroll_speed / 60.0f);
	self->priv->settle_position = -unity_launcher_scroller_view_get_aligned_settle_position (self);
	self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING;
}


static float unity_launcher_scroller_view_get_aligned_settle_position (UnityLauncherScrollerView* self) {
	float result = 0.0F;
	float final_position;
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	g_return_val_if_fail (self != NULL, 0.0F);
	final_position = self->priv->scroll_position;
	if (self->priv->total_child_height < ((clutter_actor_get_height ((ClutterActor*) self) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.top)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom))) {
		final_position = (float) 0;
	} else {
		if (self->priv->scroll_position > 0) {
			final_position = (float) 0;
		} else {
			CtkPadding _tmp2_ = {0};
			CtkPadding _tmp3_ = {0};
			if ((-self->priv->scroll_position) > (((self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.top)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.bottom))) {
				CtkPadding _tmp4_ = {0};
				final_position = (self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self)) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp4_), _tmp4_.bottom);
			}
		}
	}
	result = final_position;
	return result;
}


static void unity_launcher_scroller_view_real_get_preferred_width (ClutterActor* base, float for_height, float* minimum_width, float* natural_width) {
	UnityLauncherScrollerView * self;
	float pmin_width;
	float pnat_width;
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	CtkPadding _tmp2_ = {0};
	CtkPadding _tmp3_ = {0};
	self = (UnityLauncherScrollerView*) base;
	*minimum_width = (float) 0;
	*natural_width = (float) 0;
	pmin_width = 0.0f;
	pnat_width = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			float cmin_width;
			float cnat_width;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			cmin_width = 0.0f;
			cnat_width = 0.0f;
			clutter_actor_get_preferred_width ((ClutterActor*) child, for_height, &cmin_width, &cnat_width);
			pmin_width = MAX (pmin_width, cmin_width);
			pnat_width = MAX (pnat_width, cnat_width);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	pmin_width = pmin_width + ((ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.left) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.right));
	pnat_width = pnat_width + ((ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.left) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.right));
	*minimum_width = pmin_width;
	*natural_width = pnat_width;
}


static void unity_launcher_scroller_view_real_get_preferred_height (ClutterActor* base, float for_width, float* minimum_height, float* natural_height) {
	UnityLauncherScrollerView * self;
	float cnat_height;
	float cmin_height;
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	CtkPadding _tmp2_ = {0};
	CtkPadding _tmp3_ = {0};
	self = (UnityLauncherScrollerView*) base;
	*minimum_height = 0.0f;
	*natural_height = 0.0f;
	cnat_height = 0.0f;
	cmin_height = 0.0f;
	self->priv->total_child_height = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			cnat_height = 0.0f;
			cmin_height = 0.0f;
			clutter_actor_get_preferred_height ((ClutterActor*) child, for_width, &cmin_height, &cnat_height);
			self->priv->total_child_height = self->priv->total_child_height + (cnat_height + self->spacing);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	*minimum_height = (self->priv->total_child_height + (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.top)) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom);
	*natural_height = (self->priv->total_child_height + (ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.top)) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.bottom);
	return;
}


static void unity_launcher_scroller_view_order_children (UnityLauncherScrollerView* self, gboolean immediate) {
	float h;
	float min_height = 0.0F;
	float nat_height = 0.0F;
	g_return_if_fail (self != NULL);
	h = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_get_preferred_height ((ClutterActor*) child, clutter_actor_get_width ((ClutterActor*) self), &min_height, &nat_height);
			if (h != unity_launcher_scroller_child_get_position (child)) {
				if (!immediate) {
					if (CLUTTER_IS_ANIMATION (clutter_actor_get_animation ((ClutterActor*) child))) {
						float current_pos;
						current_pos = unity_launcher_scroller_child_get_position (child);
						clutter_animation_completed (clutter_actor_get_animation ((ClutterActor*) child));
						unity_launcher_scroller_child_set_position (child, current_pos);
					}
					clutter_actor_animate ((ClutterActor*) child, (gulong) CLUTTER_EASE_IN_OUT_QUAD, (guint) 170, "position", h, NULL);
				} else {
					unity_launcher_scroller_child_set_position (child, h);
				}
			}
			h = h + (nat_height + self->spacing);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


static void unity_launcher_scroller_view_real_allocate (ClutterActor* base, const ClutterActorBox* box, ClutterAllocationFlags flags) {
	UnityLauncherScrollerView * self;
	ClutterActorBox child_box = {0};
	CtkPadding _tmp0_ = {0};
	float current_width;
	CtkPadding _tmp1_ = {0};
	float available_height;
	CtkPadding _tmp2_ = {0};
	float available_width;
	gint bg_height = 0;
	gint bg_width = 0;
	float bg_offset;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->allocate ((ClutterActor*) CTK_ACTOR (self), box, flags);
	memset (&child_box, 0, sizeof (ClutterActorBox));
	current_width = (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.left);
	available_height = clutter_actor_box_get_height (box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom);
	available_width = clutter_actor_box_get_width (box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.right);
	self->priv->total_child_height = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			float child_height = 0.0F;
			float child_width = 0.0F;
			float natural = 0.0F;
			float min = 0.0F;
			CtkPadding _tmp3_ = {0};
			CtkPadding _tmp4_ = {0};
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_get_preferred_width ((ClutterActor*) child, available_height, &min, &natural);
			child_width = fmaxf (min, fminf (natural, available_width));
			clutter_actor_get_preferred_height ((ClutterActor*) child, child_width, &min, &natural);
			child_height = fmaxf (min, fminf (natural, available_height));
			child_box.x1 = current_width;
			child_box.x2 = clutter_actor_box_get_width (box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.right);
			child_box.y1 = (unity_launcher_scroller_child_get_position (child) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp4_), _tmp4_.top)) + self->priv->scroll_position;
			child_box.y2 = child_box.y1 + child_height;
			clutter_actor_allocate ((ClutterActor*) child, &child_box, flags);
			self->priv->total_child_height = self->priv->total_child_height + (child_height + self->spacing);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	child_box.x1 = (float) 0;
	child_box.x2 = clutter_actor_box_get_width (box);
	clutter_texture_get_base_size ((ClutterTexture*) self->priv->bgtex, &bg_width, &bg_height);
	bg_offset = fmodf (self->priv->scroll_position + 1000000, (float) bg_height);
	child_box.y1 = bg_offset - (bg_height - 1);
	child_box.y2 = (bg_offset + (bg_height - 1)) + clutter_actor_box_get_height (box);
	clutter_actor_allocate ((ClutterActor*) self->priv->bgtex, &child_box, flags);
	clutter_texture_get_base_size ((ClutterTexture*) self->priv->top_shadow, &bg_width, &bg_height);
	child_box.y1 = (float) (-1);
	child_box.y2 = (float) (bg_height - 1);
	clutter_actor_allocate ((ClutterActor*) self->priv->top_shadow, &child_box, flags);
	clutter_texture_get_base_size ((ClutterTexture*) self->priv->bottom_fade, &bg_width, &bg_height);
	child_box.y1 = clutter_actor_box_get_height (box) - bg_height;
	child_box.y2 = clutter_actor_box_get_height (box);
	clutter_actor_allocate ((ClutterActor*) self->priv->bottom_fade, &child_box, flags);
}


static void unity_launcher_scroller_view_real_pick (ClutterActor* base, const ClutterColor* color) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->pick ((ClutterActor*) CTK_ACTOR (self), color);
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_paint ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


static void unity_launcher_scroller_view_real_paint (ClutterActor* base) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	clutter_actor_paint ((ClutterActor*) self->priv->bgtex);
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			gboolean _tmp0_ = FALSE;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			if (UNITY_LAUNCHER_IS_LAUNCHER_CHILD (child)) {
				_tmp0_ = clutter_actor_get_opacity ((ClutterActor*) child) > 0;
			} else {
				_tmp0_ = FALSE;
			}
			if (_tmp0_) {
				UnityLauncherScrollerChild* _tmp1_;
				clutter_actor_paint ((ClutterActor*) (_tmp1_ = child, UNITY_LAUNCHER_IS_LAUNCHER_CHILD (_tmp1_) ? ((UnityLauncherLauncherChild*) _tmp1_) : NULL));
			}
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	{
		GeeIterator* _child_it;
		_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->child_refs);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!gee_iterator_next (_child_it)) {
				break;
			}
			child = (UnityLauncherScrollerChild*) gee_iterator_get (_child_it);
			clutter_actor_paint ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_g_object_unref0 (_child_it);
	}
	clutter_actor_paint ((ClutterActor*) self->priv->top_shadow);
	clutter_actor_paint ((ClutterActor*) self->priv->bottom_fade);
}


static void unity_launcher_scroller_view_real_map (ClutterActor* base) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->map ((ClutterActor*) CTK_ACTOR (self));
	clutter_actor_map ((ClutterActor*) self->priv->bgtex);
	clutter_actor_map ((ClutterActor*) self->priv->top_shadow);
	clutter_actor_map ((ClutterActor*) self->priv->bottom_fade);
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_map ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


static void unity_launcher_scroller_view_real_unmap (ClutterActor* base) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->unmap ((ClutterActor*) CTK_ACTOR (self));
	clutter_actor_map ((ClutterActor*) self->priv->bgtex);
	clutter_actor_map ((ClutterActor*) self->priv->top_shadow);
	clutter_actor_map ((ClutterActor*) self->priv->bottom_fade);
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_unmap ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


UnityLauncherScrollerModel* unity_launcher_scroller_view_get_model (UnityLauncherScrollerView* self) {
	UnityLauncherScrollerModel* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_model;
	return result;
}


static void unity_launcher_scroller_view_set_model (UnityLauncherScrollerView* self, UnityLauncherScrollerModel* value) {
	UnityLauncherScrollerModel* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_model = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_model), _tmp0_);
	g_object_notify ((GObject *) self, "model");
}


static void _unity_launcher_scroller_view_model_child_added_unity_launcher_scroller_model_child_added (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self) {
	unity_launcher_scroller_view_model_child_added (self, child);
}


static void _unity_launcher_scroller_view_model_child_removed_unity_launcher_scroller_model_child_removed (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self) {
	unity_launcher_scroller_view_model_child_removed (self, child);
}


static void _unity_launcher_scroller_view_model_order_changed_unity_launcher_scroller_model_order_changed (UnityLauncherScrollerModel* _sender, gpointer self) {
	unity_launcher_scroller_view_model_order_changed (self);
}


static gboolean _unity_launcher_scroller_view_on_button_press_event_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_button_press_event (self, event);
	return result;
}


static void _unity_launcher_scroller_view_on_scroller_frame_clutter_timeline_new_frame (ClutterTimeline* _sender, gint msecs, gpointer self) {
	unity_launcher_scroller_view_on_scroller_frame (self, _sender, msecs);
}


static void _lambda16_ (UnityLauncherScrollerView* self) {
	self->priv->is_scrolling = FALSE;
	self->priv->button_down = FALSE;
}


static void __lambda16__unity_drag_controller_drag_start (UnityDragController* _sender, UnityDragModel* model, gpointer self) {
	_lambda16_ (self);
}


static GObject * unity_launcher_scroller_view_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityLauncherScrollerView * self;
	parent_class = G_OBJECT_CLASS (unity_launcher_scroller_view_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_LAUNCHER_SCROLLER_VIEW (obj);
	{
		UnityTestingObjectRegistry* _tmp0_;
		CtkPadding _tmp1_ = {0};
		CtkPadding mypadding;
		ClutterTimeline* _tmp2_;
		UnityDragController* drag_controller;
		GeeArrayList* _tmp3_;
		unity_testing_object_registry_register (_tmp0_ = unity_testing_object_registry_get_default (), "LauncherScrollerView", (GObject*) self);
		_unity_testing_object_registry_unref0 (_tmp0_);
		mypadding = (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_);
		mypadding.left = 0.0f;
		mypadding.right = 0.0f;
		mypadding.top = 10.0f;
		mypadding.bottom = 5.0f;
		ctk_actor_set_padding ((CtkActor*) self, &mypadding);
		unity_launcher_scroller_view_load_textures (self);
		g_signal_connect_object (self->priv->_model, "child-added", (GCallback) _unity_launcher_scroller_view_model_child_added_unity_launcher_scroller_model_child_added, self, 0);
		g_signal_connect_object (self->priv->_model, "child-removed", (GCallback) _unity_launcher_scroller_view_model_child_removed_unity_launcher_scroller_model_child_removed, self, 0);
		g_signal_connect_object (self->priv->_model, "order-changed", (GCallback) _unity_launcher_scroller_view_model_order_changed_unity_launcher_scroller_model_order_changed, self, 0);
		{
			UnityLauncherScrollerModelIterator* _child_it;
			_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
					break;
				}
				child = unity_launcher_scroller_model_iterator_get (_child_it);
				unity_launcher_scroller_view_model_child_added (self, child);
				_g_object_unref0 (child);
			}
			_unity_launcher_scroller_model_iterator_unref0 (_child_it);
		}
		g_signal_connect_object ((ClutterActor*) self, "button-press-event", (GCallback) _unity_launcher_scroller_view_on_button_press_event_clutter_actor_button_press_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "button-release-event", (GCallback) _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "motion-event", (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self, 0);
		self->priv->fling_timeline = (_tmp2_ = clutter_timeline_new ((guint) 1000), _g_object_unref0 (self->priv->fling_timeline), _tmp2_);
		clutter_timeline_set_loop (self->priv->fling_timeline, TRUE);
		g_signal_connect_object (self->priv->fling_timeline, "new-frame", (GCallback) _unity_launcher_scroller_view_on_scroller_frame_clutter_timeline_new_frame, self, 0);
		drag_controller = _g_object_ref0 (unity_drag_controller_get_default ());
		g_signal_connect_object (drag_controller, "drag-start", (GCallback) __lambda16__unity_drag_controller_drag_start, self, 0);
		clutter_actor_set_reactive ((ClutterActor*) self, TRUE);
		self->priv->child_refs = (_tmp3_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->child_refs), _tmp3_);
		unity_launcher_scroller_view_order_children (self, TRUE);
		clutter_actor_queue_relayout ((ClutterActor*) self);
		_g_object_unref0 (drag_controller);
	}
	return obj;
}


static void unity_launcher_scroller_view_class_init (UnityLauncherScrollerViewClass * klass) {
	unity_launcher_scroller_view_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityLauncherScrollerViewPrivate));
	CLUTTER_ACTOR_CLASS (klass)->get_preferred_width = unity_launcher_scroller_view_real_get_preferred_width;
	CLUTTER_ACTOR_CLASS (klass)->get_preferred_height = unity_launcher_scroller_view_real_get_preferred_height;
	CLUTTER_ACTOR_CLASS (klass)->allocate = unity_launcher_scroller_view_real_allocate;
	CLUTTER_ACTOR_CLASS (klass)->pick = unity_launcher_scroller_view_real_pick;
	CLUTTER_ACTOR_CLASS (klass)->paint = unity_launcher_scroller_view_real_paint;
	CLUTTER_ACTOR_CLASS (klass)->map = unity_launcher_scroller_view_real_map;
	CLUTTER_ACTOR_CLASS (klass)->unmap = unity_launcher_scroller_view_real_unmap;
	G_OBJECT_CLASS (klass)->get_property = unity_launcher_scroller_view_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_launcher_scroller_view_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_launcher_scroller_view_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_launcher_scroller_view_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_LAUNCHER_SCROLLER_VIEW_MODEL, g_param_spec_object ("model", "model", "model", UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void unity_launcher_scroller_view_instance_init (UnityLauncherScrollerView * self) {
	self->priv = UNITY_LAUNCHER_SCROLLER_VIEW_GET_PRIVATE (self);
	self->spacing = 6;
	self->drag_sensitivity = 7;
	self->friction = 0.9f;
	self->is_animating = FALSE;
	self->priv->button_down = FALSE;
	self->priv->total_child_height = 0.0f;
	self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_NONE;
	self->priv->last_motion_event_time = (guint) 0;
	self->priv->is_scrolling = FALSE;
	self->priv->scroll_position = 0.0f;
	self->priv->settle_position = 0.0f;
	self->priv->previous_y_position = 0.0f;
	self->priv->previous_y_time = (guint) 0;
	self->priv->stored_delta = (guint) 0;
	self->priv->scroll_speed = 0.0f;
}


static void unity_launcher_scroller_view_finalize (GObject* obj) {
	UnityLauncherScrollerView * self;
	self = UNITY_LAUNCHER_SCROLLER_VIEW (obj);
	_g_object_unref0 (self->priv->_model);
	_g_object_unref0 (self->priv->bgtex);
	_g_object_unref0 (self->priv->top_shadow);
	_g_object_unref0 (self->priv->bottom_fade);
	_g_object_unref0 (self->priv->fling_timeline);
	_g_object_unref0 (self->priv->child_refs);
	G_OBJECT_CLASS (unity_launcher_scroller_view_parent_class)->finalize (obj);
}


GType unity_launcher_scroller_view_get_type (void) {
	static volatile gsize unity_launcher_scroller_view_type_id__volatile = 0;
	if (g_once_init_enter (&unity_launcher_scroller_view_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityLauncherScrollerViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_launcher_scroller_view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityLauncherScrollerView), 0, (GInstanceInitFunc) unity_launcher_scroller_view_instance_init, NULL };
		GType unity_launcher_scroller_view_type_id;
		unity_launcher_scroller_view_type_id = g_type_register_static (CTK_TYPE_ACTOR, "UnityLauncherScrollerView", &g_define_type_info, 0);
		g_once_init_leave (&unity_launcher_scroller_view_type_id__volatile, unity_launcher_scroller_view_type_id);
	}
	return unity_launcher_scroller_view_type_id__volatile;
}


static void unity_launcher_scroller_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityLauncherScrollerView * self;
	self = UNITY_LAUNCHER_SCROLLER_VIEW (object);
	switch (property_id) {
		case UNITY_LAUNCHER_SCROLLER_VIEW_MODEL:
		g_value_set_object (value, unity_launcher_scroller_view_get_model (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_launcher_scroller_view_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityLauncherScrollerView * self;
	self = UNITY_LAUNCHER_SCROLLER_VIEW (object);
	switch (property_id) {
		case UNITY_LAUNCHER_SCROLLER_VIEW_MODEL:
		unity_launcher_scroller_view_set_model (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}




