/* scroller-view.c generated by valac, the Vala compiler
 * generated from scroller-view.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; c-basic-offset: 2; tab-width: 2 -*- */
/*
 * Copyright (C) 2010 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Gordon Allott <gord.allott@canonical.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <clutk/clutk.h>
#include <unity.h>
#include <clutter/clutter.h>
#include <gee.h>
#include <string.h>
#include <stdlib.h>
#include <gobject/gvaluecollector.h>


#define UNITY_LAUNCHER_TYPE_SCROLLER_PHASE (unity_launcher_scroller_phase_get_type ())

#define UNITY_LAUNCHER_TYPE_SCROLLER_VIEW_TYPE (unity_launcher_scroller_view_type_get_type ())

#define UNITY_LAUNCHER_TYPE_CHILD_TRANSITION (unity_launcher_child_transition_get_type ())
#define UNITY_LAUNCHER_CHILD_TRANSITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_CHILD_TRANSITION, UnityLauncherChildTransition))
#define UNITY_LAUNCHER_CHILD_TRANSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_CHILD_TRANSITION, UnityLauncherChildTransitionClass))
#define UNITY_LAUNCHER_IS_CHILD_TRANSITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_CHILD_TRANSITION))
#define UNITY_LAUNCHER_IS_CHILD_TRANSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_CHILD_TRANSITION))
#define UNITY_LAUNCHER_CHILD_TRANSITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_CHILD_TRANSITION, UnityLauncherChildTransitionClass))

typedef struct _UnityLauncherChildTransition UnityLauncherChildTransition;
typedef struct _UnityLauncherChildTransitionClass UnityLauncherChildTransitionClass;
typedef struct _UnityLauncherChildTransitionPrivate UnityLauncherChildTransitionPrivate;
typedef struct _UnityLauncherParamSpecChildTransition UnityLauncherParamSpecChildTransition;

#define UNITY_LAUNCHER_TYPE_SCROLLER_VIEW (unity_launcher_scroller_view_get_type ())
#define UNITY_LAUNCHER_SCROLLER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerView))
#define UNITY_LAUNCHER_SCROLLER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerViewClass))
#define UNITY_LAUNCHER_IS_SCROLLER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW))
#define UNITY_LAUNCHER_IS_SCROLLER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW))
#define UNITY_LAUNCHER_SCROLLER_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerViewClass))

typedef struct _UnityLauncherScrollerView UnityLauncherScrollerView;
typedef struct _UnityLauncherScrollerViewClass UnityLauncherScrollerViewClass;
typedef struct _UnityLauncherScrollerViewPrivate UnityLauncherScrollerViewPrivate;

#define UNITY_LAUNCHER_TYPE_SCROLLER_MODEL (unity_launcher_scroller_model_get_type ())
#define UNITY_LAUNCHER_SCROLLER_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, UnityLauncherScrollerModel))
#define UNITY_LAUNCHER_SCROLLER_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, UnityLauncherScrollerModelClass))
#define UNITY_LAUNCHER_IS_SCROLLER_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL))
#define UNITY_LAUNCHER_IS_SCROLLER_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL))
#define UNITY_LAUNCHER_SCROLLER_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, UnityLauncherScrollerModelClass))

typedef struct _UnityLauncherScrollerModel UnityLauncherScrollerModel;
typedef struct _UnityLauncherScrollerModelClass UnityLauncherScrollerModelClass;

#define UNITY_LAUNCHER_TYPE_SCROLLER_CHILD (unity_launcher_scroller_child_get_type ())
#define UNITY_LAUNCHER_SCROLLER_CHILD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, UnityLauncherScrollerChild))
#define UNITY_LAUNCHER_SCROLLER_CHILD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, UnityLauncherScrollerChildClass))
#define UNITY_LAUNCHER_IS_SCROLLER_CHILD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD))
#define UNITY_LAUNCHER_IS_SCROLLER_CHILD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD))
#define UNITY_LAUNCHER_SCROLLER_CHILD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, UnityLauncherScrollerChildClass))

typedef struct _UnityLauncherScrollerChild UnityLauncherScrollerChild;
typedef struct _UnityLauncherScrollerChildClass UnityLauncherScrollerChildClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR (unity_launcher_scroller_model_iterator_get_type ())
#define UNITY_LAUNCHER_SCROLLER_MODEL_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR, UnityLauncherScrollerModelIterator))
#define UNITY_LAUNCHER_SCROLLER_MODEL_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR, UnityLauncherScrollerModelIteratorClass))
#define UNITY_LAUNCHER_SCROLLER_MODEL_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR))
#define UNITY_LAUNCHER_SCROLLER_MODEL_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR))
#define UNITY_LAUNCHER_SCROLLER_MODEL_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_SCROLLER_MODEL_TYPE_ITERATOR, UnityLauncherScrollerModelIteratorClass))

typedef struct _UnityLauncherScrollerModelIterator UnityLauncherScrollerModelIterator;
typedef struct _UnityLauncherScrollerModelIteratorClass UnityLauncherScrollerModelIteratorClass;
#define _unity_launcher_scroller_model_iterator_unref0(var) ((var == NULL) ? NULL : (var = (unity_launcher_scroller_model_iterator_unref (var), NULL)))
typedef struct _Block7Data Block7Data;

#define TYPE_MENU_MANAGER (menu_manager_get_type ())
#define MENU_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MENU_MANAGER, MenuManager))
#define MENU_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MENU_MANAGER, MenuManagerClass))
#define IS_MENU_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MENU_MANAGER))
#define IS_MENU_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MENU_MANAGER))
#define MENU_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MENU_MANAGER, MenuManagerClass))

typedef struct _MenuManager MenuManager;
typedef struct _MenuManagerClass MenuManagerClass;
#define _unity_launcher_child_transition_unref0(var) ((var == NULL) ? NULL : (var = (unity_launcher_child_transition_unref (var), NULL)))

#define UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD (unity_launcher_launcher_child_get_type ())
#define UNITY_LAUNCHER_LAUNCHER_CHILD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD, UnityLauncherLauncherChild))
#define UNITY_LAUNCHER_LAUNCHER_CHILD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD, UnityLauncherLauncherChildClass))
#define UNITY_LAUNCHER_IS_LAUNCHER_CHILD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD))
#define UNITY_LAUNCHER_IS_LAUNCHER_CHILD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD))
#define UNITY_LAUNCHER_LAUNCHER_CHILD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_LAUNCHER_TYPE_LAUNCHER_CHILD, UnityLauncherLauncherChildClass))

typedef struct _UnityLauncherLauncherChild UnityLauncherLauncherChild;
typedef struct _UnityLauncherLauncherChildClass UnityLauncherLauncherChildClass;

#define UNITY_TESTING_TYPE_OBJECT_REGISTRY (unity_testing_object_registry_get_type ())
#define UNITY_TESTING_OBJECT_REGISTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TESTING_TYPE_OBJECT_REGISTRY, UnityTestingObjectRegistry))
#define UNITY_TESTING_OBJECT_REGISTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TESTING_TYPE_OBJECT_REGISTRY, UnityTestingObjectRegistryClass))
#define UNITY_TESTING_IS_OBJECT_REGISTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TESTING_TYPE_OBJECT_REGISTRY))
#define UNITY_TESTING_IS_OBJECT_REGISTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TESTING_TYPE_OBJECT_REGISTRY))
#define UNITY_TESTING_OBJECT_REGISTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TESTING_TYPE_OBJECT_REGISTRY, UnityTestingObjectRegistryClass))

typedef struct _UnityTestingObjectRegistry UnityTestingObjectRegistry;
typedef struct _UnityTestingObjectRegistryClass UnityTestingObjectRegistryClass;
#define _unity_testing_object_registry_unref0(var) ((var == NULL) ? NULL : (var = (unity_testing_object_registry_unref (var), NULL)))

typedef enum  {
	UNITY_LAUNCHER_SCROLLER_PHASE_PANNING,
	UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING,
	UNITY_LAUNCHER_SCROLLER_PHASE_REORDERING,
	UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG,
	UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE,
	UNITY_LAUNCHER_SCROLLER_PHASE_NONE
} UnityLauncherScrollerPhase;

typedef enum  {
	UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED,
	UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED
} UnityLauncherScrollerViewType;

struct _UnityLauncherChildTransition {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityLauncherChildTransitionPrivate * priv;
	float position;
	float rotation;
};

struct _UnityLauncherChildTransitionClass {
	GTypeClass parent_class;
	void (*finalize) (UnityLauncherChildTransition *self);
};

struct _UnityLauncherParamSpecChildTransition {
	GParamSpec parent_instance;
};

struct _UnityLauncherScrollerView {
	CtkActor parent_instance;
	UnityLauncherScrollerViewPrivate * priv;
	gint spacing;
	gint drag_sensitivity;
	float friction;
	gboolean is_animating;
};

struct _UnityLauncherScrollerViewClass {
	CtkActorClass parent_class;
};

struct _UnityLauncherScrollerViewPrivate {
	UnityLauncherScrollerModel* _model;
	UnityThemeImage* bgtex;
	UnityThemeImage* top_shadow;
	gboolean button_down;
	float total_child_height;
	UnityLauncherScrollerPhase current_phase;
	guint last_motion_event_time;
	UnityLauncherScrollerViewType view_type;
	gboolean is_scrolling;
	float scroll_position;
	float settle_position;
	ClutterTimeline* fling_timeline;
	float previous_y_position;
	guint previous_y_time;
	guint stored_delta;
	float scroll_speed;
	float contract_icon_degrees;
	gint focused_launcher;
	GeeArrayList* draw_ftb;
	GeeArrayList* draw_btf;
	GeeArrayList* child_refs;
};

struct _Block7Data {
	int _ref_count_;
	UnityLauncherScrollerView * self;
	UnityLauncherScrollerChild* child;
};


static gpointer unity_launcher_child_transition_parent_class = NULL;
static gpointer unity_launcher_scroller_view_parent_class = NULL;

GType unity_launcher_scroller_phase_get_type (void);
GType unity_launcher_scroller_view_type_get_type (void);
gpointer unity_launcher_child_transition_ref (gpointer instance);
void unity_launcher_child_transition_unref (gpointer instance);
GParamSpec* unity_launcher_param_spec_child_transition (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_launcher_value_set_child_transition (GValue* value, gpointer v_object);
void unity_launcher_value_take_child_transition (GValue* value, gpointer v_object);
gpointer unity_launcher_value_get_child_transition (const GValue* value);
GType unity_launcher_child_transition_get_type (void);
enum  {
	UNITY_LAUNCHER_CHILD_TRANSITION_DUMMY_PROPERTY
};
UnityLauncherChildTransition* unity_launcher_child_transition_new (void);
UnityLauncherChildTransition* unity_launcher_child_transition_construct (GType object_type);
static void unity_launcher_child_transition_finalize (UnityLauncherChildTransition* obj);
GType unity_launcher_scroller_view_get_type (void);
GType unity_launcher_scroller_model_get_type (void);
GType unity_launcher_scroller_child_get_type (void);
#define UNITY_LAUNCHER_SCROLLER_VIEW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, UnityLauncherScrollerViewPrivate))
enum  {
	UNITY_LAUNCHER_SCROLLER_VIEW_DUMMY_PROPERTY,
	UNITY_LAUNCHER_SCROLLER_VIEW_MODEL
};
UnityLauncherScrollerView* unity_launcher_scroller_view_new (UnityLauncherScrollerModel* _model);
UnityLauncherScrollerView* unity_launcher_scroller_view_construct (GType object_type, UnityLauncherScrollerModel* _model);
UnityLauncherScrollerModel* unity_launcher_scroller_view_get_model (UnityLauncherScrollerView* self);
UnityLauncherScrollerChild* unity_launcher_scroller_model_get (UnityLauncherScrollerModel* self, gint i);
gint unity_launcher_scroller_model_get_size (UnityLauncherScrollerModel* self);
gint unity_launcher_scroller_model_index_of (UnityLauncherScrollerModel* self, UnityLauncherScrollerChild* child);
gint unity_launcher_scroller_view_get_model_index_at_y_pos (UnityLauncherScrollerView* self, float y);
static void unity_launcher_scroller_view_load_textures (UnityLauncherScrollerView* self);
static void unity_launcher_scroller_view_order_children (UnityLauncherScrollerView* self, gboolean immediate);
static void unity_launcher_scroller_view_move_scroll_position (UnityLauncherScrollerView* self, float pixels);
gpointer unity_launcher_scroller_model_iterator_ref (gpointer instance);
void unity_launcher_scroller_model_iterator_unref (gpointer instance);
GParamSpec* unity_launcher_scroller_model_param_spec_iterator (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_launcher_scroller_model_value_set_iterator (GValue* value, gpointer v_object);
void unity_launcher_scroller_model_value_take_iterator (GValue* value, gpointer v_object);
gpointer unity_launcher_scroller_model_value_get_iterator (const GValue* value);
GType unity_launcher_scroller_model_iterator_get_type (void);
UnityLauncherScrollerModelIterator* unity_launcher_scroller_model_iterator (UnityLauncherScrollerModel* self);
gboolean unity_launcher_scroller_model_iterator_next (UnityLauncherScrollerModelIterator* self);
UnityLauncherScrollerChild* unity_launcher_scroller_model_iterator_get (UnityLauncherScrollerModelIterator* self);
static void unity_launcher_scroller_view_disable_animations_on_children (UnityLauncherScrollerView* self, ClutterEvent* event);
static void _lambda32_ (UnityLauncherScrollerView* self);
static void __lambda32__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void unity_launcher_scroller_view_model_child_added (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child);
#define UNITY_LAUNCHER_SHORT_DELAY ((guint) 400)
static void _lambda33_ (Block7Data* _data7_);
static void __lambda33__clutter_animation_completed (ClutterAnimation* _sender, gpointer self);
static Block7Data* block7_data_ref (Block7Data* _data7_);
static void block7_data_unref (Block7Data* _data7_);
static void unity_launcher_scroller_view_model_child_removed (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child);
static void unity_launcher_scroller_view_model_order_changed (UnityLauncherScrollerView* self);
static gboolean unity_launcher_scroller_view_on_button_release_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean unity_launcher_scroller_view_on_button_press_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean unity_launcher_scroller_view_on_motion_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static float unity_launcher_scroller_view_get_aligned_settle_position (UnityLauncherScrollerView* self);
GType menu_manager_get_type (void);
MenuManager* menu_manager_get_default (void);
void menu_manager_popdown_current_menu (MenuManager* self);
static float unity_launcher_scroller_view_get_total_children_height (UnityLauncherScrollerView* self);
static float unity_launcher_scroller_view_get_available_height (UnityLauncherScrollerView* self);
float unity_launcher_scroller_child_get_position (UnityLauncherScrollerChild* self);
static gboolean unity_launcher_scroller_view_on_enter_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static gboolean unity_launcher_scroller_view_on_leave_event (UnityLauncherScrollerView* self, ClutterEvent* event);
static void unity_launcher_scroller_view_do_anim_settle (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_do_anim_fling (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_do_anim_bounce (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_on_scroller_frame (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs);
static void unity_launcher_scroller_view_real_get_preferred_width (ClutterActor* base, float for_height, float* minimum_width, float* natural_width);
static void unity_launcher_scroller_view_real_get_preferred_height (ClutterActor* base, float for_width, float* minimum_height, float* natural_height);
static GeeArrayList* unity_launcher_scroller_view_order_children_expanded (UnityLauncherScrollerView* self);
static GeeArrayList* unity_launcher_scroller_view_order_children_contracted (UnityLauncherScrollerView* self);
void unity_launcher_scroller_child_set_position (UnityLauncherScrollerChild* self, float value);
void unity_launcher_scroller_child_force_rotation_jump (UnityLauncherScrollerChild* self, float degrees);
void unity_launcher_scroller_child_set_rotation (UnityLauncherScrollerChild* self, float value);
static void unity_launcher_scroller_view_real_allocate (ClutterActor* base, const ClutterActorBox* box, ClutterAllocationFlags flags);
GType unity_launcher_launcher_child_get_type (void);
static void unity_launcher_scroller_view_real_pick (ClutterActor* base, const ClutterColor* color);
static void unity_launcher_scroller_view_real_paint (ClutterActor* base);
static void unity_launcher_scroller_view_real_map (ClutterActor* base);
static void unity_launcher_scroller_view_real_unmap (ClutterActor* base);
static void unity_launcher_scroller_view_set_model (UnityLauncherScrollerView* self, UnityLauncherScrollerModel* value);
gpointer unity_testing_object_registry_ref (gpointer instance);
void unity_testing_object_registry_unref (gpointer instance);
GParamSpec* unity_testing_param_spec_object_registry (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_testing_value_set_object_registry (GValue* value, gpointer v_object);
void unity_testing_value_take_object_registry (GValue* value, gpointer v_object);
gpointer unity_testing_value_get_object_registry (const GValue* value);
GType unity_testing_object_registry_get_type (void);
UnityTestingObjectRegistry* unity_testing_object_registry_get_default (void);
void unity_testing_object_registry_register (UnityTestingObjectRegistry* self, const char* name, GObject* object);
static void _unity_launcher_scroller_view_model_child_added_unity_launcher_scroller_model_child_added (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self);
static void _unity_launcher_scroller_view_model_child_removed_unity_launcher_scroller_model_child_removed (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self);
static void _unity_launcher_scroller_view_model_order_changed_unity_launcher_scroller_model_order_changed (UnityLauncherScrollerModel* _sender, gpointer self);
static gboolean _unity_launcher_scroller_view_on_button_press_event_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static void _unity_launcher_scroller_view_on_scroller_frame_clutter_timeline_new_frame (ClutterTimeline* _sender, gint msecs, gpointer self);
static void _lambda34_ (UnityLauncherScrollerView* self);
static void __lambda34__unity_drag_controller_drag_start (UnityDragController* _sender, UnityDragModel* model, gpointer self);
static gboolean _lambda35_ (UnityLauncherScrollerView* self);
static gboolean __lambda35__gsource_func (gpointer self);
static GObject * unity_launcher_scroller_view_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_launcher_scroller_view_finalize (GObject* obj);
static void unity_launcher_scroller_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_launcher_scroller_view_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);



GType unity_launcher_scroller_phase_get_type (void) {
	static volatile gsize unity_launcher_scroller_phase_type_id__volatile = 0;
	if (g_once_init_enter (&unity_launcher_scroller_phase_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_LAUNCHER_SCROLLER_PHASE_PANNING, "UNITY_LAUNCHER_SCROLLER_PHASE_PANNING", "panning"}, {UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING, "UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING", "settling"}, {UNITY_LAUNCHER_SCROLLER_PHASE_REORDERING, "UNITY_LAUNCHER_SCROLLER_PHASE_REORDERING", "reordering"}, {UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG, "UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG", "flung"}, {UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE, "UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE", "bounce"}, {UNITY_LAUNCHER_SCROLLER_PHASE_NONE, "UNITY_LAUNCHER_SCROLLER_PHASE_NONE", "none"}, {0, NULL, NULL}};
		GType unity_launcher_scroller_phase_type_id;
		unity_launcher_scroller_phase_type_id = g_enum_register_static ("UnityLauncherScrollerPhase", values);
		g_once_init_leave (&unity_launcher_scroller_phase_type_id__volatile, unity_launcher_scroller_phase_type_id);
	}
	return unity_launcher_scroller_phase_type_id__volatile;
}


GType unity_launcher_scroller_view_type_get_type (void) {
	static volatile gsize unity_launcher_scroller_view_type_type_id__volatile = 0;
	if (g_once_init_enter (&unity_launcher_scroller_view_type_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED, "UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED", "expanded"}, {UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED, "UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED", "contracted"}, {0, NULL, NULL}};
		GType unity_launcher_scroller_view_type_type_id;
		unity_launcher_scroller_view_type_type_id = g_enum_register_static ("UnityLauncherScrollerViewType", values);
		g_once_init_leave (&unity_launcher_scroller_view_type_type_id__volatile, unity_launcher_scroller_view_type_type_id);
	}
	return unity_launcher_scroller_view_type_type_id__volatile;
}


UnityLauncherChildTransition* unity_launcher_child_transition_construct (GType object_type) {
	UnityLauncherChildTransition* self;
	self = (UnityLauncherChildTransition*) g_type_create_instance (object_type);
	return self;
}


UnityLauncherChildTransition* unity_launcher_child_transition_new (void) {
	return unity_launcher_child_transition_construct (UNITY_LAUNCHER_TYPE_CHILD_TRANSITION);
}


static void unity_launcher_value_child_transition_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void unity_launcher_value_child_transition_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		unity_launcher_child_transition_unref (value->data[0].v_pointer);
	}
}


static void unity_launcher_value_child_transition_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = unity_launcher_child_transition_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer unity_launcher_value_child_transition_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* unity_launcher_value_child_transition_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		UnityLauncherChildTransition* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = unity_launcher_child_transition_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* unity_launcher_value_child_transition_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	UnityLauncherChildTransition** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = unity_launcher_child_transition_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* unity_launcher_param_spec_child_transition (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	UnityLauncherParamSpecChildTransition* spec;
	g_return_val_if_fail (g_type_is_a (object_type, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer unity_launcher_value_get_child_transition (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION), NULL);
	return value->data[0].v_pointer;
}


void unity_launcher_value_set_child_transition (GValue* value, gpointer v_object) {
	UnityLauncherChildTransition* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		unity_launcher_child_transition_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_launcher_child_transition_unref (old);
	}
}


void unity_launcher_value_take_child_transition (GValue* value, gpointer v_object) {
	UnityLauncherChildTransition* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_LAUNCHER_TYPE_CHILD_TRANSITION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_launcher_child_transition_unref (old);
	}
}


static void unity_launcher_child_transition_class_init (UnityLauncherChildTransitionClass * klass) {
	unity_launcher_child_transition_parent_class = g_type_class_peek_parent (klass);
	UNITY_LAUNCHER_CHILD_TRANSITION_CLASS (klass)->finalize = unity_launcher_child_transition_finalize;
}


static void unity_launcher_child_transition_instance_init (UnityLauncherChildTransition * self) {
	self->ref_count = 1;
}


static void unity_launcher_child_transition_finalize (UnityLauncherChildTransition* obj) {
	UnityLauncherChildTransition * self;
	self = UNITY_LAUNCHER_CHILD_TRANSITION (obj);
}


GType unity_launcher_child_transition_get_type (void) {
	static volatile gsize unity_launcher_child_transition_type_id__volatile = 0;
	if (g_once_init_enter (&unity_launcher_child_transition_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { unity_launcher_value_child_transition_init, unity_launcher_value_child_transition_free_value, unity_launcher_value_child_transition_copy_value, unity_launcher_value_child_transition_peek_pointer, "p", unity_launcher_value_child_transition_collect_value, "p", unity_launcher_value_child_transition_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UnityLauncherChildTransitionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_launcher_child_transition_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityLauncherChildTransition), 0, (GInstanceInitFunc) unity_launcher_child_transition_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType unity_launcher_child_transition_type_id;
		unity_launcher_child_transition_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UnityLauncherChildTransition", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&unity_launcher_child_transition_type_id__volatile, unity_launcher_child_transition_type_id);
	}
	return unity_launcher_child_transition_type_id__volatile;
}


gpointer unity_launcher_child_transition_ref (gpointer instance) {
	UnityLauncherChildTransition* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void unity_launcher_child_transition_unref (gpointer instance) {
	UnityLauncherChildTransition* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UNITY_LAUNCHER_CHILD_TRANSITION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


UnityLauncherScrollerView* unity_launcher_scroller_view_construct (GType object_type, UnityLauncherScrollerModel* _model) {
	UnityLauncherScrollerView * self;
	g_return_val_if_fail (_model != NULL, NULL);
	self = (UnityLauncherScrollerView*) g_object_new (object_type, "model", _model, NULL);
	return self;
}


UnityLauncherScrollerView* unity_launcher_scroller_view_new (UnityLauncherScrollerModel* _model) {
	return unity_launcher_scroller_view_construct (UNITY_LAUNCHER_TYPE_SCROLLER_VIEW, _model);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


gint unity_launcher_scroller_view_get_model_index_at_y_pos (UnityLauncherScrollerView* self, float y) {
	gint result = 0;
	gint iy;
	ClutterActor* _tmp0_;
	ClutterActor* picked_actor;
	ClutterActor* _tmp9_;
	g_return_val_if_fail (self != NULL, 0);
	iy = (gint) y;
	picked_actor = _g_object_ref0 (clutter_stage_get_actor_at_pos ((_tmp0_ = clutter_actor_get_stage ((ClutterActor*) self), CLUTTER_IS_STAGE (_tmp0_) ? ((ClutterStage*) _tmp0_) : NULL), CLUTTER_PICK_REACTIVE, 25, iy));
	if (UNITY_LAUNCHER_IS_SCROLLER_CHILD (picked_actor) == FALSE) {
		ClutterActor* _tmp2_;
		ClutterActor* _tmp1_;
		picked_actor = (_tmp2_ = _g_object_ref0 (clutter_stage_get_actor_at_pos ((_tmp1_ = clutter_actor_get_stage ((ClutterActor*) self), CLUTTER_IS_STAGE (_tmp1_) ? ((ClutterStage*) _tmp1_) : NULL), CLUTTER_PICK_REACTIVE, 25, iy - self->spacing)), _g_object_unref0 (picked_actor), _tmp2_);
		if (UNITY_LAUNCHER_IS_SCROLLER_CHILD (picked_actor) == FALSE) {
			ClutterActor* _tmp4_;
			ClutterActor* _tmp3_;
			picked_actor = (_tmp4_ = _g_object_ref0 (clutter_stage_get_actor_at_pos ((_tmp3_ = clutter_actor_get_stage ((ClutterActor*) self), CLUTTER_IS_STAGE (_tmp3_) ? ((ClutterStage*) _tmp3_) : NULL), CLUTTER_PICK_REACTIVE, 25, iy + self->spacing)), _g_object_unref0 (picked_actor), _tmp4_);
			if (UNITY_LAUNCHER_IS_SCROLLER_CHILD (picked_actor) == FALSE) {
				gint _tmp5_ = 0;
				UnityLauncherScrollerChild* _tmp7_;
				CtkPadding _tmp6_ = {0};
				gboolean _tmp8_;
				if ((_tmp8_ = y < (((ctk_actor_get_padding ((CtkActor*) self, &_tmp6_), _tmp6_.top) + clutter_actor_get_height ((ClutterActor*) (_tmp7_ = unity_launcher_scroller_model_get (self->priv->_model, 0)))) + self->spacing), _g_object_unref0 (_tmp7_), _tmp8_)) {
					_tmp5_ = 0;
				} else {
					_tmp5_ = unity_launcher_scroller_model_get_size (self->priv->_model) - 1;
				}
				result = _tmp5_;
				_g_object_unref0 (picked_actor);
				return result;
			}
		}
	}
	result = unity_launcher_scroller_model_index_of (self->priv->_model, (_tmp9_ = picked_actor, UNITY_LAUNCHER_IS_SCROLLER_CHILD (_tmp9_) ? ((UnityLauncherScrollerChild*) _tmp9_) : NULL));
	_g_object_unref0 (picked_actor);
	return result;
	_g_object_unref0 (picked_actor);
}


static void unity_launcher_scroller_view_load_textures (UnityLauncherScrollerView* self) {
	UnityThemeImage* _tmp0_;
	UnityThemeImage* _tmp1_;
	g_return_if_fail (self != NULL);
	self->priv->bgtex = (_tmp0_ = g_object_ref_sink (unity_theme_image_new ("launcher_background_middle")), _g_object_unref0 (self->priv->bgtex), _tmp0_);
	clutter_texture_set_repeat ((ClutterTexture*) self->priv->bgtex, TRUE, TRUE);
	clutter_actor_set_parent ((ClutterActor*) self->priv->bgtex, (ClutterActor*) self);
	self->priv->top_shadow = (_tmp1_ = g_object_ref_sink (unity_theme_image_new ("overflow_top")), _g_object_unref0 (self->priv->top_shadow), _tmp1_);
	clutter_texture_set_repeat ((ClutterTexture*) self->priv->top_shadow, TRUE, FALSE);
	clutter_actor_set_parent ((ClutterActor*) self->priv->top_shadow, (ClutterActor*) self);
}


static void unity_launcher_scroller_view_move_scroll_position (UnityLauncherScrollerView* self, float pixels) {
	g_return_if_fail (self != NULL);
	self->priv->scroll_position = self->priv->scroll_position + pixels;
	unity_launcher_scroller_view_order_children (self, TRUE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static void unity_launcher_scroller_view_disable_animations_on_children (UnityLauncherScrollerView* self, ClutterEvent* event) {
	ClutterEvent _tmp0_ = {0};
	ClutterEvent e;
	g_return_if_fail (self != NULL);
	e = (_tmp0_.type = 0, _tmp0_);
	e.type = CLUTTER_LEAVE;
	e.crossing.time = (*event).motion.time;
	e.crossing.flags = (*event).motion.flags;
	e.crossing.stage = (*event).motion.stage;
	e.crossing.x = (*event).motion.x;
	e.crossing.y = (*event).motion.y;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			if (CLUTTER_IS_ACTOR (child)) {
				e.crossing.source = (ClutterActor*) child;
				clutter_actor_event ((ClutterActor*) child, &e, FALSE);
			}
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


static void _lambda32_ (UnityLauncherScrollerView* self) {
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static void __lambda32__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_lambda32_ (self);
}


static void unity_launcher_scroller_view_model_child_added (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (child != NULL);
	clutter_actor_unparent ((ClutterActor*) child);
	clutter_actor_set_parent ((ClutterActor*) child, (ClutterActor*) self);
	if (unity_launcher_scroller_model_index_of (self->priv->_model, child) == (unity_launcher_scroller_model_get_size (self->priv->_model) - 1)) {
		unity_launcher_scroller_view_order_children (self, TRUE);
	} else {
		unity_launcher_scroller_view_order_children (self, FALSE);
	}
	clutter_actor_queue_relayout ((ClutterActor*) self);
	g_signal_connect_object ((GObject*) child, "notify::position", (GCallback) __lambda32__g_object_notify, self, 0);
}


static void _lambda33_ (Block7Data* _data7_) {
	UnityLauncherScrollerView * self;
	self = _data7_->self;
	clutter_actor_unparent ((ClutterActor*) _data7_->child);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->child_refs, _data7_->child);
}


static void __lambda33__clutter_animation_completed (ClutterAnimation* _sender, gpointer self) {
	_lambda33_ (self);
}


static Block7Data* block7_data_ref (Block7Data* _data7_) {
	++_data7_->_ref_count_;
	return _data7_;
}


static void block7_data_unref (Block7Data* _data7_) {
	if ((--_data7_->_ref_count_) == 0) {
		_g_object_unref0 (_data7_->self);
		_g_object_unref0 (_data7_->child);
		g_slice_free (Block7Data, _data7_);
	}
}


static void unity_launcher_scroller_view_model_child_removed (UnityLauncherScrollerView* self, UnityLauncherScrollerChild* child) {
	Block7Data* _data7_;
	ClutterAnimation* anim;
	g_return_if_fail (self != NULL);
	g_return_if_fail (child != NULL);
	_data7_ = g_slice_new0 (Block7Data);
	_data7_->_ref_count_ = 1;
	_data7_->self = g_object_ref (self);
	_data7_->child = _g_object_ref0 (child);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->child_refs, _data7_->child);
	anim = _g_object_ref0 (clutter_actor_animate ((ClutterActor*) _data7_->child, (gulong) CLUTTER_EASE_OUT_QUAD, UNITY_LAUNCHER_SHORT_DELAY, "opacity", 0, NULL));
	g_signal_connect_data (anim, "completed", (GCallback) __lambda33__clutter_animation_completed, block7_data_ref (_data7_), (GClosureNotify) block7_data_unref, 0);
	unity_launcher_scroller_view_order_children (self, FALSE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
	_g_object_unref0 (anim);
	block7_data_unref (_data7_);
}


static void unity_launcher_scroller_view_model_order_changed (UnityLauncherScrollerView* self) {
	g_return_if_fail (self != NULL);
	unity_launcher_scroller_view_order_children (self, FALSE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static gboolean _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_button_release_event (self, event);
	return result;
}


static gboolean unity_launcher_scroller_view_on_button_press_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if ((*event).button.button != 1) {
		result = FALSE;
		return result;
	}
	self->priv->button_down = TRUE;
	self->priv->previous_y_position = (*event).button.y;
	self->priv->previous_y_time = (guint) (*event).button.time;
	g_signal_connect_object (clutter_actor_get_stage ((ClutterActor*) self), "button-release-event", (GCallback) _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event, self, 0);
	result = TRUE;
	return result;
}


static gboolean _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_motion_event (self, event);
	return result;
}


static gboolean unity_launcher_scroller_view_on_button_release_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	guint _tmp0_;
	MenuManager* manager;
	g_return_val_if_fail (self != NULL, FALSE);
	if ((*event).button.button != 1) {
		result = FALSE;
		return result;
	}
	self->priv->button_down = FALSE;
	g_signal_parse_name ("button-release-event", CLUTTER_TYPE_ACTOR, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (clutter_actor_get_stage ((ClutterActor*) self), G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event, self);
	unity_shell_remove_fullscreen_request (unity_global_shell, (GObject*) self);
	if (self->priv->is_scrolling) {
		guint _tmp1_;
		self->priv->is_scrolling = FALSE;
		clutter_ungrab_pointer ();
		g_signal_parse_name ("motion-event", CLUTTER_TYPE_ACTOR, &_tmp1_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (clutter_actor_get_stage ((ClutterActor*) self), G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self);
		if (((*event).button.time - self->priv->last_motion_event_time) > 120) {
			self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING;
			self->priv->settle_position = unity_launcher_scroller_view_get_aligned_settle_position (self);
		} else {
			self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG;
		}
		{
			UnityLauncherScrollerModelIterator* _child_it;
			_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
					break;
				}
				child = unity_launcher_scroller_model_iterator_get (_child_it);
				clutter_actor_set_reactive ((ClutterActor*) child, FALSE);
				_g_object_unref0 (child);
			}
			_unity_launcher_scroller_model_iterator_unref0 (_child_it);
		}
		clutter_timeline_start (self->priv->fling_timeline);
	}
	manager = menu_manager_get_default ();
	menu_manager_popdown_current_menu (manager);
	result = TRUE;
	_g_object_unref0 (manager);
	return result;
}


static gboolean unity_launcher_scroller_view_on_enter_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->view_type == UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED) {
		result = FALSE;
		return result;
	}
	self->priv->view_type = UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED;
	unity_shell_add_fullscreen_request (unity_global_shell, (GObject*) self);
	if (unity_launcher_scroller_view_get_total_children_height (self) > unity_launcher_scroller_view_get_available_height (self)) {
		gint index;
		float old_scroll_position;
		UnityLauncherScrollerChild* _tmp0_;
		float _tmp1_;
		float child_height;
		UnityLauncherScrollerChild* _tmp3_;
		UnityLauncherScrollerChild* _tmp2_;
		float _tmp4_;
		float new_scroll_position;
		index = unity_launcher_scroller_view_get_model_index_at_y_pos (self, (*event).crossing.y);
		old_scroll_position = self->priv->scroll_position;
		self->priv->scroll_position = (float) 0;
		unity_launcher_scroller_view_order_children (self, TRUE);
		child_height = (_tmp1_ = clutter_actor_get_height ((ClutterActor*) (_tmp0_ = unity_launcher_scroller_model_get (self->priv->_model, index))) / 2, _g_object_unref0 (_tmp0_), _tmp1_);
		new_scroll_position = (_tmp4_ = ((-unity_launcher_scroller_child_get_position (_tmp2_ = unity_launcher_scroller_model_get (self->priv->_model, index))) + (*event).crossing.y) - clutter_actor_get_height ((ClutterActor*) (_tmp3_ = unity_launcher_scroller_model_get (self->priv->_model, index))), _g_object_unref0 (_tmp3_), _g_object_unref0 (_tmp2_), _tmp4_);
		self->priv->view_type = UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED;
		self->priv->scroll_position = old_scroll_position;
		unity_launcher_scroller_view_order_children (self, TRUE);
		self->priv->view_type = UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED;
		self->priv->scroll_position = new_scroll_position;
		unity_launcher_scroller_view_order_children (self, FALSE);
		clutter_actor_queue_relayout ((ClutterActor*) self);
	}
	result = FALSE;
	return result;
}


static gboolean unity_launcher_scroller_view_on_leave_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->view_type == UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED) {
		result = FALSE;
		return result;
	}
	if ((*event).crossing.x < (clutter_actor_get_width ((ClutterActor*) self) - 1)) {
		result = FALSE;
		return result;
	}
	unity_shell_remove_fullscreen_request (unity_global_shell, (GObject*) self);
	self->priv->focused_launcher = unity_launcher_scroller_view_get_model_index_at_y_pos (self, (*event).crossing.y);
	self->priv->view_type = UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED;
	unity_launcher_scroller_view_order_children (self, FALSE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
	result = FALSE;
	return result;
}


static gboolean unity_launcher_scroller_view_on_motion_event (UnityLauncherScrollerView* self, ClutterEvent* event) {
	gboolean result = FALSE;
	UnityDragController* drag_controller;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	drag_controller = _g_object_ref0 (unity_drag_controller_get_default ());
	if (unity_drag_controller_get_is_dragging (drag_controller)) {
		result = FALSE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	self->priv->last_motion_event_time = (guint) (*event).motion.time;
	if (self->priv->button_down) {
		_tmp1_ = self->priv->is_scrolling == FALSE;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = self->priv->view_type != UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		float diff;
		diff = (*event).motion.y - self->priv->previous_y_position;
		if (fabsf (diff) > self->drag_sensitivity) {
			self->priv->is_scrolling = TRUE;
			unity_shell_add_fullscreen_request (unity_global_shell, (GObject*) self);
			clutter_grab_pointer ((ClutterActor*) self);
			g_signal_connect_object (clutter_actor_get_stage ((ClutterActor*) self), "motion-event", (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self, 0);
		}
	}
	if (self->priv->is_scrolling) {
		float pixel_diff;
		guint time_diff;
		unity_launcher_scroller_view_disable_animations_on_children (self, event);
		pixel_diff = (*event).motion.y - self->priv->previous_y_position;
		time_diff = (guint) ((*event).motion.time - self->priv->previous_y_time);
		self->priv->scroll_speed = pixel_diff / (time_diff / 1000.0f);
		self->priv->previous_y_position = (*event).motion.y;
		self->priv->previous_y_time = (guint) (*event).motion.time;
		unity_launcher_scroller_view_move_scroll_position (self, pixel_diff);
		result = TRUE;
		_g_object_unref0 (drag_controller);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (drag_controller);
	return result;
}


static void unity_launcher_scroller_view_on_scroller_frame (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	guint delta;
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	delta = clutter_timeline_get_delta (timeline);
	delta = delta + self->priv->stored_delta;
	if (delta <= 16) {
		self->priv->stored_delta = delta;
		return;
	}
	while (TRUE) {
		if (!(delta > 16)) {
			break;
		}
		self->is_animating = TRUE;
		delta = delta - ((guint) 16);
		switch (self->priv->current_phase) {
			case UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING:
			{
				unity_launcher_scroller_view_do_anim_settle (self, timeline, msecs);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_PHASE_FLUNG:
			{
				unity_launcher_scroller_view_do_anim_fling (self, timeline, msecs);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE:
			{
				unity_launcher_scroller_view_do_anim_bounce (self, timeline, msecs);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_PHASE_NONE:
			{
				clutter_timeline_stop (timeline);
				self->priv->scroll_speed = 0.0f;
				self->is_animating = FALSE;
				{
					UnityLauncherScrollerModelIterator* _child_it;
					_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
					while (TRUE) {
						UnityLauncherScrollerChild* child;
						if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
							break;
						}
						child = unity_launcher_scroller_model_iterator_get (_child_it);
						clutter_actor_set_reactive ((ClutterActor*) child, TRUE);
						_g_object_unref0 (child);
					}
					_unity_launcher_scroller_model_iterator_unref0 (_child_it);
				}
				break;
			}
			default:
			{
				g_assert_not_reached ();
			}
		}
	}
	self->priv->stored_delta = delta;
}


static void unity_launcher_scroller_view_do_anim_settle (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	float distance;
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	distance = self->priv->settle_position - self->priv->scroll_position;
	unity_launcher_scroller_view_move_scroll_position (self, distance * 0.2f);
	if (fabs ((double) distance) < 1) {
		self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_NONE;
	}
}


static void unity_launcher_scroller_view_do_anim_fling (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	float scroll_move_amount;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	self->priv->scroll_speed = self->priv->scroll_speed * self->friction;
	scroll_move_amount = self->priv->scroll_speed / 60.0f;
	unity_launcher_scroller_view_move_scroll_position (self, scroll_move_amount);
	if (scroll_move_amount <= (-1.0)) {
		_tmp1_ = (-self->priv->scroll_position) > (self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self));
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp2_ = FALSE;
		if (scroll_move_amount >= 1.0) {
			_tmp2_ = self->priv->scroll_position > 0;
		} else {
			_tmp2_ = FALSE;
		}
		_tmp0_ = _tmp2_;
	}
	if (_tmp0_) {
		self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_BOUNCE;
	}
	if (fabsf (scroll_move_amount) < 1.0) {
		gboolean _tmp4_ = FALSE;
		if (self->priv->scroll_position > 0) {
			_tmp4_ = TRUE;
		} else {
			_tmp4_ = (-self->priv->scroll_position) > (self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self));
		}
		_tmp3_ = _tmp4_;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		self->priv->settle_position = unity_launcher_scroller_view_get_aligned_settle_position (self);
		self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING;
	} else {
		if (fabsf (scroll_move_amount) < 1.0) {
			self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_NONE;
		}
	}
}


static void unity_launcher_scroller_view_do_anim_bounce (UnityLauncherScrollerView* self, ClutterTimeline* timeline, gint msecs) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (timeline != NULL);
	self->priv->scroll_speed = self->priv->scroll_speed * 0.5f;
	unity_launcher_scroller_view_move_scroll_position (self, self->priv->scroll_speed / 60.0f);
	self->priv->settle_position = -unity_launcher_scroller_view_get_aligned_settle_position (self);
	self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_SETTLING;
}


static float unity_launcher_scroller_view_get_aligned_settle_position (UnityLauncherScrollerView* self) {
	float result = 0.0F;
	float final_position;
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	g_return_val_if_fail (self != NULL, 0.0F);
	final_position = self->priv->scroll_position;
	if (self->priv->total_child_height < ((clutter_actor_get_height ((ClutterActor*) self) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.top)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom))) {
		final_position = (float) 0;
	} else {
		if (self->priv->scroll_position > 0) {
			final_position = (float) 0;
		} else {
			CtkPadding _tmp2_ = {0};
			CtkPadding _tmp3_ = {0};
			if ((-self->priv->scroll_position) > (((self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.top)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.bottom))) {
				CtkPadding _tmp4_ = {0};
				final_position = (self->priv->total_child_height - clutter_actor_get_height ((ClutterActor*) self)) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp4_), _tmp4_.bottom);
			}
		}
	}
	result = final_position;
	return result;
}


static void unity_launcher_scroller_view_real_get_preferred_width (ClutterActor* base, float for_height, float* minimum_width, float* natural_width) {
	UnityLauncherScrollerView * self;
	float pmin_width;
	float pnat_width;
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	CtkPadding _tmp2_ = {0};
	CtkPadding _tmp3_ = {0};
	self = (UnityLauncherScrollerView*) base;
	*minimum_width = (float) 0;
	*natural_width = (float) 0;
	pmin_width = 0.0f;
	pnat_width = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			float cmin_width;
			float cnat_width;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			cmin_width = 0.0f;
			cnat_width = 0.0f;
			clutter_actor_get_preferred_width ((ClutterActor*) child, for_height, &cmin_width, &cnat_width);
			pmin_width = MAX (pmin_width, cmin_width);
			pnat_width = MAX (pnat_width, cnat_width);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	pmin_width = pmin_width + ((ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.left) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.right));
	pnat_width = pnat_width + ((ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.left) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.right));
	*minimum_width = pmin_width;
	*natural_width = pnat_width;
}


static void unity_launcher_scroller_view_real_get_preferred_height (ClutterActor* base, float for_width, float* minimum_height, float* natural_height) {
	UnityLauncherScrollerView * self;
	float cnat_height;
	float cmin_height;
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	CtkPadding _tmp2_ = {0};
	CtkPadding _tmp3_ = {0};
	self = (UnityLauncherScrollerView*) base;
	*minimum_height = 0.0f;
	*natural_height = 0.0f;
	cnat_height = 0.0f;
	cmin_height = 0.0f;
	self->priv->total_child_height = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			cnat_height = 0.0f;
			cmin_height = 0.0f;
			clutter_actor_get_preferred_height ((ClutterActor*) child, for_width, &cmin_height, &cnat_height);
			self->priv->total_child_height = self->priv->total_child_height + (cnat_height + self->spacing);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	*minimum_height = (self->priv->total_child_height + (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.top)) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom);
	*natural_height = (self->priv->total_child_height + (ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.top)) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.bottom);
	return;
}


static void unity_launcher_scroller_view_order_children (UnityLauncherScrollerView* self, gboolean immediate) {
	GeeArrayList* transitions;
	g_return_if_fail (self != NULL);
	transitions = NULL;
	if (unity_launcher_scroller_view_get_total_children_height (self) < unity_launcher_scroller_view_get_available_height (self)) {
		GeeArrayList* _tmp0_;
		transitions = (_tmp0_ = unity_launcher_scroller_view_order_children_expanded (self), _g_object_unref0 (transitions), _tmp0_);
	} else {
		switch (self->priv->view_type) {
			case UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED:
			{
				GeeArrayList* _tmp1_;
				transitions = (_tmp1_ = unity_launcher_scroller_view_order_children_contracted (self), _g_object_unref0 (transitions), _tmp1_);
				break;
			}
			case UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_EXPANDED:
			{
				GeeArrayList* _tmp2_;
				transitions = (_tmp2_ = unity_launcher_scroller_view_order_children_expanded (self), _g_object_unref0 (transitions), _tmp2_);
				break;
			}
			default:
			{
				g_assert_not_reached ();
			}
		}
	}
	{
		gint index;
		index = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				if (!_tmp3_) {
					index++;
				}
				_tmp3_ = FALSE;
				if (!(index < unity_launcher_scroller_model_get_size (self->priv->_model))) {
					break;
				}
				child = unity_launcher_scroller_model_get (self->priv->_model, index);
				if (immediate) {
					UnityLauncherChildTransition* _tmp4_;
					UnityLauncherChildTransition* _tmp5_;
					unity_launcher_scroller_child_set_position (child, (_tmp4_ = (UnityLauncherChildTransition*) gee_abstract_list_get ((GeeAbstractList*) transitions, index))->position);
					_unity_launcher_child_transition_unref0 (_tmp4_);
					unity_launcher_scroller_child_force_rotation_jump (child, (_tmp5_ = (UnityLauncherChildTransition*) gee_abstract_list_get ((GeeAbstractList*) transitions, index))->rotation);
					_unity_launcher_child_transition_unref0 (_tmp5_);
				} else {
					gboolean do_new_position;
					UnityLauncherChildTransition* _tmp9_;
					do_new_position = TRUE;
					if (CLUTTER_IS_ANIMATION (clutter_actor_get_animation ((ClutterActor*) child))) {
						GValue _tmp6_ = {0};
						GValue value;
						ClutterInterval* interval;
						UnityLauncherChildTransition* _tmp7_;
						gboolean _tmp8_;
						value = (g_value_init (&_tmp6_, G_TYPE_GTYPE), g_value_set_gtype (&_tmp6_, G_TYPE_FLOAT), _tmp6_);
						interval = _g_object_ref0 (clutter_animation_get_interval (clutter_actor_get_animation ((ClutterActor*) child), "position"));
						clutter_interval_get_final_value (interval, &value);
						if ((_tmp8_ = g_value_get_float (&value) != (_tmp7_ = (UnityLauncherChildTransition*) gee_abstract_list_get ((GeeAbstractList*) transitions, index))->position, _unity_launcher_child_transition_unref0 (_tmp7_), _tmp8_)) {
							float current_pos;
							current_pos = unity_launcher_scroller_child_get_position (child);
							clutter_animation_completed (clutter_actor_get_animation ((ClutterActor*) child));
							unity_launcher_scroller_child_set_position (child, current_pos);
						} else {
							do_new_position = FALSE;
						}
						G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
						_g_object_unref0 (interval);
					}
					unity_launcher_scroller_child_set_rotation (child, (_tmp9_ = (UnityLauncherChildTransition*) gee_abstract_list_get ((GeeAbstractList*) transitions, index))->rotation);
					_unity_launcher_child_transition_unref0 (_tmp9_);
					if (do_new_position) {
						UnityLauncherChildTransition* _tmp10_;
						clutter_actor_animate ((ClutterActor*) child, (gulong) CLUTTER_EASE_IN_OUT_QUAD, (guint) 300, "position", (_tmp10_ = (UnityLauncherChildTransition*) gee_abstract_list_get ((GeeAbstractList*) transitions, index))->position, NULL);
						_unity_launcher_child_transition_unref0 (_tmp10_);
					}
				}
				_g_object_unref0 (child);
			}
		}
	}
	_g_object_unref0 (transitions);
}


static GeeArrayList* unity_launcher_scroller_view_order_children_expanded (UnityLauncherScrollerView* self) {
	GeeArrayList* result = NULL;
	GeeArrayList* ret_transitions;
	float h;
	float min_height = 0.0F;
	float nat_height = 0.0F;
	GeeArrayList* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	ret_transitions = gee_array_list_new (UNITY_LAUNCHER_TYPE_CHILD_TRANSITION, (GBoxedCopyFunc) unity_launcher_child_transition_ref, unity_launcher_child_transition_unref, NULL);
	h = 0.0f;
	if (!GEE_IS_ARRAY_LIST (self->priv->draw_ftb)) {
		GeeArrayList* _tmp0_;
		self->priv->draw_ftb = (_tmp0_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->draw_ftb), _tmp0_);
	}
	self->priv->draw_btf = (_tmp1_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->draw_btf), _tmp1_);
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			UnityLauncherChildTransition* transition;
			gboolean _tmp2_ = FALSE;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_get_preferred_height ((ClutterActor*) child, clutter_actor_get_width ((ClutterActor*) self), &min_height, &nat_height);
			transition = unity_launcher_child_transition_new ();
			transition->position = h + self->priv->scroll_position;
			transition->rotation = 0.0f;
			gee_abstract_collection_add ((GeeAbstractCollection*) ret_transitions, transition);
			if (gee_abstract_collection_contains ((GeeAbstractCollection*) self->priv->draw_ftb, child)) {
				_tmp2_ = TRUE;
			} else {
				_tmp2_ = gee_abstract_collection_contains ((GeeAbstractCollection*) self->priv->draw_ftb, child);
			}
			if (!_tmp2_) {
				gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->draw_ftb, child);
			}
			h = h + (nat_height + self->spacing);
			_g_object_unref0 (child);
			_unity_launcher_child_transition_unref0 (transition);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	result = ret_transitions;
	return result;
}


static GeeArrayList* unity_launcher_scroller_view_order_children_contracted (UnityLauncherScrollerView* self) {
	GeeArrayList* result = NULL;
	GeeArrayList* ret_transitions;
	float h;
	float min_height = 0.0F;
	float nat_height = 0.0F;
	gint num_launchers;
	float total_child_height;
	gint num_children_handled;
	gint index_start_flat = 0;
	gint index_end_flat;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	ret_transitions = gee_array_list_new (UNITY_LAUNCHER_TYPE_CHILD_TRANSITION, (GBoxedCopyFunc) unity_launcher_child_transition_ref, unity_launcher_child_transition_unref, NULL);
	h = 0.0f;
	num_launchers = 0;
	total_child_height = unity_launcher_scroller_view_get_total_children_height (self);
	if (total_child_height > unity_launcher_scroller_view_get_available_height (self)) {
		num_launchers = (gint) floorf ((unity_launcher_scroller_view_get_available_height (self) - (self->spacing * 2)) / (48.0f + self->spacing));
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				float flat_space;
				float contracted_space;
				if (!_tmp0_) {
					num_launchers--;
				}
				_tmp0_ = FALSE;
				if (!(num_launchers >= 1)) {
					break;
				}
				flat_space = num_launchers * (48.0f + self->spacing);
				contracted_space = 0.0f;
				contracted_space = (float) ((unity_launcher_scroller_model_get_size (self->priv->_model) - num_launchers) * (8 + self->spacing));
				if (((flat_space + self->spacing) + contracted_space) < (unity_launcher_scroller_view_get_available_height (self) - (self->spacing * 2))) {
					break;
				}
			}
		}
		num_launchers = MAX (num_launchers, 1);
	} else {
		num_launchers = unity_launcher_scroller_model_get_size (self->priv->_model);
	}
	num_children_handled = 0;
	index_end_flat = 0;
	if (self->priv->focused_launcher < (unity_launcher_scroller_model_get_size (self->priv->_model) - (num_launchers - (num_launchers / 2)))) {
		index_start_flat = MAX (0, self->priv->focused_launcher - (num_launchers / 2));
		index_end_flat = index_start_flat + num_launchers;
	} else {
		index_end_flat = unity_launcher_scroller_model_get_size (self->priv->_model);
		index_start_flat = index_end_flat - num_launchers;
	}
	self->priv->draw_ftb = (_tmp1_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->draw_ftb), _tmp1_);
	self->priv->draw_btf = (_tmp2_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->draw_btf), _tmp2_);
	{
		gint index;
		index = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				UnityLauncherChildTransition* transition;
				gboolean _tmp4_ = FALSE;
				if (!_tmp3_) {
					index++;
				}
				_tmp3_ = FALSE;
				if (!(index < unity_launcher_scroller_model_get_size (self->priv->_model))) {
					break;
				}
				child = unity_launcher_scroller_model_get (self->priv->_model, index);
				transition = unity_launcher_child_transition_new ();
				if (index >= index_start_flat) {
					_tmp4_ = index < index_end_flat;
				} else {
					_tmp4_ = FALSE;
				}
				if (_tmp4_) {
					clutter_actor_get_preferred_height ((ClutterActor*) child, clutter_actor_get_width ((ClutterActor*) self), &min_height, &nat_height);
					transition->position = h;
					h = h + (nat_height + self->spacing);
					num_children_handled++;
					transition->rotation = 0.0f;
					if (index == index_start_flat) {
						gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->draw_ftb, child);
					} else {
						gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->draw_btf, child);
					}
				} else {
					if (index == index_end_flat) {
						h = h - ((float) (self->spacing * 2));
					}
					transition->position = h;
					h = h + ((float) (8 + self->spacing));
					if (num_children_handled < index_start_flat) {
						transition->rotation = -self->priv->contract_icon_degrees;
						gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->draw_ftb, child);
					} else {
						transition->rotation = self->priv->contract_icon_degrees;
						gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->draw_btf, child);
					}
					num_children_handled++;
					if ((index + 1) == index_start_flat) {
						h = h + ((float) 30);
					}
				}
				gee_abstract_collection_add ((GeeAbstractCollection*) ret_transitions, transition);
				_g_object_unref0 (child);
				_unity_launcher_child_transition_unref0 (transition);
			}
		}
	}
	result = ret_transitions;
	return result;
}


static float unity_launcher_scroller_view_get_total_children_height (UnityLauncherScrollerView* self) {
	float result = 0.0F;
	float h;
	float min_height = 0.0F;
	float nat_height = 0.0F;
	g_return_val_if_fail (self != NULL, 0.0F);
	h = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_get_preferred_height ((ClutterActor*) child, clutter_actor_get_width ((ClutterActor*) self), &min_height, &nat_height);
			h = h + (nat_height + self->spacing);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	result = h;
	return result;
}


static float unity_launcher_scroller_view_get_available_height (UnityLauncherScrollerView* self) {
	float result = 0.0F;
	ClutterActorBox box = {0};
	CtkPadding _tmp0_ = {0};
	CtkPadding _tmp1_ = {0};
	g_return_val_if_fail (self != NULL, 0.0F);
	ctk_actor_get_stored_allocation ((CtkActor*) self, &box);
	result = (clutter_actor_box_get_height (&box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.top)) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom);
	return result;
}


static void unity_launcher_scroller_view_real_allocate (ClutterActor* base, const ClutterActorBox* box, ClutterAllocationFlags flags) {
	UnityLauncherScrollerView * self;
	ClutterActorBox child_box = {0};
	CtkPadding _tmp0_ = {0};
	float current_width;
	CtkPadding _tmp1_ = {0};
	float available_height;
	CtkPadding _tmp2_ = {0};
	float available_width;
	gint bg_height = 0;
	gint bg_width = 0;
	float bg_offset;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->allocate ((ClutterActor*) CTK_ACTOR (self), box, flags);
	memset (&child_box, 0, sizeof (ClutterActorBox));
	current_width = (ctk_actor_get_padding ((CtkActor*) self, &_tmp0_), _tmp0_.left);
	available_height = clutter_actor_box_get_height (box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_.bottom);
	available_width = clutter_actor_box_get_width (box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp2_), _tmp2_.right);
	self->priv->total_child_height = 0.0f;
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			float child_height = 0.0F;
			float child_width = 0.0F;
			float natural = 0.0F;
			float min = 0.0F;
			CtkPadding _tmp3_ = {0};
			CtkPadding _tmp4_ = {0};
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_get_preferred_width ((ClutterActor*) child, available_height, &min, &natural);
			child_width = fmaxf (min, fminf (natural, available_width));
			clutter_actor_get_preferred_height ((ClutterActor*) child, child_width, &min, &natural);
			child_height = fmaxf (min, fminf (natural, available_height));
			child_box.x1 = current_width;
			child_box.x2 = clutter_actor_box_get_width (box) - (ctk_actor_get_padding ((CtkActor*) self, &_tmp3_), _tmp3_.right);
			child_box.y1 = unity_launcher_scroller_child_get_position (child) + (ctk_actor_get_padding ((CtkActor*) self, &_tmp4_), _tmp4_.top);
			child_box.y2 = child_box.y1 + child_height;
			clutter_actor_allocate ((ClutterActor*) child, &child_box, flags);
			clutter_actor_remove_clip ((ClutterActor*) child);
			if (child_box.y1 < 0) {
				clutter_actor_set_clip ((ClutterActor*) child, (float) 0, fabsf (child_box.y1), clutter_actor_box_get_width (&child_box), clutter_actor_box_get_height (&child_box) - child_box.y1);
			}
			self->priv->total_child_height = self->priv->total_child_height + (child_height + self->spacing);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
	child_box.x1 = (float) 0;
	child_box.x2 = clutter_actor_box_get_width (box);
	clutter_texture_get_base_size ((ClutterTexture*) self->priv->bgtex, &bg_width, &bg_height);
	bg_offset = fmodf (self->priv->scroll_position + 1000000, (float) bg_height);
	child_box.y1 = bg_offset - (bg_height - 1);
	child_box.y2 = (bg_offset + (bg_height - 1)) + clutter_actor_box_get_height (box);
	clutter_actor_allocate ((ClutterActor*) self->priv->bgtex, &child_box, flags);
	clutter_texture_get_base_size ((ClutterTexture*) self->priv->top_shadow, &bg_width, &bg_height);
	child_box.y1 = (float) (-1);
	child_box.y2 = (float) (bg_height - 1);
	clutter_actor_allocate ((ClutterActor*) self->priv->top_shadow, &child_box, flags);
}


static void unity_launcher_scroller_view_real_pick (ClutterActor* base, const ClutterColor* color) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->pick ((ClutterActor*) CTK_ACTOR (self), color);
	{
		gint index;
		index = gee_collection_get_size ((GeeCollection*) self->priv->draw_btf) - 1;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				gboolean _tmp1_ = FALSE;
				if (!_tmp0_) {
					index--;
				}
				_tmp0_ = FALSE;
				if (!(index >= 0)) {
					break;
				}
				child = (UnityLauncherScrollerChild*) gee_abstract_list_get ((GeeAbstractList*) self->priv->draw_btf, index);
				if (UNITY_LAUNCHER_IS_LAUNCHER_CHILD (child)) {
					_tmp1_ = clutter_actor_get_opacity ((ClutterActor*) child) > 0;
				} else {
					_tmp1_ = FALSE;
				}
				if (_tmp1_) {
					UnityLauncherScrollerChild* _tmp2_;
					clutter_actor_paint ((ClutterActor*) (_tmp2_ = child, UNITY_LAUNCHER_IS_LAUNCHER_CHILD (_tmp2_) ? ((UnityLauncherLauncherChild*) _tmp2_) : NULL));
				}
				_g_object_unref0 (child);
			}
		}
	}
	{
		GeeIterator* _child_it;
		_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->draw_ftb);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			gboolean _tmp3_ = FALSE;
			if (!gee_iterator_next (_child_it)) {
				break;
			}
			child = (UnityLauncherScrollerChild*) gee_iterator_get (_child_it);
			if (UNITY_LAUNCHER_IS_LAUNCHER_CHILD (child)) {
				_tmp3_ = clutter_actor_get_opacity ((ClutterActor*) child) > 0;
			} else {
				_tmp3_ = FALSE;
			}
			if (_tmp3_) {
				UnityLauncherScrollerChild* _tmp4_;
				clutter_actor_paint ((ClutterActor*) (_tmp4_ = child, UNITY_LAUNCHER_IS_LAUNCHER_CHILD (_tmp4_) ? ((UnityLauncherLauncherChild*) _tmp4_) : NULL));
			}
			_g_object_unref0 (child);
		}
		_g_object_unref0 (_child_it);
	}
	{
		GeeIterator* _child_it;
		_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->child_refs);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!gee_iterator_next (_child_it)) {
				break;
			}
			child = (UnityLauncherScrollerChild*) gee_iterator_get (_child_it);
			clutter_actor_paint ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_g_object_unref0 (_child_it);
	}
}


static void unity_launcher_scroller_view_real_paint (ClutterActor* base) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	clutter_actor_paint ((ClutterActor*) self->priv->bgtex);
	{
		gint index;
		index = gee_collection_get_size ((GeeCollection*) self->priv->draw_btf) - 1;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				gboolean _tmp1_ = FALSE;
				if (!_tmp0_) {
					index--;
				}
				_tmp0_ = FALSE;
				if (!(index >= 0)) {
					break;
				}
				child = (UnityLauncherScrollerChild*) gee_abstract_list_get ((GeeAbstractList*) self->priv->draw_btf, index);
				if (UNITY_LAUNCHER_IS_LAUNCHER_CHILD (child)) {
					_tmp1_ = clutter_actor_get_opacity ((ClutterActor*) child) > 0;
				} else {
					_tmp1_ = FALSE;
				}
				if (_tmp1_) {
					UnityLauncherScrollerChild* _tmp2_;
					clutter_actor_paint ((ClutterActor*) (_tmp2_ = child, UNITY_LAUNCHER_IS_LAUNCHER_CHILD (_tmp2_) ? ((UnityLauncherLauncherChild*) _tmp2_) : NULL));
				}
				_g_object_unref0 (child);
			}
		}
	}
	{
		GeeIterator* _child_it;
		_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->draw_ftb);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			gboolean _tmp3_ = FALSE;
			if (!gee_iterator_next (_child_it)) {
				break;
			}
			child = (UnityLauncherScrollerChild*) gee_iterator_get (_child_it);
			if (UNITY_LAUNCHER_IS_LAUNCHER_CHILD (child)) {
				_tmp3_ = clutter_actor_get_opacity ((ClutterActor*) child) > 0;
			} else {
				_tmp3_ = FALSE;
			}
			if (_tmp3_) {
				UnityLauncherScrollerChild* _tmp4_;
				clutter_actor_paint ((ClutterActor*) (_tmp4_ = child, UNITY_LAUNCHER_IS_LAUNCHER_CHILD (_tmp4_) ? ((UnityLauncherLauncherChild*) _tmp4_) : NULL));
			}
			_g_object_unref0 (child);
		}
		_g_object_unref0 (_child_it);
	}
	{
		GeeIterator* _child_it;
		_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->child_refs);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!gee_iterator_next (_child_it)) {
				break;
			}
			child = (UnityLauncherScrollerChild*) gee_iterator_get (_child_it);
			clutter_actor_paint ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_g_object_unref0 (_child_it);
	}
	clutter_actor_paint ((ClutterActor*) self->priv->top_shadow);
}


static void unity_launcher_scroller_view_real_map (ClutterActor* base) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->map ((ClutterActor*) CTK_ACTOR (self));
	clutter_actor_map ((ClutterActor*) self->priv->bgtex);
	clutter_actor_map ((ClutterActor*) self->priv->top_shadow);
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_map ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


static void unity_launcher_scroller_view_real_unmap (ClutterActor* base) {
	UnityLauncherScrollerView * self;
	self = (UnityLauncherScrollerView*) base;
	CLUTTER_ACTOR_CLASS (unity_launcher_scroller_view_parent_class)->unmap ((ClutterActor*) CTK_ACTOR (self));
	clutter_actor_map ((ClutterActor*) self->priv->bgtex);
	clutter_actor_map ((ClutterActor*) self->priv->top_shadow);
	{
		UnityLauncherScrollerModelIterator* _child_it;
		_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
		while (TRUE) {
			UnityLauncherScrollerChild* child;
			if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
				break;
			}
			child = unity_launcher_scroller_model_iterator_get (_child_it);
			clutter_actor_unmap ((ClutterActor*) child);
			_g_object_unref0 (child);
		}
		_unity_launcher_scroller_model_iterator_unref0 (_child_it);
	}
}


UnityLauncherScrollerModel* unity_launcher_scroller_view_get_model (UnityLauncherScrollerView* self) {
	UnityLauncherScrollerModel* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_model;
	return result;
}


static void unity_launcher_scroller_view_set_model (UnityLauncherScrollerView* self, UnityLauncherScrollerModel* value) {
	UnityLauncherScrollerModel* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_model = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_model), _tmp0_);
	g_object_notify ((GObject *) self, "model");
}


static void _unity_launcher_scroller_view_model_child_added_unity_launcher_scroller_model_child_added (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self) {
	unity_launcher_scroller_view_model_child_added (self, child);
}


static void _unity_launcher_scroller_view_model_child_removed_unity_launcher_scroller_model_child_removed (UnityLauncherScrollerModel* _sender, UnityLauncherScrollerChild* child, gpointer self) {
	unity_launcher_scroller_view_model_child_removed (self, child);
}


static void _unity_launcher_scroller_view_model_order_changed_unity_launcher_scroller_model_order_changed (UnityLauncherScrollerModel* _sender, gpointer self) {
	unity_launcher_scroller_view_model_order_changed (self);
}


static gboolean _unity_launcher_scroller_view_on_button_press_event_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_button_press_event (self, event);
	return result;
}


static gboolean _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_enter_event (self, event);
	return result;
}


static gboolean _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = unity_launcher_scroller_view_on_leave_event (self, event);
	return result;
}


static void _unity_launcher_scroller_view_on_scroller_frame_clutter_timeline_new_frame (ClutterTimeline* _sender, gint msecs, gpointer self) {
	unity_launcher_scroller_view_on_scroller_frame (self, _sender, msecs);
}


static void _lambda34_ (UnityLauncherScrollerView* self) {
	self->priv->is_scrolling = FALSE;
	self->priv->button_down = FALSE;
}


static void __lambda34__unity_drag_controller_drag_start (UnityDragController* _sender, UnityDragModel* model, gpointer self) {
	_lambda34_ (self);
}


static gboolean _lambda35_ (UnityLauncherScrollerView* self) {
	gboolean result = FALSE;
	unity_launcher_scroller_view_order_children (self, TRUE);
	clutter_actor_queue_relayout ((ClutterActor*) self);
}


static gboolean __lambda35__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda35_ (self);
	return result;
}


static GObject * unity_launcher_scroller_view_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityLauncherScrollerView * self;
	parent_class = G_OBJECT_CLASS (unity_launcher_scroller_view_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_LAUNCHER_SCROLLER_VIEW (obj);
	{
		UnityTestingObjectRegistry* _tmp0_;
		CtkPadding _tmp1_ = {0};
		CtkPadding mypadding;
		ClutterTimeline* _tmp2_;
		UnityDragController* drag_controller;
		GeeArrayList* _tmp3_;
		unity_testing_object_registry_register (_tmp0_ = unity_testing_object_registry_get_default (), "LauncherScrollerView", (GObject*) self);
		_unity_testing_object_registry_unref0 (_tmp0_);
		mypadding = (ctk_actor_get_padding ((CtkActor*) self, &_tmp1_), _tmp1_);
		mypadding.left = 0.0f;
		mypadding.right = 0.0f;
		mypadding.top = 10.0f;
		mypadding.bottom = 5.0f;
		ctk_actor_set_padding ((CtkActor*) self, &mypadding);
		unity_launcher_scroller_view_load_textures (self);
		g_signal_connect_object (self->priv->_model, "child-added", (GCallback) _unity_launcher_scroller_view_model_child_added_unity_launcher_scroller_model_child_added, self, 0);
		g_signal_connect_object (self->priv->_model, "child-removed", (GCallback) _unity_launcher_scroller_view_model_child_removed_unity_launcher_scroller_model_child_removed, self, 0);
		g_signal_connect_object (self->priv->_model, "order-changed", (GCallback) _unity_launcher_scroller_view_model_order_changed_unity_launcher_scroller_model_order_changed, self, 0);
		{
			UnityLauncherScrollerModelIterator* _child_it;
			_child_it = unity_launcher_scroller_model_iterator (self->priv->_model);
			while (TRUE) {
				UnityLauncherScrollerChild* child;
				if (!unity_launcher_scroller_model_iterator_next (_child_it)) {
					break;
				}
				child = unity_launcher_scroller_model_iterator_get (_child_it);
				unity_launcher_scroller_view_model_child_added (self, child);
				_g_object_unref0 (child);
			}
			_unity_launcher_scroller_model_iterator_unref0 (_child_it);
		}
		g_signal_connect_object ((ClutterActor*) self, "button-press-event", (GCallback) _unity_launcher_scroller_view_on_button_press_event_clutter_actor_button_press_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "button-release-event", (GCallback) _unity_launcher_scroller_view_on_button_release_event_clutter_actor_button_release_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "motion-event", (GCallback) _unity_launcher_scroller_view_on_motion_event_clutter_actor_motion_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "enter-event", (GCallback) _unity_launcher_scroller_view_on_enter_event_clutter_actor_enter_event, self, 0);
		g_signal_connect_object ((ClutterActor*) self, "leave-event", (GCallback) _unity_launcher_scroller_view_on_leave_event_clutter_actor_leave_event, self, 0);
		self->priv->fling_timeline = (_tmp2_ = clutter_timeline_new ((guint) 1000), _g_object_unref0 (self->priv->fling_timeline), _tmp2_);
		clutter_timeline_set_loop (self->priv->fling_timeline, TRUE);
		g_signal_connect_object (self->priv->fling_timeline, "new-frame", (GCallback) _unity_launcher_scroller_view_on_scroller_frame_clutter_timeline_new_frame, self, 0);
		drag_controller = _g_object_ref0 (unity_drag_controller_get_default ());
		g_signal_connect_object (drag_controller, "drag-start", (GCallback) __lambda34__unity_drag_controller_drag_start, self, 0);
		clutter_actor_set_reactive ((ClutterActor*) self, TRUE);
		self->priv->child_refs = (_tmp3_ = gee_array_list_new (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->child_refs), _tmp3_);
		unity_launcher_scroller_view_order_children (self, TRUE);
		clutter_actor_queue_relayout ((ClutterActor*) self);
		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, __lambda35__gsource_func, g_object_ref (self), g_object_unref);
		_g_object_unref0 (drag_controller);
	}
	return obj;
}


static void unity_launcher_scroller_view_class_init (UnityLauncherScrollerViewClass * klass) {
	unity_launcher_scroller_view_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityLauncherScrollerViewPrivate));
	CLUTTER_ACTOR_CLASS (klass)->get_preferred_width = unity_launcher_scroller_view_real_get_preferred_width;
	CLUTTER_ACTOR_CLASS (klass)->get_preferred_height = unity_launcher_scroller_view_real_get_preferred_height;
	CLUTTER_ACTOR_CLASS (klass)->allocate = unity_launcher_scroller_view_real_allocate;
	CLUTTER_ACTOR_CLASS (klass)->pick = unity_launcher_scroller_view_real_pick;
	CLUTTER_ACTOR_CLASS (klass)->paint = unity_launcher_scroller_view_real_paint;
	CLUTTER_ACTOR_CLASS (klass)->map = unity_launcher_scroller_view_real_map;
	CLUTTER_ACTOR_CLASS (klass)->unmap = unity_launcher_scroller_view_real_unmap;
	G_OBJECT_CLASS (klass)->get_property = unity_launcher_scroller_view_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_launcher_scroller_view_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_launcher_scroller_view_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_launcher_scroller_view_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_LAUNCHER_SCROLLER_VIEW_MODEL, g_param_spec_object ("model", "model", "model", UNITY_LAUNCHER_TYPE_SCROLLER_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void unity_launcher_scroller_view_instance_init (UnityLauncherScrollerView * self) {
	self->priv = UNITY_LAUNCHER_SCROLLER_VIEW_GET_PRIVATE (self);
	self->spacing = 6;
	self->drag_sensitivity = 7;
	self->friction = 0.9f;
	self->is_animating = FALSE;
	self->priv->button_down = FALSE;
	self->priv->total_child_height = 0.0f;
	self->priv->current_phase = UNITY_LAUNCHER_SCROLLER_PHASE_NONE;
	self->priv->last_motion_event_time = (guint) 0;
	self->priv->view_type = UNITY_LAUNCHER_SCROLLER_VIEW_TYPE_CONTRACTED;
	self->priv->is_scrolling = FALSE;
	self->priv->scroll_position = 0.0f;
	self->priv->settle_position = 0.0f;
	self->priv->previous_y_position = 0.0f;
	self->priv->previous_y_time = (guint) 0;
	self->priv->stored_delta = (guint) 0;
	self->priv->scroll_speed = 0.0f;
	self->priv->contract_icon_degrees = 30.0f;
	self->priv->focused_launcher = 0;
}


static void unity_launcher_scroller_view_finalize (GObject* obj) {
	UnityLauncherScrollerView * self;
	self = UNITY_LAUNCHER_SCROLLER_VIEW (obj);
	_g_object_unref0 (self->priv->_model);
	_g_object_unref0 (self->priv->bgtex);
	_g_object_unref0 (self->priv->top_shadow);
	_g_object_unref0 (self->priv->fling_timeline);
	_g_object_unref0 (self->priv->draw_ftb);
	_g_object_unref0 (self->priv->draw_btf);
	_g_object_unref0 (self->priv->child_refs);
	G_OBJECT_CLASS (unity_launcher_scroller_view_parent_class)->finalize (obj);
}


GType unity_launcher_scroller_view_get_type (void) {
	static volatile gsize unity_launcher_scroller_view_type_id__volatile = 0;
	if (g_once_init_enter (&unity_launcher_scroller_view_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityLauncherScrollerViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_launcher_scroller_view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityLauncherScrollerView), 0, (GInstanceInitFunc) unity_launcher_scroller_view_instance_init, NULL };
		GType unity_launcher_scroller_view_type_id;
		unity_launcher_scroller_view_type_id = g_type_register_static (CTK_TYPE_ACTOR, "UnityLauncherScrollerView", &g_define_type_info, 0);
		g_once_init_leave (&unity_launcher_scroller_view_type_id__volatile, unity_launcher_scroller_view_type_id);
	}
	return unity_launcher_scroller_view_type_id__volatile;
}


static void unity_launcher_scroller_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityLauncherScrollerView * self;
	self = UNITY_LAUNCHER_SCROLLER_VIEW (object);
	switch (property_id) {
		case UNITY_LAUNCHER_SCROLLER_VIEW_MODEL:
		g_value_set_object (value, unity_launcher_scroller_view_get_model (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_launcher_scroller_view_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityLauncherScrollerView * self;
	self = UNITY_LAUNCHER_SCROLLER_VIEW (object);
	switch (property_id) {
		case UNITY_LAUNCHER_SCROLLER_VIEW_MODEL:
		unity_launcher_scroller_view_set_model (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}




