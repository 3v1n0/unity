/* window.c generated by valac, the Vala compiler
 * generated from window.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; c-basic-offset: 2; tab-width: 2 -*- */
/*
 * Copyright (C) 2009 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Gordon Allott <gord.allott@canonical.com>
 *             Neil Jagdish Patel <neil.patel@canonical.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <unity.h>
#include <libwnck/libwnck.h>
#include <clutter-gtk/clutter-gtk.h>
#include <clutter/clutter.h>
#include <clutk/clutk.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>
#include <unity-utils.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define UNITY_TYPE_UNDERLAY_WINDOW (unity_underlay_window_get_type ())
#define UNITY_UNDERLAY_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_UNDERLAY_WINDOW, UnityUnderlayWindow))
#define UNITY_UNDERLAY_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_UNDERLAY_WINDOW, UnityUnderlayWindowClass))
#define UNITY_IS_UNDERLAY_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_UNDERLAY_WINDOW))
#define UNITY_IS_UNDERLAY_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_UNDERLAY_WINDOW))
#define UNITY_UNDERLAY_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_UNDERLAY_WINDOW, UnityUnderlayWindowClass))

typedef struct _UnityUnderlayWindow UnityUnderlayWindow;
typedef struct _UnityUnderlayWindowClass UnityUnderlayWindowClass;
typedef struct _UnityUnderlayWindowPrivate UnityUnderlayWindowPrivate;

#define UNITY_TYPE_WORKAREA (unity_workarea_get_type ())
#define UNITY_WORKAREA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_WORKAREA, UnityWorkarea))
#define UNITY_WORKAREA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_WORKAREA, UnityWorkareaClass))
#define UNITY_IS_WORKAREA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_WORKAREA))
#define UNITY_IS_WORKAREA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_WORKAREA))
#define UNITY_WORKAREA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_WORKAREA, UnityWorkareaClass))

typedef struct _UnityWorkarea UnityWorkarea;
typedef struct _UnityWorkareaClass UnityWorkareaClass;

#define UNITY_TYPE_BACKGROUND (unity_background_get_type ())
#define UNITY_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_BACKGROUND, UnityBackground))
#define UNITY_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_BACKGROUND, UnityBackgroundClass))
#define UNITY_IS_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_BACKGROUND))
#define UNITY_IS_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_BACKGROUND))
#define UNITY_BACKGROUND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_BACKGROUND, UnityBackgroundClass))

typedef struct _UnityBackground UnityBackground;
typedef struct _UnityBackgroundClass UnityBackgroundClass;

#define UNITY_QUICKLAUNCHER_TYPE_VIEW (unity_quicklauncher_view_get_type ())
#define UNITY_QUICKLAUNCHER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_QUICKLAUNCHER_TYPE_VIEW, UnityQuicklauncherView))
#define UNITY_QUICKLAUNCHER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_QUICKLAUNCHER_TYPE_VIEW, UnityQuicklauncherViewClass))
#define UNITY_QUICKLAUNCHER_IS_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_QUICKLAUNCHER_TYPE_VIEW))
#define UNITY_QUICKLAUNCHER_IS_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_QUICKLAUNCHER_TYPE_VIEW))
#define UNITY_QUICKLAUNCHER_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_QUICKLAUNCHER_TYPE_VIEW, UnityQuicklauncherViewClass))

typedef struct _UnityQuicklauncherView UnityQuicklauncherView;
typedef struct _UnityQuicklauncherViewClass UnityQuicklauncherViewClass;

#define UNITY_PANEL_TYPE_VIEW (unity_panel_view_get_type ())
#define UNITY_PANEL_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PANEL_TYPE_VIEW, UnityPanelView))
#define UNITY_PANEL_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PANEL_TYPE_VIEW, UnityPanelViewClass))
#define UNITY_PANEL_IS_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PANEL_TYPE_VIEW))
#define UNITY_PANEL_IS_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PANEL_TYPE_VIEW))
#define UNITY_PANEL_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PANEL_TYPE_VIEW, UnityPanelViewClass))

typedef struct _UnityPanelView UnityPanelView;
typedef struct _UnityPanelViewClass UnityPanelViewClass;

#define UNITY_PLACES_TYPE_CONTROLLER (unity_places_controller_get_type ())
#define UNITY_PLACES_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACES_TYPE_CONTROLLER, UnityPlacesController))
#define UNITY_PLACES_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACES_TYPE_CONTROLLER, UnityPlacesControllerClass))
#define UNITY_PLACES_IS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACES_TYPE_CONTROLLER))
#define UNITY_PLACES_IS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACES_TYPE_CONTROLLER))
#define UNITY_PLACES_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACES_TYPE_CONTROLLER, UnityPlacesControllerClass))

typedef struct _UnityPlacesController UnityPlacesController;
typedef struct _UnityPlacesControllerClass UnityPlacesControllerClass;

#define UNITY_PLACES_TYPE_VIEW (unity_places_view_get_type ())
#define UNITY_PLACES_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACES_TYPE_VIEW, UnityPlacesView))
#define UNITY_PLACES_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACES_TYPE_VIEW, UnityPlacesViewClass))
#define UNITY_PLACES_IS_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACES_TYPE_VIEW))
#define UNITY_PLACES_IS_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACES_TYPE_VIEW))
#define UNITY_PLACES_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACES_TYPE_VIEW, UnityPlacesViewClass))

typedef struct _UnityPlacesView UnityPlacesView;
typedef struct _UnityPlacesViewClass UnityPlacesViewClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _unity_workarea_unref0(var) ((var == NULL) ? NULL : (var = (unity_workarea_unref (var), NULL)))
typedef struct _UnityWorkareaPrivate UnityWorkareaPrivate;
typedef struct _UnityParamSpecWorkarea UnityParamSpecWorkarea;

struct _UnityUnderlayWindow {
	GtkWindow parent_instance;
	UnityUnderlayWindowPrivate * priv;
};

struct _UnityUnderlayWindowClass {
	GtkWindowClass parent_class;
};

struct _UnityUnderlayWindowPrivate {
	gboolean _is_popup;
	gint _popup_width;
	gint _popup_height;
	WnckScreen* wnck_screen;
	UnityWorkarea* workarea_size;
	GtkClutterEmbed* gtk_clutter;
	ClutterStage* stage;
	gboolean is_showing;
	UnityBackground* background;
	UnityQuicklauncherView* quicklauncher;
	UnityPanelView* panel;
	UnityPlacesController* controller;
	UnityPlacesView* places;
	gboolean places_enabled;
	gboolean showing_places;
};

struct _UnityWorkarea {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityWorkareaPrivate * priv;
	gint left;
	gint top;
	gint right;
	gint bottom;
};

struct _UnityWorkareaClass {
	GTypeClass parent_class;
	void (*finalize) (UnityWorkarea *self);
};

struct _UnityParamSpecWorkarea {
	GParamSpec parent_instance;
};


static gpointer unity_underlay_window_parent_class = NULL;
static UnityShellIface* unity_underlay_window_unity_shell_parent_iface = NULL;
static gpointer unity_workarea_parent_class = NULL;

GType unity_underlay_window_get_type (void);
gpointer unity_workarea_ref (gpointer instance);
void unity_workarea_unref (gpointer instance);
GParamSpec* unity_param_spec_workarea (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_value_set_workarea (GValue* value, gpointer v_object);
gpointer unity_value_get_workarea (const GValue* value);
GType unity_workarea_get_type (void);
GType unity_background_get_type (void);
GType unity_quicklauncher_view_get_type (void);
GType unity_panel_view_get_type (void);
GType unity_places_controller_get_type (void);
GType unity_places_view_get_type (void);
#define UNITY_UNDERLAY_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_UNDERLAY_WINDOW, UnityUnderlayWindowPrivate))
enum  {
	UNITY_UNDERLAY_WINDOW_DUMMY_PROPERTY,
	UNITY_UNDERLAY_WINDOW_MENUS_SWALLOW_EVENTS,
	UNITY_UNDERLAY_WINDOW_IS_POPUP,
	UNITY_UNDERLAY_WINDOW_POPUP_WIDTH,
	UNITY_UNDERLAY_WINDOW_POPUP_HEIGHT
};
static void unity_underlay_window_real_add_fullscreen_request (UnityShell* base, GObject* o);
static gboolean unity_underlay_window_real_remove_fullscreen_request (UnityShell* base, GObject* o);
static void unity_underlay_window_real_ensure_input_region (UnityShell* base);
UnityUnderlayWindow* unity_underlay_window_new (gboolean popup, gint width, gint height);
UnityUnderlayWindow* unity_underlay_window_construct (GType object_type, gboolean popup, gint width, gint height);
gboolean unity_underlay_window_get_is_popup (UnityUnderlayWindow* self);
gint unity_underlay_window_get_popup_width (UnityUnderlayWindow* self);
gint unity_underlay_window_get_popup_height (UnityUnderlayWindow* self);
void utils_set_strut (GtkWindow* window, guint32 strut_size, guint32 strut_start, guint32 strut_end, guint32 top_size, guint32 top_start, guint32 top_end);
static void unity_underlay_window_relayout (UnityUnderlayWindow* self);
static void unity_underlay_window_real_show (GtkWidget* base);
void unity_underlay_window_on_active_window_changed (UnityUnderlayWindow* self, WnckWindow* previous_window);
gboolean unity_underlay_window_on_stage_button_press (UnityUnderlayWindow* self, ClutterEvent* src);
static void unity_underlay_window_real_show_window_picker (UnityShell* base);
static void unity_underlay_window_real_grab_keyboard (UnityShell* base, gboolean grab, guint32 timestamp);
static ClutterStage* unity_underlay_window_real_get_stage (UnityShell* base);
static UnityShellMode unity_underlay_window_real_get_mode (UnityShell* base);
void unity_panel_view_set_indicator_mode (UnityPanelView* self, gboolean mode);
static void unity_underlay_window_real_show_unity (UnityShell* base);
gint unity_panel_view_get_indicators_width (UnityPanelView* self);
static gint unity_underlay_window_real_get_indicators_width (UnityShell* base);
static void unity_underlay_window_set_is_popup (UnityUnderlayWindow* self, gboolean value);
static void unity_underlay_window_set_popup_width (UnityUnderlayWindow* self, gint value);
static void unity_underlay_window_set_popup_height (UnityUnderlayWindow* self, gint value);
UnityWorkarea* unity_workarea_new (void);
UnityWorkarea* unity_workarea_construct (GType object_type);
void unity_workarea_update_net_workarea (UnityWorkarea* self);
static gboolean _lambda8_ (UnityUnderlayWindow* self);
static gboolean __lambda8__gtk_widget_delete_event (GtkWidget* _sender, GdkEvent* event, gpointer self);
static gboolean _lambda9_ (UnityUnderlayWindow* self);
static gboolean __lambda9__gtk_widget_delete_event (GtkWidget* _sender, GdkEvent* event, gpointer self);
static void _lambda10_ (GdkScreen* s, UnityUnderlayWindow* self);
static void __lambda10__gdk_screen_size_changed (GdkScreen* _sender, gpointer self);
static void _lambda11_ (GdkScreen* s, UnityUnderlayWindow* self);
static void __lambda11__gdk_screen_monitors_changed (GdkScreen* _sender, gpointer self);
static gboolean _unity_underlay_window_on_stage_button_press_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
UnityBackground* unity_background_new (void);
UnityBackground* unity_background_construct (GType object_type);
UnityQuicklauncherView* unity_quicklauncher_view_new (UnityShell* shell);
UnityQuicklauncherView* unity_quicklauncher_view_construct (GType object_type, UnityShell* shell);
UnityPlacesController* unity_places_controller_new (UnityShell* shell);
UnityPlacesController* unity_places_controller_construct (GType object_type, UnityShell* shell);
UnityPlacesView* unity_places_controller_get_view (UnityPlacesController* self);
UnityPanelView* unity_panel_view_new (UnityShell* shell);
UnityPanelView* unity_panel_view_construct (GType object_type, UnityShell* shell);
static void _unity_underlay_window_on_active_window_changed_wnck_screen_active_window_changed (WnckScreen* _sender, WnckWindow* previous_window, gpointer self);
static GObject * unity_underlay_window_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_underlay_window_finalize (GObject* obj);
static void unity_underlay_window_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_underlay_window_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
enum  {
	UNITY_WORKAREA_DUMMY_PROPERTY
};
static void unity_workarea_finalize (UnityWorkarea* obj);
static int _vala_strcmp0 (const char * str1, const char * str2);



#line 46 "window.vala"
static void unity_underlay_window_real_add_fullscreen_request (UnityShell* base, GObject* o) {
#line 248 "window.c"
	UnityUnderlayWindow * self;
	self = (UnityUnderlayWindow*) base;
#line 46 "window.vala"
	g_return_if_fail (o != NULL);
#line 48 "window.vala"
	return;
#line 255 "window.c"
}


#line 51 "window.vala"
static gboolean unity_underlay_window_real_remove_fullscreen_request (UnityShell* base, GObject* o) {
#line 261 "window.c"
	UnityUnderlayWindow * self;
	gboolean result;
	self = (UnityUnderlayWindow*) base;
#line 51 "window.vala"
	g_return_val_if_fail (o != NULL, FALSE);
#line 267 "window.c"
	result = FALSE;
#line 53 "window.vala"
	return result;
#line 271 "window.c"
}


#line 56 "window.vala"
static void unity_underlay_window_real_ensure_input_region (UnityShell* base) {
#line 277 "window.c"
	UnityUnderlayWindow * self;
	self = (UnityUnderlayWindow*) base;
#line 59 "window.vala"
	return;
#line 282 "window.c"
}


#line 64 "window.vala"
UnityUnderlayWindow* unity_underlay_window_construct (GType object_type, gboolean popup, gint width, gint height) {
#line 288 "window.c"
	UnityUnderlayWindow * self;
#line 66 "window.vala"
	self = (UnityUnderlayWindow*) g_object_new (object_type, "is-popup", popup, "popup-width", width, "popup-height", height, NULL);
#line 292 "window.c"
	return self;
}


#line 64 "window.vala"
UnityUnderlayWindow* unity_underlay_window_new (gboolean popup, gint width, gint height) {
#line 64 "window.vala"
	return unity_underlay_window_construct (UNITY_TYPE_UNDERLAY_WINDOW, popup, width, height);
#line 301 "window.c"
}


#line 181 "window.vala"
static void unity_underlay_window_relayout (UnityUnderlayWindow* self) {
#line 307 "window.c"
	gint x = 0;
	gint y = 0;
	gint width = 0;
	gint height = 0;
	float ql_width = 0.0F;
#line 181 "window.vala"
	g_return_if_fail (self != NULL);
#line 185 "window.vala"
	if (self->priv->_is_popup) {
#line 187 "window.vala"
		x = 0;
#line 188 "window.vala"
		y = 0;
#line 189 "window.vala"
		width = self->priv->_popup_width;
#line 190 "window.vala"
		height = self->priv->_popup_height;
#line 325 "window.c"
	} else {
		GdkRectangle size = {0};
#line 196 "window.vala"
		gdk_screen_get_monitor_geometry (gtk_window_get_screen ((GtkWindow*) self), 0, &size);
#line 197 "window.vala"
		x = size.x;
#line 198 "window.vala"
		y = size.y;
#line 199 "window.vala"
		width = size.width;
#line 200 "window.vala"
		height = size.height;
#line 338 "window.c"
	}
#line 203 "window.vala"
	ql_width = (float) 58;
#line 204 "window.vala"
	gtk_window_resize ((GtkWindow*) self, width, height);
#line 205 "window.vala"
	clutter_actor_set_size ((ClutterActor*) self->priv->stage, (float) width, (float) height);
#line 207 "window.vala"
	if (!self->priv->_is_popup) {
#line 208 "window.vala"
		utils_set_strut (GTK_WINDOW (self), (guint32) ((guint) ql_width), (guint32) 0, (guint32) height, (guint32) 24, (guint32) 0, (guint32) width);
#line 350 "window.c"
	}
#line 213 "window.vala"
	clutter_actor_set_position ((ClutterActor*) self->priv->background, (float) 0, (float) 0);
#line 214 "window.vala"
	clutter_actor_set_size ((ClutterActor*) self->priv->background, (float) width, (float) height);
#line 216 "window.vala"
	clutter_actor_set_size ((ClutterActor*) self->priv->quicklauncher, ql_width, (float) (height - 23));
#line 217 "window.vala"
	clutter_actor_set_position ((ClutterActor*) self->priv->quicklauncher, (float) 0, (float) 23);
#line 219 "window.vala"
	if (self->priv->places_enabled) {
#line 221 "window.vala"
		clutter_actor_set_size ((ClutterActor*) self->priv->places, (float) width, (float) height);
#line 222 "window.vala"
		clutter_actor_set_position ((ClutterActor*) self->priv->places, (float) 0, (float) 0);
#line 366 "window.c"
	}
#line 225 "window.vala"
	clutter_actor_set_size ((ClutterActor*) self->priv->panel, (float) width, (float) 23);
#line 226 "window.vala"
	clutter_actor_set_position ((ClutterActor*) self->priv->panel, (float) 0, (float) 0);
#line 372 "window.c"
}


#line 229 "window.vala"
static void unity_underlay_window_real_show (GtkWidget* base) {
#line 378 "window.c"
	UnityUnderlayWindow * self;
	self = (UnityUnderlayWindow*) base;
#line 231 "window.vala"
	GTK_WIDGET_CLASS (unity_underlay_window_parent_class)->show ((GtkWidget*) GTK_WINDOW (self));
#line 232 "window.vala"
	gtk_widget_show ((GtkWidget*) self->priv->gtk_clutter);
#line 233 "window.vala"
	clutter_actor_show_all ((ClutterActor*) self->priv->stage);
#line 387 "window.c"
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


#line 239 "window.vala"
void unity_underlay_window_on_active_window_changed (UnityUnderlayWindow* self, WnckWindow* previous_window) {
#line 398 "window.c"
	WnckWindow* new_window;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
#line 239 "window.vala"
	g_return_if_fail (self != NULL);
#line 241 "window.vala"
	new_window = _g_object_ref0 (wnck_screen_get_active_window (self->priv->wnck_screen));
#line 242 "window.vala"
	if (new_window == NULL) {
#line 408 "window.c"
		_g_object_unref0 (new_window);
#line 243 "window.vala"
		return;
#line 412 "window.c"
	}
#line 246 "window.vala"
	if (WNCK_IS_WINDOW (new_window)) {
#line 247 "window.vala"
		_tmp1_ = G_TYPE_FROM_INSTANCE ((GObject*) new_window) != WNCK_WINDOW_DESKTOP;
#line 418 "window.c"
	} else {
#line 246 "window.vala"
		_tmp1_ = FALSE;
#line 422 "window.c"
	}
#line 246 "window.vala"
	if (_tmp1_) {
#line 248 "window.vala"
		_tmp0_ = _vala_strcmp0 (wnck_window_get_name (new_window), "Unity") == 0;
#line 428 "window.c"
	} else {
#line 246 "window.vala"
		_tmp0_ = FALSE;
#line 432 "window.c"
	}
#line 246 "window.vala"
	if (_tmp0_) {
#line 251 "window.vala"
		self->priv->is_showing = TRUE;
#line 438 "window.c"
	} else {
#line 259 "window.vala"
		self->priv->is_showing = FALSE;
#line 442 "window.c"
	}
	_g_object_unref0 (new_window);
}


#line 263 "window.vala"
gboolean unity_underlay_window_on_stage_button_press (UnityUnderlayWindow* self, ClutterEvent* src) {
#line 450 "window.c"
	gboolean result;
#line 263 "window.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 265 "window.vala"
	if (self->priv->_is_popup) {
#line 456 "window.c"
		result = FALSE;
#line 266 "window.vala"
		return result;
#line 460 "window.c"
	}
#line 268 "window.vala"
	if (self->priv->is_showing) {
#line 464 "window.c"
		;
	} else {
	}
	result = FALSE;
#line 276 "window.vala"
	return result;
#line 471 "window.c"
}


#line 283 "window.vala"
static void unity_underlay_window_real_show_window_picker (UnityShell* base) {
#line 477 "window.c"
	UnityUnderlayWindow * self;
	self = (UnityUnderlayWindow*) base;
#line 285 "window.vala"
	g_debug ("window.vala:285: Window picker not implemented in popup mode");
#line 482 "window.c"
}


#line 288 "window.vala"
static void unity_underlay_window_real_grab_keyboard (UnityShell* base, gboolean grab, guint32 timestamp) {
#line 488 "window.c"
	UnityUnderlayWindow * self;
	self = (UnityUnderlayWindow*) base;
}


#line 293 "window.vala"
static ClutterStage* unity_underlay_window_real_get_stage (UnityShell* base) {
#line 496 "window.c"
	UnityUnderlayWindow * self;
	ClutterStage* result;
	self = (UnityUnderlayWindow*) base;
	result = _g_object_ref0 (self->priv->stage);
#line 295 "window.vala"
	return result;
#line 503 "window.c"
}


#line 298 "window.vala"
static UnityShellMode unity_underlay_window_real_get_mode (UnityShell* base) {
#line 509 "window.c"
	UnityUnderlayWindow * self;
	UnityShellMode result;
	self = (UnityUnderlayWindow*) base;
	result = UNITY_SHELL_MODE_UNDERLAY;
#line 300 "window.vala"
	return result;
#line 516 "window.c"
}


#line 303 "window.vala"
static void unity_underlay_window_real_show_unity (UnityShell* base) {
#line 522 "window.c"
	UnityUnderlayWindow * self;
	self = (UnityUnderlayWindow*) base;
#line 305 "window.vala"
	if (self->priv->places_enabled != TRUE) {
#line 527 "window.c"
		WnckScreen* screen;
#line 307 "window.vala"
		screen = _g_object_ref0 (wnck_screen_get_default ());
#line 309 "window.vala"
		wnck_screen_toggle_showing_desktop (screen, !wnck_screen_get_showing_desktop (screen));
#line 533 "window.c"
		_g_object_unref0 (screen);
#line 310 "window.vala"
		return;
#line 537 "window.c"
	}
#line 313 "window.vala"
	if (self->priv->showing_places) {
#line 315 "window.vala"
		self->priv->showing_places = FALSE;
#line 316 "window.vala"
		unity_panel_view_set_indicator_mode (self->priv->panel, TRUE);
#line 317 "window.vala"
		clutter_actor_set_opacity ((ClutterActor*) self->priv->places, (guint8) 255);
#line 547 "window.c"
	} else {
#line 321 "window.vala"
		self->priv->showing_places = TRUE;
#line 322 "window.vala"
		unity_panel_view_set_indicator_mode (self->priv->panel, FALSE);
#line 323 "window.vala"
		clutter_actor_set_opacity ((ClutterActor*) self->priv->places, (guint8) 0);
#line 555 "window.c"
	}
#line 326 "window.vala"
	clutter_actor_queue_redraw ((ClutterActor*) self->priv->places);
#line 559 "window.c"
}


#line 329 "window.vala"
static gint unity_underlay_window_real_get_indicators_width (UnityShell* base) {
#line 565 "window.c"
	UnityUnderlayWindow * self;
	gint result;
	self = (UnityUnderlayWindow*) base;
	result = unity_panel_view_get_indicators_width (self->priv->panel);
#line 331 "window.vala"
	return result;
#line 572 "window.c"
}


static gboolean unity_underlay_window_real_get_menus_swallow_events (UnityShell* base) {
	gboolean result;
	UnityUnderlayWindow* self;
	self = (UnityUnderlayWindow*) base;
	result = TRUE;
#line 26 "window.vala"
	return result;
#line 583 "window.c"
}


gboolean unity_underlay_window_get_is_popup (UnityUnderlayWindow* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_popup;
#line 27 "window.vala"
	return result;
#line 593 "window.c"
}


static void unity_underlay_window_set_is_popup (UnityUnderlayWindow* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_is_popup = value;
	g_object_notify ((GObject *) self, "is-popup");
}


gint unity_underlay_window_get_popup_width (UnityUnderlayWindow* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_popup_width;
#line 28 "window.vala"
	return result;
#line 610 "window.c"
}


static void unity_underlay_window_set_popup_width (UnityUnderlayWindow* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_popup_width = value;
	g_object_notify ((GObject *) self, "popup-width");
}


gint unity_underlay_window_get_popup_height (UnityUnderlayWindow* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_popup_height;
#line 29 "window.vala"
	return result;
#line 627 "window.c"
}


static void unity_underlay_window_set_popup_height (UnityUnderlayWindow* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_popup_height = value;
	g_object_notify ((GObject *) self, "popup-height");
}


#line 82 "window.vala"
static gboolean _lambda8_ (UnityUnderlayWindow* self) {
#line 640 "window.c"
	gboolean result;
#line 84 "window.vala"
	gtk_main_quit ();
#line 644 "window.c"
	result = FALSE;
#line 85 "window.vala"
	return result;
#line 648 "window.c"
}


#line 82 "window.vala"
static gboolean __lambda8__gtk_widget_delete_event (GtkWidget* _sender, GdkEvent* event, gpointer self) {
#line 654 "window.c"
	return _lambda8_ (self);
}


#line 98 "window.vala"
static gboolean _lambda9_ (UnityUnderlayWindow* self) {
#line 661 "window.c"
	gboolean result;
	result = TRUE;
#line 98 "window.vala"
	return result;
#line 666 "window.c"
}


#line 98 "window.vala"
static gboolean __lambda9__gtk_widget_delete_event (GtkWidget* _sender, GdkEvent* event, gpointer self) {
#line 672 "window.c"
	return _lambda9_ (self);
}


#line 99 "window.vala"
static void _lambda10_ (GdkScreen* s, UnityUnderlayWindow* self) {
#line 99 "window.vala"
	g_return_if_fail (s != NULL);
#line 100 "window.vala"
	unity_underlay_window_relayout (self);
#line 683 "window.c"
}


#line 99 "window.vala"
static void __lambda10__gdk_screen_size_changed (GdkScreen* _sender, gpointer self) {
#line 689 "window.c"
	_lambda10_ (_sender, self);
}


#line 101 "window.vala"
static void _lambda11_ (GdkScreen* s, UnityUnderlayWindow* self) {
#line 101 "window.vala"
	g_return_if_fail (s != NULL);
#line 102 "window.vala"
	unity_underlay_window_relayout (self);
#line 700 "window.c"
}


#line 101 "window.vala"
static void __lambda11__gdk_screen_monitors_changed (GdkScreen* _sender, gpointer self) {
#line 706 "window.c"
	_lambda11_ (_sender, self);
}


#line 263 "window.vala"
static gboolean _unity_underlay_window_on_stage_button_press_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
#line 713 "window.c"
	return unity_underlay_window_on_stage_button_press (self, event);
}


#line 239 "window.vala"
static void _unity_underlay_window_on_active_window_changed_wnck_screen_active_window_changed (WnckScreen* _sender, WnckWindow* previous_window, gpointer self) {
#line 720 "window.c"
	unity_underlay_window_on_active_window_changed (self, previous_window);
}


static GObject * unity_underlay_window_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityUnderlayWindow * self;
	parent_class = G_OBJECT_CLASS (unity_underlay_window_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_UNDERLAY_WINDOW (obj);
	{
		UnityShell* _tmp0_;
		UnityWorkarea* _tmp1_;
		GtkClutterEmbed* _tmp2_;
		GtkTargetEntry* _tmp10_;
		gint target_list_size;
		gint target_list_length1;
		GtkTargetEntry* _tmp9_ = NULL;
		GtkTargetEntry _tmp3_ = {0};
		GtkTargetEntry _tmp4_ = {0};
		GtkTargetEntry _tmp5_ = {0};
		GtkTargetEntry _tmp6_ = {0};
		GtkTargetEntry _tmp7_ = {0};
		GtkTargetEntry _tmp8_ = {0};
		GtkTargetEntry* target_list;
		ClutterStage* _tmp11_;
		ClutterColor _tmp12_ = {0};
		ClutterColor stage_bg;
		UnityBackground* _tmp13_;
		UnityQuicklauncherView* _tmp14_;
		UnityPanelView* _tmp17_;
		WnckScreen* _tmp18_;
#line 71 "window.vala"
		START_FUNCTION ();
#line 72 "window.vala"
		unity_global_shell = (_tmp0_ = _g_object_ref0 ((UnityShell*) self), _g_object_unref0 (unity_global_shell), _tmp0_);
#line 73 "window.vala"
		self->priv->workarea_size = (_tmp1_ = unity_workarea_new (), _unity_workarea_unref0 (self->priv->workarea_size), _tmp1_);
#line 74 "window.vala"
		unity_workarea_update_net_workarea (self->priv->workarea_size);
#line 76 "window.vala"
		if (self->priv->_is_popup) {
#line 78 "window.vala"
			gtk_window_set_type_hint ((GtkWindow*) self, GDK_WINDOW_TYPE_HINT_NORMAL);
#line 79 "window.vala"
			gtk_window_set_decorated ((GtkWindow*) self, TRUE);
#line 80 "window.vala"
			gtk_window_set_skip_taskbar_hint ((GtkWindow*) self, FALSE);
#line 81 "window.vala"
			gtk_window_set_skip_pager_hint ((GtkWindow*) self, FALSE);
#line 82 "window.vala"
			g_signal_connect_object ((GtkWidget*) self, "delete-event", (GCallback) __lambda8__gtk_widget_delete_event, self, 0);
#line 774 "window.c"
		} else {
#line 91 "window.vala"
			gtk_window_set_type_hint ((GtkWindow*) self, GDK_WINDOW_TYPE_HINT_DESKTOP);
#line 92 "window.vala"
			gtk_window_set_keep_below ((GtkWindow*) self, TRUE);
#line 93 "window.vala"
			gtk_window_set_decorated ((GtkWindow*) self, FALSE);
#line 94 "window.vala"
			gtk_window_set_skip_taskbar_hint ((GtkWindow*) self, TRUE);
#line 95 "window.vala"
			gtk_window_set_skip_pager_hint ((GtkWindow*) self, TRUE);
#line 96 "window.vala"
			gtk_window_set_accept_focus ((GtkWindow*) self, FALSE);
#line 97 "window.vala"
			g_object_set ((GtkWidget*) self, "can-focus", FALSE, NULL);
#line 98 "window.vala"
			g_signal_connect_object ((GtkWidget*) self, "delete-event", (GCallback) __lambda9__gtk_widget_delete_event, self, 0);
#line 99 "window.vala"
			g_signal_connect_object (gtk_window_get_screen ((GtkWindow*) self), "size-changed", (GCallback) __lambda10__gdk_screen_size_changed, self, 0);
#line 101 "window.vala"
			g_signal_connect_object (gtk_window_get_screen ((GtkWindow*) self), "monitors-changed", (GCallback) __lambda11__gdk_screen_monitors_changed, self, 0);
#line 796 "window.c"
		}
#line 104 "window.vala"
		gtk_window_set_title ((GtkWindow*) self, "Unity");
#line 105 "window.vala"
		gtk_window_set_icon_name ((GtkWindow*) self, "distributor-logo");
#line 106 "window.vala"
		self->priv->is_showing = FALSE;
#line 109 "window.vala"
		LOGGER_START_PROCESS ("unity_underlay_window_realize");
#line 110 "window.vala"
		gtk_widget_realize ((GtkWidget*) self);
#line 111 "window.vala"
		LOGGER_END_PROCESS ("unity_underlay_window_realize");
#line 113 "window.vala"
		self->priv->gtk_clutter = (_tmp2_ = g_object_ref_sink ((GtkClutterEmbed*) gtk_clutter_embed_new ()), _g_object_unref0 (self->priv->gtk_clutter), _tmp2_);
#line 114 "window.vala"
		gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->gtk_clutter);
#line 115 "window.vala"
		LOGGER_START_PROCESS ("gtk_clutter_realize");
#line 116 "window.vala"
		gtk_widget_realize ((GtkWidget*) self->priv->gtk_clutter);
#line 117 "window.vala"
		LOGGER_END_PROCESS ("gtk_clutter_realize");
#line 820 "window.c"
		target_list = (_tmp10_ = (_tmp9_ = g_new0 (GtkTargetEntry, 6), _tmp9_[0] = (memset (&_tmp3_, 0, sizeof (GtkTargetEntry)), _tmp3_.target = "STRING", _tmp3_.flags = (guint) 0, _tmp3_.info = (guint) UNITY_DND_TARGETS_TARGET_STRING, _tmp3_), _tmp9_[1] = (memset (&_tmp4_, 0, sizeof (GtkTargetEntry)), _tmp4_.target = "text/plain", _tmp4_.flags = (guint) 0, _tmp4_.info = (guint) UNITY_DND_TARGETS_TARGET_STRING, _tmp4_), _tmp9_[2] = (memset (&_tmp5_, 0, sizeof (GtkTargetEntry)), _tmp5_.target = "text/uri-list", _tmp5_.flags = (guint) 0, _tmp5_.info = (guint) UNITY_DND_TARGETS_TARGET_URL, _tmp5_), _tmp9_[3] = (memset (&_tmp6_, 0, sizeof (GtkTargetEntry)), _tmp6_.target = "x-url/http", _tmp6_.flags = (guint) 0, _tmp6_.info = (guint) UNITY_DND_TARGETS_TARGET_URL, _tmp6_), _tmp9_[4] = (memset (&_tmp7_, 0, sizeof (GtkTargetEntry)), _tmp7_.target = "x-url/ftp", _tmp7_.flags = (guint) 0, _tmp7_.info = (guint) UNITY_DND_TARGETS_TARGET_URL, _tmp7_), _tmp9_[5] = (memset (&_tmp8_, 0, sizeof (GtkTargetEntry)), _tmp8_.target = "_NETSCAPE_URL", _tmp8_.flags = (guint) 0, _tmp8_.info = (guint) UNITY_DND_TARGETS_TARGET_URL, _tmp8_), _tmp9_), target_list_length1 = 6, target_list_size = target_list_length1, _tmp10_);
#line 128 "window.vala"
		LOGGER_START_PROCESS ("ctk_dnd_init");
#line 129 "window.vala"
		ctk_dnd_init ((GtkWidget*) self->priv->gtk_clutter, target_list, target_list_length1);
#line 130 "window.vala"
		LOGGER_END_PROCESS ("ctk_dnd_init");
#line 132 "window.vala"
		self->priv->stage = (_tmp11_ = _g_object_ref0 (CLUTTER_STAGE (gtk_clutter_embed_get_stage (self->priv->gtk_clutter))), _g_object_unref0 (self->priv->stage), _tmp11_);
#line 134 "window.vala"
		stage_bg = (memset (&_tmp12_, 0, sizeof (ClutterColor)), _tmp12_.red = (guint8) 0x00, _tmp12_.green = (guint8) 0x00, _tmp12_.blue = (guint8) 0x00, _tmp12_.alpha = (guint8) 0xff, _tmp12_);
#line 140 "window.vala"
		clutter_stage_set_color (self->priv->stage, &stage_bg);
#line 141 "window.vala"
		g_signal_connect_object ((ClutterActor*) self->priv->stage, "button-press-event", (GCallback) _unity_underlay_window_on_stage_button_press_clutter_actor_button_press_event, self, 0);
#line 143 "window.vala"
		self->priv->places_enabled = g_getenv ("UNITY_ENABLE_PLACES") != NULL;
#line 146 "window.vala"
		self->priv->background = (_tmp13_ = g_object_ref_sink (unity_background_new ()), _g_object_unref0 (self->priv->background), _tmp13_);
#line 147 "window.vala"
		clutter_container_add_actor ((ClutterContainer*) self->priv->stage, (ClutterActor*) self->priv->background);
#line 148 "window.vala"
		clutter_actor_show ((ClutterActor*) self->priv->background);
#line 150 "window.vala"
		self->priv->quicklauncher = (_tmp14_ = g_object_ref_sink (unity_quicklauncher_view_new ((UnityShell*) self)), _g_object_unref0 (self->priv->quicklauncher), _tmp14_);
#line 151 "window.vala"
		clutter_container_add_actor ((ClutterContainer*) self->priv->stage, (ClutterActor*) self->priv->quicklauncher);
#line 152 "window.vala"
		clutter_actor_show ((ClutterActor*) self->priv->quicklauncher);
#line 154 "window.vala"
		if (self->priv->places_enabled) {
#line 852 "window.c"
			UnityPlacesController* _tmp15_;
			UnityPlacesView* _tmp16_;
#line 156 "window.vala"
			self->priv->controller = (_tmp15_ = unity_places_controller_new ((UnityShell*) self), _g_object_unref0 (self->priv->controller), _tmp15_);
#line 157 "window.vala"
			self->priv->places = (_tmp16_ = unity_places_controller_get_view (self->priv->controller), _g_object_unref0 (self->priv->places), _tmp16_);
#line 158 "window.vala"
			clutter_container_add_actor ((ClutterContainer*) self->priv->stage, (ClutterActor*) self->priv->places);
#line 159 "window.vala"
			clutter_actor_set_opacity ((ClutterActor*) self->priv->places, (guint8) 0);
#line 160 "window.vala"
			self->priv->showing_places = FALSE;
#line 865 "window.c"
		}
#line 163 "window.vala"
		self->priv->panel = (_tmp17_ = g_object_ref_sink (unity_panel_view_new ((UnityShell*) self)), _g_object_unref0 (self->priv->panel), _tmp17_);
#line 164 "window.vala"
		clutter_container_add_actor ((ClutterContainer*) self->priv->stage, (ClutterActor*) self->priv->panel);
#line 165 "window.vala"
		clutter_actor_show ((ClutterActor*) self->priv->panel);
#line 168 "window.vala"
		gtk_window_move ((GtkWindow*) self, 0, 0);
#line 169 "window.vala"
		unity_underlay_window_relayout (self);
#line 172 "window.vala"
		self->priv->wnck_screen = (_tmp18_ = _g_object_ref0 (wnck_screen_get_default ()), _g_object_unref0 (self->priv->wnck_screen), _tmp18_);
#line 173 "window.vala"
		if (!self->priv->_is_popup) {
#line 175 "window.vala"
			g_signal_connect_object (self->priv->wnck_screen, "active-window-changed", (GCallback) _unity_underlay_window_on_active_window_changed_wnck_screen_active_window_changed, self, 0);
#line 883 "window.c"
		}
#line 178 "window.vala"
		END_FUNCTION ();
#line 887 "window.c"
		target_list = (g_free (target_list), NULL);
	}
	return obj;
}


static void unity_underlay_window_class_init (UnityUnderlayWindowClass * klass) {
	unity_underlay_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityUnderlayWindowPrivate));
	GTK_WIDGET_CLASS (klass)->show = unity_underlay_window_real_show;
	G_OBJECT_CLASS (klass)->get_property = unity_underlay_window_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_underlay_window_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_underlay_window_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_underlay_window_finalize;
	g_object_class_override_property (G_OBJECT_CLASS (klass), UNITY_UNDERLAY_WINDOW_MENUS_SWALLOW_EVENTS, "menus-swallow-events");
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_UNDERLAY_WINDOW_IS_POPUP, g_param_spec_boolean ("is-popup", "is-popup", "is-popup", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_UNDERLAY_WINDOW_POPUP_WIDTH, g_param_spec_int ("popup-width", "popup-width", "popup-width", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_UNDERLAY_WINDOW_POPUP_HEIGHT, g_param_spec_int ("popup-height", "popup-height", "popup-height", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void unity_underlay_window_unity_shell_interface_init (UnityShellIface * iface) {
	unity_underlay_window_unity_shell_parent_iface = g_type_interface_peek_parent (iface);
	iface->add_fullscreen_request = unity_underlay_window_real_add_fullscreen_request;
	iface->remove_fullscreen_request = unity_underlay_window_real_remove_fullscreen_request;
	iface->ensure_input_region = unity_underlay_window_real_ensure_input_region;
	iface->show_window_picker = unity_underlay_window_real_show_window_picker;
	iface->grab_keyboard = unity_underlay_window_real_grab_keyboard;
	iface->get_stage = unity_underlay_window_real_get_stage;
	iface->get_mode = unity_underlay_window_real_get_mode;
	iface->show_unity = unity_underlay_window_real_show_unity;
	iface->get_indicators_width = unity_underlay_window_real_get_indicators_width;
	iface->get_menus_swallow_events = unity_underlay_window_real_get_menus_swallow_events;
}


static void unity_underlay_window_instance_init (UnityUnderlayWindow * self) {
	self->priv = UNITY_UNDERLAY_WINDOW_GET_PRIVATE (self);
	self->priv->places_enabled = FALSE;
}


static void unity_underlay_window_finalize (GObject* obj) {
	UnityUnderlayWindow * self;
	self = UNITY_UNDERLAY_WINDOW (obj);
	_g_object_unref0 (self->priv->wnck_screen);
	_unity_workarea_unref0 (self->priv->workarea_size);
	_g_object_unref0 (self->priv->gtk_clutter);
	_g_object_unref0 (self->priv->stage);
	_g_object_unref0 (self->priv->background);
	_g_object_unref0 (self->priv->quicklauncher);
	_g_object_unref0 (self->priv->panel);
	_g_object_unref0 (self->priv->controller);
	_g_object_unref0 (self->priv->places);
	G_OBJECT_CLASS (unity_underlay_window_parent_class)->finalize (obj);
}


GType unity_underlay_window_get_type (void) {
	static GType unity_underlay_window_type_id = 0;
	if (unity_underlay_window_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityUnderlayWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_underlay_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityUnderlayWindow), 0, (GInstanceInitFunc) unity_underlay_window_instance_init, NULL };
		static const GInterfaceInfo unity_shell_info = { (GInterfaceInitFunc) unity_underlay_window_unity_shell_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		unity_underlay_window_type_id = g_type_register_static (GTK_TYPE_WINDOW, "UnityUnderlayWindow", &g_define_type_info, 0);
		g_type_add_interface_static (unity_underlay_window_type_id, UNITY_TYPE_SHELL, &unity_shell_info);
	}
	return unity_underlay_window_type_id;
}


static void unity_underlay_window_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityUnderlayWindow * self;
	self = UNITY_UNDERLAY_WINDOW (object);
	switch (property_id) {
		case UNITY_UNDERLAY_WINDOW_MENUS_SWALLOW_EVENTS:
		g_value_set_boolean (value, unity_shell_get_menus_swallow_events ((UnityShell*) self));
		break;
		case UNITY_UNDERLAY_WINDOW_IS_POPUP:
		g_value_set_boolean (value, unity_underlay_window_get_is_popup (self));
		break;
		case UNITY_UNDERLAY_WINDOW_POPUP_WIDTH:
		g_value_set_int (value, unity_underlay_window_get_popup_width (self));
		break;
		case UNITY_UNDERLAY_WINDOW_POPUP_HEIGHT:
		g_value_set_int (value, unity_underlay_window_get_popup_height (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_underlay_window_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityUnderlayWindow * self;
	self = UNITY_UNDERLAY_WINDOW (object);
	switch (property_id) {
		case UNITY_UNDERLAY_WINDOW_IS_POPUP:
		unity_underlay_window_set_is_popup (self, g_value_get_boolean (value));
		break;
		case UNITY_UNDERLAY_WINDOW_POPUP_WIDTH:
		unity_underlay_window_set_popup_width (self, g_value_get_int (value));
		break;
		case UNITY_UNDERLAY_WINDOW_POPUP_HEIGHT:
		unity_underlay_window_set_popup_height (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


#line 344 "window.vala"
UnityWorkarea* unity_workarea_construct (GType object_type) {
#line 1003 "window.c"
	UnityWorkarea* self;
	self = (UnityWorkarea*) g_type_create_instance (object_type);
#line 346 "window.vala"
	self->left = 0;
#line 347 "window.vala"
	self->right = 0;
#line 348 "window.vala"
	self->top = 0;
#line 349 "window.vala"
	self->bottom = 0;
#line 351 "window.vala"
	unity_workarea_update_net_workarea (self);
#line 1016 "window.c"
	return self;
}


#line 344 "window.vala"
UnityWorkarea* unity_workarea_new (void) {
#line 344 "window.vala"
	return unity_workarea_construct (UNITY_TYPE_WORKAREA);
#line 1025 "window.c"
}


#line 354 "window.vala"
void unity_workarea_update_net_workarea (UnityWorkarea* self) {
#line 354 "window.vala"
	g_return_if_fail (self != NULL);
#line 359 "window.vala"
	self->left = 0;
#line 360 "window.vala"
	self->right = 0;
#line 361 "window.vala"
	self->top = 24;
#line 362 "window.vala"
	self->bottom = 0;
#line 1041 "window.c"
}


static void unity_value_workarea_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void unity_value_workarea_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		unity_workarea_unref (value->data[0].v_pointer);
	}
}


static void unity_value_workarea_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = unity_workarea_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer unity_value_workarea_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* unity_value_workarea_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		UnityWorkarea* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = unity_workarea_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* unity_value_workarea_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	UnityWorkarea** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = unity_workarea_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* unity_param_spec_workarea (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	UnityParamSpecWorkarea* spec;
	g_return_val_if_fail (g_type_is_a (object_type, UNITY_TYPE_WORKAREA), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer unity_value_get_workarea (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_TYPE_WORKAREA), NULL);
	return value->data[0].v_pointer;
}


void unity_value_set_workarea (GValue* value, gpointer v_object) {
	UnityWorkarea* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_TYPE_WORKAREA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_TYPE_WORKAREA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		unity_workarea_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_workarea_unref (old);
	}
}


static void unity_workarea_class_init (UnityWorkareaClass * klass) {
	unity_workarea_parent_class = g_type_class_peek_parent (klass);
	UNITY_WORKAREA_CLASS (klass)->finalize = unity_workarea_finalize;
	g_signal_new ("workarea_changed", UNITY_TYPE_WORKAREA, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void unity_workarea_instance_init (UnityWorkarea * self) {
	self->ref_count = 1;
}


static void unity_workarea_finalize (UnityWorkarea* obj) {
	UnityWorkarea * self;
	self = UNITY_WORKAREA (obj);
}


GType unity_workarea_get_type (void) {
	static GType unity_workarea_type_id = 0;
	if (unity_workarea_type_id == 0) {
		static const GTypeValueTable g_define_type_value_table = { unity_value_workarea_init, unity_value_workarea_free_value, unity_value_workarea_copy_value, unity_value_workarea_peek_pointer, "p", unity_value_workarea_collect_value, "p", unity_value_workarea_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UnityWorkareaClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_workarea_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityWorkarea), 0, (GInstanceInitFunc) unity_workarea_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		unity_workarea_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UnityWorkarea", &g_define_type_info, &g_define_type_fundamental_info, 0);
	}
	return unity_workarea_type_id;
}


gpointer unity_workarea_ref (gpointer instance) {
	UnityWorkarea* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void unity_workarea_unref (gpointer instance) {
	UnityWorkarea* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UNITY_WORKAREA_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




