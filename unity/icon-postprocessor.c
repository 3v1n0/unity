/* icon-postprocessor.c generated by valac, the Vala compiler
 * generated from icon-postprocessor.vala, do not modify */

/*
 *      icon-postprocessor.vala
 *      Copyright (C) 2010 Canonical Ltd
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 *      MA 02110-1301, USA.
 *
 *
 *      Authored by Gordon Allott <gord.allott@canonical.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <clutter/clutter.h>
#include <clutk/clutk.h>
#include <cogl/cogl.h>
#include <string.h>
#include <stdlib.h>


#define UNITY_TYPE_UNITY_ICON (unity_unity_icon_get_type ())
#define UNITY_UNITY_ICON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_UNITY_ICON, UnityUnityIcon))
#define UNITY_UNITY_ICON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_UNITY_ICON, UnityUnityIconClass))
#define UNITY_IS_UNITY_ICON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_UNITY_ICON))
#define UNITY_IS_UNITY_ICON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_UNITY_ICON))
#define UNITY_UNITY_ICON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_UNITY_ICON, UnityUnityIconClass))

typedef struct _UnityUnityIcon UnityUnityIcon;
typedef struct _UnityUnityIconClass UnityUnityIconClass;
typedef struct _UnityUnityIconPrivate UnityUnityIconPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cogl_handle_unref0(var) ((var == NULL) ? NULL : (var = (cogl_handle_unref (var), NULL)))

#define UNITY_TYPE_THEME_IMAGE (unity_theme_image_get_type ())
#define UNITY_THEME_IMAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_THEME_IMAGE, UnityThemeImage))
#define UNITY_THEME_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_THEME_IMAGE, UnityThemeImageClass))
#define UNITY_IS_THEME_IMAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_THEME_IMAGE))
#define UNITY_IS_THEME_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_THEME_IMAGE))
#define UNITY_THEME_IMAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_THEME_IMAGE, UnityThemeImageClass))

typedef struct _UnityThemeImage UnityThemeImage;
typedef struct _UnityThemeImageClass UnityThemeImageClass;

struct _UnityUnityIcon {
	CtkActor parent_instance;
	UnityUnityIconPrivate * priv;
};

struct _UnityUnityIconClass {
	CtkActorClass parent_class;
};

struct _UnityUnityIconPrivate {
	ClutterTexture* _icon;
	ClutterTexture* _bg_color;
	CoglHandle* bg_mat;
	CoglHandle* fg_mat;
	CoglHandle* icon_material;
	CoglHandle* bgcol_material;
};


extern ClutterTexture* unity_unity_icon_bg_layer;
ClutterTexture* unity_unity_icon_bg_layer = NULL;
extern ClutterTexture* unity_unity_icon_fg_layer;
ClutterTexture* unity_unity_icon_fg_layer = NULL;
extern ClutterTexture* unity_unity_icon_mk_layer;
ClutterTexture* unity_unity_icon_mk_layer = NULL;
static gpointer unity_unity_icon_parent_class = NULL;

void unity_rgb_to_hsv (float r, float g, float b, float* hue, float* sat, float* val);
void unity_hsv_to_rgb (float hue, float sat, float val, float* r, float* g, float* b);
void unity_get_average_color (GdkPixbuf* source, guint* red, guint* green, guint* blue);
GType unity_unity_icon_get_type (void);
#define UNITY_UNITY_ICON_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_UNITY_ICON, UnityUnityIconPrivate))
enum  {
	UNITY_UNITY_ICON_DUMMY_PROPERTY,
	UNITY_UNITY_ICON_ICON,
	UNITY_UNITY_ICON_BG_COLOR
};
UnityUnityIcon* unity_unity_icon_new (ClutterTexture* icon, ClutterTexture* bg_tex);
UnityUnityIcon* unity_unity_icon_construct (GType object_type, ClutterTexture* icon, ClutterTexture* bg_tex);
static void unity_unity_icon_real_get_preferred_width (ClutterActor* base, float for_height, float* minimum_width, float* natural_width);
static void unity_unity_icon_real_get_preferred_height (ClutterActor* base, float for_width, float* minimum_height, float* natural_height);
ClutterTexture* unity_unity_icon_get_icon (UnityUnityIcon* self);
ClutterTexture* unity_unity_icon_get_bg_color (UnityUnityIcon* self);
static void unity_unity_icon_real_allocate (ClutterActor* base, const ClutterActorBox* box, ClutterAllocationFlags flags);
static void unity_unity_icon_real_pick (ClutterActor* base, const ClutterColor* color);
void unity_unity_icon_paint_real (ClutterActor* actor);
static void _unity_unity_icon_paint_real_ctk_effect_paint_func (ClutterActor* actor);
static void unity_unity_icon_real_paint (ClutterActor* base);
static void unity_unity_icon_real_map (ClutterActor* base);
static void unity_unity_icon_real_unmap (ClutterActor* base);
static void unity_unity_icon_set_icon (UnityUnityIcon* self, ClutterTexture* value);
static void unity_unity_icon_set_bg_color (UnityUnityIcon* self, ClutterTexture* value);
UnityThemeImage* unity_theme_image_new (const char* icon_name);
UnityThemeImage* unity_theme_image_construct (GType object_type, const char* icon_name);
GType unity_theme_image_get_type (void);
static GObject * unity_unity_icon_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_unity_icon_finalize (GObject* obj);
static void unity_unity_icon_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_unity_icon_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);



void unity_rgb_to_hsv (float r, float g, float b, float* hue, float* sat, float* val) {
	float min = 0.0F;
	float max = 0.0F;
	float delta;
	if (r > g) {
		float _tmp0_ = 0.0F;
		if (r > b) {
			_tmp0_ = r;
		} else {
			_tmp0_ = b;
		}
		max = _tmp0_;
	} else {
		float _tmp1_ = 0.0F;
		if (g > b) {
			_tmp1_ = g;
		} else {
			_tmp1_ = b;
		}
		max = _tmp1_;
	}
	if (r < g) {
		float _tmp2_ = 0.0F;
		if (r < b) {
			_tmp2_ = r;
		} else {
			_tmp2_ = b;
		}
		min = _tmp2_;
	} else {
		float _tmp3_ = 0.0F;
		if (g < b) {
			_tmp3_ = g;
		} else {
			_tmp3_ = b;
		}
		min = _tmp3_;
	}
	*val = max;
	delta = max - min;
	if (delta > 0.000001) {
		*sat = delta / max;
		*hue = 0.0f;
		if (r == max) {
			*hue = (g - b) / delta;
			if ((*hue) < 0.0f) {
				*hue = (*hue) + 6.0f;
			}
		} else {
			if (g == max) {
				*hue = 2.0f + ((b - r) / delta);
			} else {
				if (b == max) {
					*hue = 4.0f + ((r - g) / delta);
				}
			}
		}
		*hue = (*hue) / 6.0f;
	} else {
		*sat = 0.0f;
		*hue = 0.0f;
	}
}


void unity_hsv_to_rgb (float hue, float sat, float val, float* r, float* g, float* b) {
	gint i = 0;
	float f = 0.0F;
	float w = 0.0F;
	float q = 0.0F;
	float t = 0.0F;
	if (sat == 0.0) {
		*r = *g = *b = val;
	} else {
		if (hue == 1.0) {
			hue = 0.0f;
		}
		hue = hue * 6.0f;
		i = (gint) hue;
		f = hue - i;
		w = val * (1.0f - sat);
		q = val * (1.0f - (sat * f));
		t = val * (1.0f - (sat * (1.0f - f)));
		switch (i) {
			case 0:
			{
				*r = val;
				*g = t;
				*b = w;
				break;
			}
			case 1:
			{
				*r = q;
				*g = val;
				*b = w;
				break;
			}
			case 2:
			{
				*r = w;
				*g = val;
				*b = t;
				break;
			}
			case 3:
			{
				*r = w;
				*g = q;
				*b = val;
				break;
			}
			case 4:
			{
				*r = t;
				*g = w;
				*b = val;
				break;
			}
			case 5:
			{
				*r = val;
				*g = w;
				*b = q;
				break;
			}
		}
	}
}


void unity_get_average_color (GdkPixbuf* source, guint* red, guint* green, guint* blue) {
	gint num_channels;
	gint width;
	gint height;
	gint rowstride;
	float r = 0.0F;
	float g = 0.0F;
	float b = 0.0F;
	float a = 0.0F;
	float hue = 0.0F;
	float sat = 0.0F;
	float val = 0.0F;
	guchar* _tmp0_;
	gint _pixels_size_;
	gint pixels_length1;
	guchar* pixels;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	double r_total = 0.0;
	double g_total = 0.0;
	double b_total = 0.0;
	gint i;
	g_return_if_fail (source != NULL);
	num_channels = gdk_pixbuf_get_n_channels (source);
	width = gdk_pixbuf_get_width (source);
	height = gdk_pixbuf_get_height (source);
	rowstride = gdk_pixbuf_get_rowstride (source);
	pixels = (_tmp0_ = gdk_pixbuf_get_pixels (source), pixels_length1 = -1, _pixels_size_ = pixels_length1, _tmp0_);
	if (gdk_pixbuf_get_colorspace (source) != GDK_COLORSPACE_RGB) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = gdk_pixbuf_get_bits_per_sample (source) != 8;
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = !gdk_pixbuf_get_has_alpha (source);
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = num_channels != 4;
	}
	if (_tmp1_) {
		*red = (guint) 255;
		*green = (guint) 255;
		*blue = (guint) 255;
		return;
	}
	r_total = g_total = b_total = 0.0;
	i = 0;
	{
		gint y;
		y = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				if (!_tmp4_) {
					y++;
				}
				_tmp4_ = FALSE;
				if (!(y < height)) {
					break;
				}
				{
					gint x;
					x = 0;
					{
						gboolean _tmp5_;
						_tmp5_ = TRUE;
						while (TRUE) {
							gint pix_index;
							if (!_tmp5_) {
								x++;
							}
							_tmp5_ = FALSE;
							if (!(x < width)) {
								break;
							}
							pix_index = i + (x * 4);
							r = pixels[pix_index + 0] / 256.0f;
							g = pixels[pix_index + 1] / 256.0f;
							b = pixels[pix_index + 2] / 256.0f;
							a = pixels[pix_index + 3] / 256.0f;
							if (a < (1.0 / 256.0)) {
								continue;
							}
							unity_rgb_to_hsv (r, g, b, &hue, &sat, &val);
							r_total = r_total + ((double) ((r * sat) * a));
							g_total = g_total + ((double) ((g * sat) * a));
							b_total = b_total + ((double) ((b * sat) * a));
						}
					}
				}
				i = (y * (width * 4)) + rowstride;
			}
		}
	}
	r_total = r_total / (width * height);
	g_total = g_total / (width * height);
	b_total = b_total / (width * height);
	unity_rgb_to_hsv ((float) r_total, (float) g_total, (float) b_total, &hue, &sat, &val);
	unity_hsv_to_rgb (hue, fminf (sat + 0.6f, 1.0f), 0.5f, &r, &g, &b);
	*red = (guint) (r * 255);
	*green = (guint) (g * 255);
	*blue = (guint) (b * 255);
}


UnityUnityIcon* unity_unity_icon_construct (GType object_type, ClutterTexture* icon, ClutterTexture* bg_tex) {
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) g_object_new (object_type, "icon", icon, "bg-color", bg_tex, NULL);
	return self;
}


UnityUnityIcon* unity_unity_icon_new (ClutterTexture* icon, ClutterTexture* bg_tex) {
	return unity_unity_icon_construct (UNITY_TYPE_UNITY_ICON, icon, bg_tex);
}


static void unity_unity_icon_real_get_preferred_width (ClutterActor* base, float for_height, float* minimum_width, float* natural_width) {
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
	*natural_width = *minimum_width = (float) 48;
}


static void unity_unity_icon_real_get_preferred_height (ClutterActor* base, float for_width, float* minimum_height, float* natural_height) {
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
	*natural_height = *minimum_height = (float) 48;
}


static void unity_unity_icon_real_allocate (ClutterActor* base, const ClutterActorBox* box, ClutterAllocationFlags flags) {
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
	CLUTTER_ACTOR_CLASS (unity_unity_icon_parent_class)->allocate ((ClutterActor*) CTK_ACTOR (self), box, flags);
	if (CLUTTER_IS_TEXTURE (self->priv->_icon)) {
		clutter_actor_allocate ((ClutterActor*) self->priv->_icon, box, flags);
	}
	if (CLUTTER_IS_TEXTURE (self->priv->_bg_color)) {
		clutter_actor_allocate ((ClutterActor*) self->priv->_bg_color, box, flags);
	}
}


static void unity_unity_icon_real_pick (ClutterActor* base, const ClutterColor* color) {
	UnityUnityIcon * self;
	CoglHandle* mat;
	self = (UnityUnityIcon*) base;
	ctk_actor_set_effects_painting ((CtkActor*) self, TRUE);
	mat = cogl_material_new ();
	cogl_material_set_color4ub (mat, (guchar) (*color).red, (guchar) (*color).green, (guchar) (*color).blue, (guchar) (*color).alpha);
	cogl_rectangle ((float) 0, (float) 0, (float) 48, (float) 48);
	CLUTTER_ACTOR_CLASS (unity_unity_icon_parent_class)->pick ((ClutterActor*) CTK_ACTOR (self), color);
	ctk_actor_set_effects_painting ((CtkActor*) self, FALSE);
	_cogl_handle_unref0 (mat);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void unity_unity_icon_paint_real (ClutterActor* actor) {
	ClutterActor* _tmp0_;
	UnityUnityIcon* _self_;
	ClutterActorBox box = {0};
	guchar opacity;
	g_return_if_fail (actor != NULL);
	_self_ = _g_object_ref0 ((_tmp0_ = actor, UNITY_IS_UNITY_ICON (_tmp0_) ? ((UnityUnityIcon*) _tmp0_) : NULL));
	memset (&box, 0, sizeof (ClutterActorBox));
	ctk_actor_get_stored_allocation ((CtkActor*) _self_, &box);
	opacity = (guchar) clutter_actor_get_paint_opacity ((ClutterActor*) _self_);
	cogl_material_set_color4ub (_self_->priv->bg_mat, opacity, opacity, opacity, opacity);
	cogl_material_set_color4ub (_self_->priv->bgcol_material, opacity, opacity, opacity, opacity);
	cogl_material_set_color4ub (_self_->priv->icon_material, opacity, opacity, opacity, opacity);
	cogl_material_set_color4ub (_self_->priv->fg_mat, opacity, opacity, opacity, opacity);
	cogl_set_source (_self_->priv->bg_mat);
	cogl_rectangle (box.x1, box.y1, box.x2, box.y2);
	if (CLUTTER_IS_TEXTURE (_self_->priv->_bg_color)) {
		cogl_set_source (_self_->priv->bgcol_material);
		cogl_rectangle (box.x1, box.y1, box.x2, box.y2);
	}
	if (CLUTTER_IS_TEXTURE (_self_->priv->_icon)) {
		gint width = 0;
		gint height = 0;
		float xpad = 0.0F;
		float ypad = 0.0F;
		clutter_texture_get_base_size (_self_->priv->_icon, &width, &height);
		xpad = (clutter_actor_box_get_width (&box) - width) / 2.0f;
		ypad = (clutter_actor_box_get_height (&box) - height) / 2.0f;
		cogl_set_source (_self_->priv->icon_material);
		cogl_rectangle (xpad, ypad, box.x2 - xpad, box.y2 - ypad);
	}
	cogl_set_source (_self_->priv->fg_mat);
	cogl_rectangle (box.x1, box.y1, box.x2, box.y2);
	_g_object_unref0 (_self_);
}


static void _unity_unity_icon_paint_real_ctk_effect_paint_func (ClutterActor* actor) {
	unity_unity_icon_paint_real (actor);
}


static void unity_unity_icon_real_paint (ClutterActor* base) {
	UnityUnityIcon * self;
	GSList* effects;
	gboolean _tmp0_ = FALSE;
	self = (UnityUnityIcon*) base;
	effects = ctk_actor_get_effects ((CtkActor*) self);
	if (!ctk_actor_get_effects_painting ((CtkActor*) self)) {
		_tmp0_ = effects != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GSList* e;
		e = NULL;
		ctk_actor_set_effects_painting ((CtkActor*) self, TRUE);
		{
			gboolean _tmp1_;
			e = effects;
			_tmp1_ = TRUE;
			while (TRUE) {
				CtkEffect* effect;
				gboolean _tmp2_ = FALSE;
				gboolean last_effect;
				if (!_tmp1_) {
					e = e->next;
				}
				_tmp1_ = FALSE;
				if (!(e != NULL)) {
					break;
				}
				effect = _g_object_ref0 ((CtkEffect*) e->data);
				if (e->next != NULL) {
					_tmp2_ = FALSE;
				} else {
					_tmp2_ = TRUE;
				}
				last_effect = _tmp2_;
				ctk_effect_paint (effect, _unity_unity_icon_paint_real_ctk_effect_paint_func, last_effect);
				_g_object_unref0 (effect);
			}
		}
		ctk_actor_set_effects_painting ((CtkActor*) self, FALSE);
	} else {
		unity_unity_icon_paint_real ((ClutterActor*) self);
	}
}


static void unity_unity_icon_real_map (ClutterActor* base) {
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
	CLUTTER_ACTOR_CLASS (unity_unity_icon_parent_class)->map ((ClutterActor*) CTK_ACTOR (self));
	clutter_actor_map ((ClutterActor*) self->priv->_icon);
}


static void unity_unity_icon_real_unmap (ClutterActor* base) {
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
	CLUTTER_ACTOR_CLASS (unity_unity_icon_parent_class)->unmap ((ClutterActor*) CTK_ACTOR (self));
	clutter_actor_unmap ((ClutterActor*) self->priv->_icon);
}


ClutterTexture* unity_unity_icon_get_icon (UnityUnityIcon* self) {
	ClutterTexture* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_icon;
	return result;
}


static void unity_unity_icon_set_icon (UnityUnityIcon* self, ClutterTexture* value) {
	ClutterTexture* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_icon = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_icon), _tmp0_);
	g_object_notify ((GObject *) self, "icon");
}


ClutterTexture* unity_unity_icon_get_bg_color (UnityUnityIcon* self) {
	ClutterTexture* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_bg_color;
	return result;
}


static void unity_unity_icon_set_bg_color (UnityUnityIcon* self, ClutterTexture* value) {
	ClutterTexture* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_bg_color = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_bg_color), _tmp0_);
	g_object_notify ((GObject *) self, "bg-color");
}


static gpointer _cogl_handle_ref0 (gpointer self) {
	return self ? cogl_handle_ref (self) : NULL;
}


static GObject * unity_unity_icon_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityUnityIcon * self;
	parent_class = G_OBJECT_CLASS (unity_unity_icon_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_UNITY_ICON (obj);
	{
		CoglHandle* mat;
		CoglHandle* tex;
		CoglHandle* _tmp5_;
		CoglHandle* _tmp6_;
		CoglHandle* _tmp7_;
		CoglHandle* _tmp8_;
		if (!CLUTTER_IS_TEXTURE (unity_unity_icon_bg_layer)) {
			ClutterTexture* _tmp0_;
			ClutterTexture* _tmp1_;
			ClutterTexture* _tmp2_;
			unity_unity_icon_bg_layer = (_tmp0_ = (ClutterTexture*) g_object_ref_sink (unity_theme_image_new ("prism_icon_background")), _g_object_unref0 (unity_unity_icon_bg_layer), _tmp0_);
			unity_unity_icon_fg_layer = (_tmp1_ = (ClutterTexture*) g_object_ref_sink (unity_theme_image_new ("prism_icon_foreground")), _g_object_unref0 (unity_unity_icon_fg_layer), _tmp1_);
			unity_unity_icon_mk_layer = (_tmp2_ = (ClutterTexture*) g_object_ref_sink (unity_theme_image_new ("prism_icon_mask")), _g_object_unref0 (unity_unity_icon_mk_layer), _tmp2_);
		}
		if (CLUTTER_IS_TEXTURE (self->priv->_icon)) {
			CoglHandle* icon_mat;
			CoglHandle* icon_tex;
			CoglHandle* mask_tex;
			CoglHandle* _tmp3_;
			clutter_actor_set_parent ((ClutterActor*) self->priv->_icon, (ClutterActor*) self);
			icon_mat = cogl_material_new ();
			icon_tex = (CoglHandle*) clutter_texture_get_cogl_texture (self->priv->_icon);
			mask_tex = (CoglHandle*) clutter_texture_get_cogl_texture (unity_unity_icon_mk_layer);
			cogl_material_set_layer (icon_mat, 0, icon_tex);
			cogl_material_set_layer (icon_mat, 1, mask_tex);
			self->priv->icon_material = (_tmp3_ = _cogl_handle_ref0 (icon_mat), _cogl_handle_unref0 (self->priv->icon_material), _tmp3_);
			_cogl_handle_unref0 (icon_mat);
			_cogl_handle_unref0 (icon_tex);
			_cogl_handle_unref0 (mask_tex);
		}
		if (CLUTTER_IS_TEXTURE (self->priv->_bg_color)) {
			CoglHandle* _tmp4_;
			CoglHandle* color;
			CoglHandle* mask_tex;
			clutter_actor_set_parent ((ClutterActor*) self->priv->_bg_color, (ClutterActor*) self);
			self->priv->bgcol_material = (_tmp4_ = cogl_material_new (), _cogl_handle_unref0 (self->priv->bgcol_material), _tmp4_);
			color = (CoglHandle*) clutter_texture_get_cogl_texture (self->priv->_bg_color);
			mask_tex = (CoglHandle*) clutter_texture_get_cogl_texture (unity_unity_icon_mk_layer);
			cogl_material_set_layer (self->priv->bgcol_material, 0, color);
			cogl_material_set_layer_filters (self->priv->bgcol_material, 1, COGL_MATERIAL_FILTER_NEAREST, COGL_MATERIAL_FILTER_NEAREST);
			cogl_material_set_layer (self->priv->bgcol_material, 1, mask_tex);
			_cogl_handle_unref0 (color);
			_cogl_handle_unref0 (mask_tex);
		}
		mat = cogl_material_new ();
		tex = (CoglHandle*) clutter_texture_get_cogl_texture (unity_unity_icon_bg_layer);
		cogl_material_set_layer (mat, 0, tex);
		self->priv->bg_mat = (_tmp5_ = _cogl_handle_ref0 (mat), _cogl_handle_unref0 (self->priv->bg_mat), _tmp5_);
		mat = (_tmp6_ = cogl_material_new (), _cogl_handle_unref0 (mat), _tmp6_);
		tex = (_tmp7_ = (CoglHandle*) clutter_texture_get_cogl_texture (unity_unity_icon_fg_layer), _cogl_handle_unref0 (tex), _tmp7_);
		cogl_material_set_layer (mat, 0, tex);
		self->priv->fg_mat = (_tmp8_ = _cogl_handle_ref0 (mat), _cogl_handle_unref0 (self->priv->fg_mat), _tmp8_);
		_cogl_handle_unref0 (mat);
		_cogl_handle_unref0 (tex);
	}
	return obj;
}


static void unity_unity_icon_class_init (UnityUnityIconClass * klass) {
	unity_unity_icon_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityUnityIconPrivate));
	CLUTTER_ACTOR_CLASS (klass)->get_preferred_width = unity_unity_icon_real_get_preferred_width;
	CLUTTER_ACTOR_CLASS (klass)->get_preferred_height = unity_unity_icon_real_get_preferred_height;
	CLUTTER_ACTOR_CLASS (klass)->allocate = unity_unity_icon_real_allocate;
	CLUTTER_ACTOR_CLASS (klass)->pick = unity_unity_icon_real_pick;
	CLUTTER_ACTOR_CLASS (klass)->paint = unity_unity_icon_real_paint;
	CLUTTER_ACTOR_CLASS (klass)->map = unity_unity_icon_real_map;
	CLUTTER_ACTOR_CLASS (klass)->unmap = unity_unity_icon_real_unmap;
	G_OBJECT_CLASS (klass)->get_property = unity_unity_icon_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_unity_icon_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_unity_icon_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_unity_icon_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_UNITY_ICON_ICON, g_param_spec_object ("icon", "icon", "icon", CLUTTER_TYPE_TEXTURE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_UNITY_ICON_BG_COLOR, g_param_spec_object ("bg-color", "bg-color", "bg-color", CLUTTER_TYPE_TEXTURE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void unity_unity_icon_instance_init (UnityUnityIcon * self) {
	self->priv = UNITY_UNITY_ICON_GET_PRIVATE (self);
}


static void unity_unity_icon_finalize (GObject* obj) {
	UnityUnityIcon * self;
	self = UNITY_UNITY_ICON (obj);
	_g_object_unref0 (self->priv->_icon);
	_g_object_unref0 (self->priv->_bg_color);
	_cogl_handle_unref0 (self->priv->bg_mat);
	_cogl_handle_unref0 (self->priv->fg_mat);
	_cogl_handle_unref0 (self->priv->icon_material);
	_cogl_handle_unref0 (self->priv->bgcol_material);
	G_OBJECT_CLASS (unity_unity_icon_parent_class)->finalize (obj);
}


GType unity_unity_icon_get_type (void) {
	static volatile gsize unity_unity_icon_type_id__volatile = 0;
	if (g_once_init_enter (&unity_unity_icon_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityUnityIconClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_unity_icon_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityUnityIcon), 0, (GInstanceInitFunc) unity_unity_icon_instance_init, NULL };
		GType unity_unity_icon_type_id;
		unity_unity_icon_type_id = g_type_register_static (CTK_TYPE_ACTOR, "UnityUnityIcon", &g_define_type_info, 0);
		g_once_init_leave (&unity_unity_icon_type_id__volatile, unity_unity_icon_type_id);
	}
	return unity_unity_icon_type_id__volatile;
}


static void unity_unity_icon_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityUnityIcon * self;
	self = UNITY_UNITY_ICON (object);
	switch (property_id) {
		case UNITY_UNITY_ICON_ICON:
		g_value_set_object (value, unity_unity_icon_get_icon (self));
		break;
		case UNITY_UNITY_ICON_BG_COLOR:
		g_value_set_object (value, unity_unity_icon_get_bg_color (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_unity_icon_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityUnityIcon * self;
	self = UNITY_UNITY_ICON (object);
	switch (property_id) {
		case UNITY_UNITY_ICON_ICON:
		unity_unity_icon_set_icon (self, g_value_get_object (value));
		break;
		case UNITY_UNITY_ICON_BG_COLOR:
		unity_unity_icon_set_bg_color (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}




