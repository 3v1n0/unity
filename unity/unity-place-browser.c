/* unity-place-browser.c generated by valac, the Vala compiler
 * generated from unity-place-browser.vala, do not modify */

/*
 * Copyright (C) 2010 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by Mikkel Kamstrup Erlandsen <mikkel.kamstrup@canonical.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <dbus/dbus.h>
#include <gee.h>
#include <gobject/gvaluecollector.h>


#define UNITY_PLACE_TYPE__BROWSINGSTATE (unity_place__browsingstate_get_type ())
typedef struct _UnityPlace_BrowsingState UnityPlace_BrowsingState;
#define _g_free0(var) (var = (g_free (var), NULL))

#define UNITY_PLACE_TYPE_BROWSING_OP (unity_place_browsing_op_get_type ())

#define UNITY_PLACE_TYPE_BROWSER_SERVICE (unity_place_browser_service_get_type ())
#define UNITY_PLACE_BROWSER_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_BROWSER_SERVICE, UnityPlaceBrowserService))
#define UNITY_PLACE_IS_BROWSER_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_BROWSER_SERVICE))
#define UNITY_PLACE_BROWSER_SERVICE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), UNITY_PLACE_TYPE_BROWSER_SERVICE, UnityPlaceBrowserServiceIface))

typedef struct _UnityPlaceBrowserService UnityPlaceBrowserService;
typedef struct _UnityPlaceBrowserServiceIface UnityPlaceBrowserServiceIface;
typedef struct _DBusObjectVTable _DBusObjectVTable;
typedef struct _UnityPlaceBrowserServiceDBusProxy UnityPlaceBrowserServiceDBusProxy;
typedef DBusGProxyClass UnityPlaceBrowserServiceDBusProxyClass;

#define UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL (unity_place_browser_service_impl_get_type ())
#define UNITY_PLACE_BROWSER_SERVICE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL, UnityPlaceBrowserServiceImpl))
#define UNITY_PLACE_BROWSER_SERVICE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL, UnityPlaceBrowserServiceImplClass))
#define UNITY_PLACE_IS_BROWSER_SERVICE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL))
#define UNITY_PLACE_IS_BROWSER_SERVICE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL))
#define UNITY_PLACE_BROWSER_SERVICE_IMPL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL, UnityPlaceBrowserServiceImplClass))

typedef struct _UnityPlaceBrowserServiceImpl UnityPlaceBrowserServiceImpl;
typedef struct _UnityPlaceBrowserServiceImplClass UnityPlaceBrowserServiceImplClass;
typedef struct _UnityPlaceBrowserServiceImplPrivate UnityPlaceBrowserServiceImplPrivate;

#define UNITY_PLACE_TYPE_BROWSER (unity_place_browser_get_type ())
#define UNITY_PLACE_BROWSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_BROWSER, UnityPlaceBrowser))
#define UNITY_PLACE_BROWSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_BROWSER, UnityPlaceBrowserClass))
#define UNITY_PLACE_IS_BROWSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_BROWSER))
#define UNITY_PLACE_IS_BROWSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_BROWSER))
#define UNITY_PLACE_BROWSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_BROWSER, UnityPlaceBrowserClass))

typedef struct _UnityPlaceBrowser UnityPlaceBrowser;
typedef struct _UnityPlaceBrowserClass UnityPlaceBrowserClass;
typedef struct _UnityPlaceBrowserPrivate UnityPlaceBrowserPrivate;

#define UNITY_PLACE_TYPE_STACK (unity_place_stack_get_type ())
#define UNITY_PLACE_STACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_STACK, UnityPlaceStack))
#define UNITY_PLACE_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_STACK, UnityPlaceStackClass))
#define UNITY_PLACE_IS_STACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_STACK))
#define UNITY_PLACE_IS_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_STACK))
#define UNITY_PLACE_STACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_STACK, UnityPlaceStackClass))

typedef struct _UnityPlaceStack UnityPlaceStack;
typedef struct _UnityPlaceStackClass UnityPlaceStackClass;

#define UNITY_PLACE_TYPE_STATE (unity_place_state_get_type ())
#define UNITY_PLACE_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_STATE, UnityPlaceState))
#define UNITY_PLACE_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_STATE, UnityPlaceStateClass))
#define UNITY_PLACE_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_STATE))
#define UNITY_PLACE_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_STATE))
#define UNITY_PLACE_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_STATE, UnityPlaceStateClass))

typedef struct _UnityPlaceState UnityPlaceState;
typedef struct _UnityPlaceStateClass UnityPlaceStateClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _unity_place_stack_unref0(var) ((var == NULL) ? NULL : (var = (unity_place_stack_unref (var), NULL)))
#define _unity_place_state_unref0(var) ((var == NULL) ? NULL : (var = (unity_place_state_unref (var), NULL)))
typedef struct _UnityPlaceStatePrivate UnityPlaceStatePrivate;
typedef struct _UnityPlaceParamSpecState UnityPlaceParamSpecState;
typedef struct _UnityPlaceStackPrivate UnityPlaceStackPrivate;
typedef struct _UnityPlaceParamSpecStack UnityPlaceParamSpecStack;

struct _UnityPlace_BrowsingState {
	gboolean sensitive;
	char* comment;
};

typedef enum  {
	UNITY_PLACE_BROWSING_OP_BACK,
	UNITY_PLACE_BROWSING_OP_FORWARD,
	UNITY_PLACE_BROWSING_OP_NUM_OPS
} UnityPlaceBrowsingOp;

struct _UnityPlaceBrowserServiceIface {
	GTypeInterface parent_iface;
	UnityPlace_BrowsingState* (*go_back) (UnityPlaceBrowserService* self, int* result_length1, GError** error);
	UnityPlace_BrowsingState* (*go_forward) (UnityPlaceBrowserService* self, int* result_length1, GError** error);
	UnityPlace_BrowsingState* (*get_state) (UnityPlaceBrowserService* self, int* result_length1, GError** error);
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};

struct _UnityPlaceBrowserServiceDBusProxy {
	DBusGProxy parent_instance;
	gboolean disposed;
};

struct _UnityPlaceBrowserServiceImpl {
	GObject parent_instance;
	UnityPlaceBrowserServiceImplPrivate * priv;
};

struct _UnityPlaceBrowserServiceImplClass {
	GObjectClass parent_class;
};

struct _UnityPlaceBrowserServiceImplPrivate {
	char* _dbus_path;
	UnityPlace_BrowsingState* _browsing_state;
	gint _browsing_state_length1;
	gint __browsing_state_size_;
};

struct _UnityPlaceBrowser {
	GObject parent_instance;
	UnityPlaceBrowserPrivate * priv;
};

struct _UnityPlaceBrowserClass {
	GObjectClass parent_class;
};

struct _UnityPlaceBrowserPrivate {
	GType e_type;
	GBoxedCopyFunc e_dup_func;
	GDestroyNotify e_destroy_func;
	UnityPlaceBrowserServiceImpl* service;
	UnityPlaceStack* back_stack;
	UnityPlaceStack* forward_stack;
	UnityPlaceState* current_state;
	char* _dbus_path;
};

struct _UnityPlaceState {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityPlaceStatePrivate * priv;
	gpointer state;
	char* comment;
};

struct _UnityPlaceStateClass {
	GTypeClass parent_class;
	void (*finalize) (UnityPlaceState *self);
};

struct _UnityPlaceStatePrivate {
	GType e_type;
	GBoxedCopyFunc e_dup_func;
	GDestroyNotify e_destroy_func;
};

struct _UnityPlaceParamSpecState {
	GParamSpec parent_instance;
};

struct _UnityPlaceStack {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityPlaceStackPrivate * priv;
};

struct _UnityPlaceStackClass {
	GTypeClass parent_class;
	void (*finalize) (UnityPlaceStack *self);
};

struct _UnityPlaceStackPrivate {
	GType e_type;
	GBoxedCopyFunc e_dup_func;
	GDestroyNotify e_destroy_func;
	GeeLinkedList* list;
};

struct _UnityPlaceParamSpecStack {
	GParamSpec parent_instance;
};


static gpointer unity_place_browser_service_impl_parent_class = NULL;
static UnityPlaceBrowserServiceIface* unity_place_browser_service_impl_unity_place_browser_service_parent_iface = NULL;
static gpointer unity_place_browser_parent_class = NULL;
static gpointer unity_place_state_parent_class = NULL;
static gpointer unity_place_stack_parent_class = NULL;

GType unity_place__browsingstate_get_type (void) G_GNUC_CONST;
UnityPlace_BrowsingState* unity_place__browsingstate_dup (const UnityPlace_BrowsingState* self);
void unity_place__browsingstate_free (UnityPlace_BrowsingState* self);
void unity_place__browsingstate_copy (const UnityPlace_BrowsingState* self, UnityPlace_BrowsingState* dest);
void unity_place__browsingstate_destroy (UnityPlace_BrowsingState* self);
GType unity_place_browsing_op_get_type (void) G_GNUC_CONST;
UnityPlaceBrowserService* unity_place_browser_service_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path);
GType unity_place_browser_service_get_type (void) G_GNUC_CONST;
UnityPlace_BrowsingState* unity_place_browser_service_go_back (UnityPlaceBrowserService* self, int* result_length1, GError** error);
UnityPlace_BrowsingState* unity_place_browser_service_go_forward (UnityPlaceBrowserService* self, int* result_length1, GError** error);
UnityPlace_BrowsingState* unity_place_browser_service_get_state (UnityPlaceBrowserService* self, int* result_length1, GError** error);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
void unity_place_browser_service_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _unity_place_browser_service_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult unity_place_browser_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_unity_place_browser_service_introspect (UnityPlaceBrowserService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_browser_service_property_get_all (UnityPlaceBrowserService* self, DBusConnection* connection, DBusMessage* message);
static void _vala_UnityPlace_BrowsingState_array_free (UnityPlace_BrowsingState* array, gint array_length);
static DBusHandlerResult _dbus_unity_place_browser_service_go_back (UnityPlaceBrowserService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_browser_service_go_forward (UnityPlaceBrowserService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_browser_service_get_state (UnityPlaceBrowserService* self, DBusConnection* connection, DBusMessage* message);
GType unity_place_browser_service_dbus_proxy_get_type (void) G_GNUC_CONST;
DBusHandlerResult unity_place_browser_service_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
	UNITY_PLACE_BROWSER_SERVICE_DBUS_PROXY_DUMMY_PROPERTY
};
static UnityPlace_BrowsingState* unity_place_browser_service_dbus_proxy_go_back (UnityPlaceBrowserService* self, int* result_length1, GError** error);
static UnityPlace_BrowsingState* unity_place_browser_service_dbus_proxy_go_forward (UnityPlaceBrowserService* self, int* result_length1, GError** error);
static UnityPlace_BrowsingState* unity_place_browser_service_dbus_proxy_get_state (UnityPlaceBrowserService* self, int* result_length1, GError** error);
static void unity_place_browser_service_dbus_proxy_unity_place_browser_service__interface_init (UnityPlaceBrowserServiceIface* iface);
static void unity_place_browser_service_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_browser_service_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_place_browser_service_impl_get_type (void) G_GNUC_CONST;
#define UNITY_PLACE_BROWSER_SERVICE_IMPL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL, UnityPlaceBrowserServiceImplPrivate))
enum  {
	UNITY_PLACE_BROWSER_SERVICE_IMPL_DUMMY_PROPERTY,
	UNITY_PLACE_BROWSER_SERVICE_IMPL_DBUS_PATH
};
static void unity_place_browser_service_impl_set_dbus_path (UnityPlaceBrowserServiceImpl* self, const char* value);
static void unity_place_browser_service_impl_set_browsing_state (UnityPlaceBrowserServiceImpl* self, UnityPlace_BrowsingState* value, int value_length1);
UnityPlaceBrowserServiceImpl* unity_place_browser_service_impl_new (const char* dbus_path);
UnityPlaceBrowserServiceImpl* unity_place_browser_service_impl_construct (GType object_type, const char* dbus_path);
UnityPlace_BrowsingState* unity_place_browser_service_impl_get_browsing_state (UnityPlaceBrowserServiceImpl* self, int* result_length1);
static UnityPlace_BrowsingState* _vala_array_dup9 (UnityPlace_BrowsingState* self, int length);
static UnityPlace_BrowsingState* unity_place_browser_service_impl_real_go_back (UnityPlaceBrowserService* base, int* result_length1, GError** error);
static UnityPlace_BrowsingState* _vala_array_dup10 (UnityPlace_BrowsingState* self, int length);
static UnityPlace_BrowsingState* unity_place_browser_service_impl_real_go_forward (UnityPlaceBrowserService* base, int* result_length1, GError** error);
static UnityPlace_BrowsingState* _vala_array_dup11 (UnityPlace_BrowsingState* self, int length);
static UnityPlace_BrowsingState* unity_place_browser_service_impl_real_get_state (UnityPlaceBrowserService* base, int* result_length1, GError** error);
const char* unity_place_browser_service_impl_get_dbus_path (UnityPlaceBrowserServiceImpl* self);
static UnityPlace_BrowsingState* _vala_array_dup12 (UnityPlace_BrowsingState* self, int length);
void unity_place_browser_service_impl_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _unity_place_browser_service_impl_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult unity_place_browser_service_impl_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_unity_place_browser_service_impl_introspect (UnityPlaceBrowserServiceImpl* self, DBusConnection* connection, DBusMessage* message);
static void unity_place_browser_service_impl_finalize (GObject* obj);
static void unity_place_browser_service_impl_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_browser_service_impl_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_place_browser_get_type (void) G_GNUC_CONST;
gpointer unity_place_stack_ref (gpointer instance);
void unity_place_stack_unref (gpointer instance);
GParamSpec* unity_place_param_spec_stack (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_place_value_set_stack (GValue* value, gpointer v_object);
void unity_place_value_take_stack (GValue* value, gpointer v_object);
gpointer unity_place_value_get_stack (const GValue* value);
GType unity_place_stack_get_type (void) G_GNUC_CONST;
gpointer unity_place_state_ref (gpointer instance);
void unity_place_state_unref (gpointer instance);
GParamSpec* unity_place_param_spec_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void unity_place_value_set_state (GValue* value, gpointer v_object);
void unity_place_value_take_state (GValue* value, gpointer v_object);
gpointer unity_place_value_get_state (const GValue* value);
GType unity_place_state_get_type (void) G_GNUC_CONST;
#define UNITY_PLACE_BROWSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_BROWSER, UnityPlaceBrowserPrivate))
enum  {
	UNITY_PLACE_BROWSER_DUMMY_PROPERTY,
	UNITY_PLACE_BROWSER_DBUS_PATH,
	UNITY_PLACE_BROWSER_E_TYPE,
	UNITY_PLACE_BROWSER_E_DUP_FUNC,
	UNITY_PLACE_BROWSER_E_DESTROY_FUNC
};
static void unity_place_browser_set_dbus_path (UnityPlaceBrowser* self, const char* value);
UnityPlaceStack* unity_place_stack_new (GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func);
UnityPlaceStack* unity_place_stack_construct (GType object_type, GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func);
void unity_place_browser_go_back (UnityPlaceBrowser* self);
static void _unity_place_browser_go_back_unity_place_browser_service_impl_back (UnityPlaceBrowserServiceImpl* _sender, gpointer self);
void unity_place_browser_go_forward (UnityPlaceBrowser* self);
static void _unity_place_browser_go_forward_unity_place_browser_service_impl_forward (UnityPlaceBrowserServiceImpl* _sender, gpointer self);
static void unity_place_browser_update_service_state (UnityPlaceBrowser* self);
UnityPlaceBrowser* unity_place_browser_new (GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func, const char* dbus_path);
UnityPlaceBrowser* unity_place_browser_construct (GType object_type, GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func, const char* dbus_path);
UnityPlaceStack* unity_place_stack_push (UnityPlaceStack* self, gconstpointer element);
UnityPlaceState* unity_place_state_new (GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func);
UnityPlaceState* unity_place_state_construct (GType object_type, GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func);
void unity_place_browser_record_state (UnityPlaceBrowser* self, gconstpointer state, const char* comment);
void unity_place_stack_clear (UnityPlaceStack* self);
void unity_place_browser_clear (UnityPlaceBrowser* self);
gpointer unity_place_stack_pop (UnityPlaceStack* self);
gboolean unity_place_stack_is_empty (UnityPlaceStack* self);
gpointer unity_place_stack_peek (UnityPlaceStack* self);
UnityPlaceBrowserService* unity_place_browser_get_service (UnityPlaceBrowser* self);
const char* unity_place_browser_get_dbus_path (UnityPlaceBrowser* self);
static void unity_place_browser_finalize (GObject* obj);
static void unity_place_browser_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_browser_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define UNITY_PLACE_STATE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_STATE, UnityPlaceStatePrivate))
enum  {
	UNITY_PLACE_STATE_DUMMY_PROPERTY
};
static void unity_place_state_finalize (UnityPlaceState* obj);
#define UNITY_PLACE_STACK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_STACK, UnityPlaceStackPrivate))
enum  {
	UNITY_PLACE_STACK_DUMMY_PROPERTY
};
gint unity_place_stack_size (UnityPlaceStack* self);
static void unity_place_stack_finalize (UnityPlaceStack* obj);

static const DBusObjectPathVTable _unity_place_browser_service_dbus_path_vtable = {_unity_place_browser_service_dbus_unregister, unity_place_browser_service_dbus_message};
static const _DBusObjectVTable _unity_place_browser_service_dbus_vtable = {unity_place_browser_service_dbus_register_object};
static const DBusObjectPathVTable _unity_place_browser_service_impl_dbus_path_vtable = {_unity_place_browser_service_impl_dbus_unregister, unity_place_browser_service_impl_dbus_message};
static const _DBusObjectVTable _unity_place_browser_service_impl_dbus_vtable = {unity_place_browser_service_impl_dbus_register_object};

static void g_cclosure_user_marshal_VOID__POINTER_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

void unity_place__browsingstate_copy (const UnityPlace_BrowsingState* self, UnityPlace_BrowsingState* dest) {
	dest->sensitive = self->sensitive;
	dest->comment = g_strdup (self->comment);
}


void unity_place__browsingstate_destroy (UnityPlace_BrowsingState* self) {
	_g_free0 (self->comment);
}


UnityPlace_BrowsingState* unity_place__browsingstate_dup (const UnityPlace_BrowsingState* self) {
	UnityPlace_BrowsingState* dup;
	dup = g_new0 (UnityPlace_BrowsingState, 1);
	unity_place__browsingstate_copy (self, dup);
	return dup;
}


void unity_place__browsingstate_free (UnityPlace_BrowsingState* self) {
	unity_place__browsingstate_destroy (self);
	g_free (self);
}


GType unity_place__browsingstate_get_type (void) {
	static volatile gsize unity_place__browsingstate_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place__browsingstate_type_id__volatile)) {
		GType unity_place__browsingstate_type_id;
		unity_place__browsingstate_type_id = g_boxed_type_register_static ("UnityPlace_BrowsingState", (GBoxedCopyFunc) unity_place__browsingstate_dup, (GBoxedFreeFunc) unity_place__browsingstate_free);
		g_once_init_leave (&unity_place__browsingstate_type_id__volatile, unity_place__browsingstate_type_id);
	}
	return unity_place__browsingstate_type_id__volatile;
}


GType unity_place_browsing_op_get_type (void) {
	static volatile gsize unity_place_browsing_op_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_browsing_op_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_PLACE_BROWSING_OP_BACK, "UNITY_PLACE_BROWSING_OP_BACK", "back"}, {UNITY_PLACE_BROWSING_OP_FORWARD, "UNITY_PLACE_BROWSING_OP_FORWARD", "forward"}, {UNITY_PLACE_BROWSING_OP_NUM_OPS, "UNITY_PLACE_BROWSING_OP_NUM_OPS", "num-ops"}, {0, NULL, NULL}};
		GType unity_place_browsing_op_type_id;
		unity_place_browsing_op_type_id = g_enum_register_static ("UnityPlaceBrowsingOp", values);
		g_once_init_leave (&unity_place_browsing_op_type_id__volatile, unity_place_browsing_op_type_id);
	}
	return unity_place_browsing_op_type_id__volatile;
}


UnityPlace_BrowsingState* unity_place_browser_service_go_back (UnityPlaceBrowserService* self, int* result_length1, GError** error) {
	return UNITY_PLACE_BROWSER_SERVICE_GET_INTERFACE (self)->go_back (self, result_length1, error);
}


UnityPlace_BrowsingState* unity_place_browser_service_go_forward (UnityPlaceBrowserService* self, int* result_length1, GError** error) {
	return UNITY_PLACE_BROWSER_SERVICE_GET_INTERFACE (self)->go_forward (self, result_length1, error);
}


UnityPlace_BrowsingState* unity_place_browser_service_get_state (UnityPlaceBrowserService* self, int* result_length1, GError** error) {
	return UNITY_PLACE_BROWSER_SERVICE_GET_INTERFACE (self)->get_state (self, result_length1, error);
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}


void _unity_place_browser_service_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_unity_place_browser_service_introspect (UnityPlaceBrowserService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.canonical.Unity.PlaceBrowser\">\n  <method name=\"GoBack\">\n    <arg name=\"result\" type=\"a(bs)\" direction=\"out\"/>\n  </method>\n  <method name=\"GoForward\">\n    <arg name=\"result\" type=\"a(bs)\" direction=\"out\"/>\n  </method>\n  <method name=\"GetState\">\n    <arg name=\"result\" type=\"a(bs)\" direction=\"out\"/>\n  </method>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_browser_service_property_get_all (UnityPlaceBrowserService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp0_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp0_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp0_);
	if (strcmp (interface_name, "com.canonical.Unity.PlaceBrowser") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _vala_UnityPlace_BrowsingState_array_free (UnityPlace_BrowsingState* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			unity_place__browsingstate_destroy (&array[i]);
		}
	}
	g_free (array);
}


static DBusHandlerResult _dbus_unity_place_browser_service_go_back (UnityPlaceBrowserService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	UnityPlace_BrowsingState* result;
	int result_length1;
	DBusMessage* reply;
	UnityPlace_BrowsingState* _tmp1_;
	DBusMessageIter _tmp2_;
	int _tmp3_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result_length1 = 0;
	result = unity_place_browser_service_go_back (self, &result_length1, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp1_ = result;
	dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "(bs)", &_tmp2_);
	for (_tmp3_ = 0; _tmp3_ < result_length1; _tmp3_++) {
		DBusMessageIter _tmp4_;
		dbus_bool_t _tmp5_;
		const char* _tmp6_;
		dbus_message_iter_open_container (&_tmp2_, DBUS_TYPE_STRUCT, NULL, &_tmp4_);
		_tmp5_ = (*_tmp1_).sensitive;
		dbus_message_iter_append_basic (&_tmp4_, DBUS_TYPE_BOOLEAN, &_tmp5_);
		_tmp6_ = (*_tmp1_).comment;
		dbus_message_iter_append_basic (&_tmp4_, DBUS_TYPE_STRING, &_tmp6_);
		dbus_message_iter_close_container (&_tmp2_, &_tmp4_);
		_tmp1_++;
	}
	dbus_message_iter_close_container (&iter, &_tmp2_);
	result = (_vala_UnityPlace_BrowsingState_array_free (result,  result_length1), NULL);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_browser_service_go_forward (UnityPlaceBrowserService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	UnityPlace_BrowsingState* result;
	int result_length1;
	DBusMessage* reply;
	UnityPlace_BrowsingState* _tmp7_;
	DBusMessageIter _tmp8_;
	int _tmp9_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result_length1 = 0;
	result = unity_place_browser_service_go_forward (self, &result_length1, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp7_ = result;
	dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "(bs)", &_tmp8_);
	for (_tmp9_ = 0; _tmp9_ < result_length1; _tmp9_++) {
		DBusMessageIter _tmp10_;
		dbus_bool_t _tmp11_;
		const char* _tmp12_;
		dbus_message_iter_open_container (&_tmp8_, DBUS_TYPE_STRUCT, NULL, &_tmp10_);
		_tmp11_ = (*_tmp7_).sensitive;
		dbus_message_iter_append_basic (&_tmp10_, DBUS_TYPE_BOOLEAN, &_tmp11_);
		_tmp12_ = (*_tmp7_).comment;
		dbus_message_iter_append_basic (&_tmp10_, DBUS_TYPE_STRING, &_tmp12_);
		dbus_message_iter_close_container (&_tmp8_, &_tmp10_);
		_tmp7_++;
	}
	dbus_message_iter_close_container (&iter, &_tmp8_);
	result = (_vala_UnityPlace_BrowsingState_array_free (result,  result_length1), NULL);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_browser_service_get_state (UnityPlaceBrowserService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	UnityPlace_BrowsingState* result;
	int result_length1;
	DBusMessage* reply;
	UnityPlace_BrowsingState* _tmp13_;
	DBusMessageIter _tmp14_;
	int _tmp15_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result_length1 = 0;
	result = unity_place_browser_service_get_state (self, &result_length1, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp13_ = result;
	dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "(bs)", &_tmp14_);
	for (_tmp15_ = 0; _tmp15_ < result_length1; _tmp15_++) {
		DBusMessageIter _tmp16_;
		dbus_bool_t _tmp17_;
		const char* _tmp18_;
		dbus_message_iter_open_container (&_tmp14_, DBUS_TYPE_STRUCT, NULL, &_tmp16_);
		_tmp17_ = (*_tmp13_).sensitive;
		dbus_message_iter_append_basic (&_tmp16_, DBUS_TYPE_BOOLEAN, &_tmp17_);
		_tmp18_ = (*_tmp13_).comment;
		dbus_message_iter_append_basic (&_tmp16_, DBUS_TYPE_STRING, &_tmp18_);
		dbus_message_iter_close_container (&_tmp14_, &_tmp16_);
		_tmp13_++;
	}
	dbus_message_iter_close_container (&iter, &_tmp14_);
	result = (_vala_UnityPlace_BrowsingState_array_free (result,  result_length1), NULL);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult unity_place_browser_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_unity_place_browser_service_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_unity_place_browser_service_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceBrowser", "GoBack")) {
		result = _dbus_unity_place_browser_service_go_back (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceBrowser", "GoForward")) {
		result = _dbus_unity_place_browser_service_go_forward (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceBrowser", "GetState")) {
		result = _dbus_unity_place_browser_service_get_state (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


void unity_place_browser_service_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_unity_place_browser_service_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
}


static void unity_place_browser_service_base_init (UnityPlaceBrowserServiceIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_type_set_qdata (UNITY_PLACE_TYPE_BROWSER_SERVICE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_unity_place_browser_service_dbus_vtable));
	}
}


GType unity_place_browser_service_get_type (void) {
	static volatile gsize unity_place_browser_service_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_browser_service_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceBrowserServiceIface), (GBaseInitFunc) unity_place_browser_service_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType unity_place_browser_service_type_id;
		unity_place_browser_service_type_id = g_type_register_static (G_TYPE_INTERFACE, "UnityPlaceBrowserService", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (unity_place_browser_service_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (unity_place_browser_service_type_id, g_quark_from_string ("ValaDBusInterfaceProxyType"), &unity_place_browser_service_dbus_proxy_get_type);
		g_once_init_leave (&unity_place_browser_service_type_id__volatile, unity_place_browser_service_type_id);
	}
	return unity_place_browser_service_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (UnityPlaceBrowserServiceDBusProxy, unity_place_browser_service_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE (UNITY_PLACE_TYPE_BROWSER_SERVICE, unity_place_browser_service_dbus_proxy_unity_place_browser_service__interface_init) );
UnityPlaceBrowserService* unity_place_browser_service_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path) {
	UnityPlaceBrowserService* self;
	self = g_object_new (unity_place_browser_service_dbus_proxy_get_type (), "connection", connection, "name", name, "path", path, "interface", "com.canonical.Unity.PlaceBrowser", NULL);
	return self;
}


static GObject* unity_place_browser_service_dbus_proxy_construct (GType gtype, guint n_properties, GObjectConstructParam* properties) {
	GObject* self;
	DBusGConnection *connection;
	char* path;
	char* filter;
	self = G_OBJECT_CLASS (unity_place_browser_service_dbus_proxy_parent_class)->constructor (gtype, n_properties, properties);
	g_object_get (self, "connection", &connection, NULL);
	g_object_get (self, "path", &path, NULL);
	dbus_connection_add_filter (dbus_g_connection_get_connection (connection), unity_place_browser_service_dbus_proxy_filter, self, NULL);
	filter = g_strdup_printf ("type='signal',path='%s'", path);
	dbus_bus_add_match (dbus_g_connection_get_connection (connection), filter, NULL);
	dbus_g_connection_unref (connection);
	g_free (path);
	g_free (filter);
	return self;
}


DBusHandlerResult unity_place_browser_service_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data) {
	if (dbus_message_has_path (message, dbus_g_proxy_get_path (user_data))) {
	}
	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void unity_place_browser_service_dbus_proxy_dispose (GObject* self) {
	DBusGConnection *connection;
	if (((UnityPlaceBrowserServiceDBusProxy*) self)->disposed) {
		return;
	}
	((UnityPlaceBrowserServiceDBusProxy*) self)->disposed = TRUE;
	g_object_get (self, "connection", &connection, NULL);
	dbus_connection_remove_filter (dbus_g_connection_get_connection (connection), unity_place_browser_service_dbus_proxy_filter, self);
	G_OBJECT_CLASS (unity_place_browser_service_dbus_proxy_parent_class)->dispose (self);
}


static void unity_place_browser_service_dbus_proxy_class_init (UnityPlaceBrowserServiceDBusProxyClass* klass) {
	G_OBJECT_CLASS (klass)->constructor = unity_place_browser_service_dbus_proxy_construct;
	G_OBJECT_CLASS (klass)->dispose = unity_place_browser_service_dbus_proxy_dispose;
	G_OBJECT_CLASS (klass)->get_property = unity_place_browser_service_dbus_proxy_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_browser_service_dbus_proxy_set_property;
}


static void unity_place_browser_service_dbus_proxy_init (UnityPlaceBrowserServiceDBusProxy* self) {
}


static UnityPlace_BrowsingState* unity_place_browser_service_dbus_proxy_go_back (UnityPlaceBrowserService* self, int* result_length1, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	UnityPlace_BrowsingState* _result;
	int _result_length1;
	UnityPlace_BrowsingState* _tmp19_;
	int _tmp19__length;
	int _tmp19__size;
	int _tmp19__length1;
	DBusMessageIter _tmp20_;
	if (((UnityPlaceBrowserServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceBrowser", "GoBack");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp25_;
			_edomain = DBUS_GERROR;
			_tmp25_ = _dbus_error.name + 27;
			if (strcmp (_tmp25_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp25_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp25_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp25_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp25_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp25_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp25_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp25_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp25_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp25_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp25_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp25_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp25_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp25_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp25_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp25_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp25_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp25_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp25_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp25_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp25_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp25_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp25_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp25_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp25_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp25_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp25_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp25_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp25_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp25_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp25_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp25_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp25_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return NULL;
	}
	if (strcmp (dbus_message_get_signature (_reply), "a(bs)")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "a(bs)", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_init (_reply, &_iter);
	_result_length1 = 0;
	_tmp19_ = g_new (UnityPlace_BrowsingState, 5);
	_tmp19__length = 0;
	_tmp19__size = 4;
	_tmp19__length1 = 0;
	dbus_message_iter_recurse (&_iter, &_tmp20_);
	for (; dbus_message_iter_get_arg_type (&_tmp20_); _tmp19__length1++) {
		UnityPlace_BrowsingState _tmp21_;
		DBusMessageIter _tmp22_;
		dbus_bool_t _tmp23_;
		const char* _tmp24_;
		if (_tmp19__size == _tmp19__length) {
			_tmp19__size = 2 * _tmp19__size;
			_tmp19_ = g_renew (UnityPlace_BrowsingState, _tmp19_, _tmp19__size + 1);
		}
		dbus_message_iter_recurse (&_tmp20_, &_tmp22_);
		dbus_message_iter_get_basic (&_tmp22_, &_tmp23_);
		dbus_message_iter_next (&_tmp22_);
		_tmp21_.sensitive = _tmp23_;
		dbus_message_iter_get_basic (&_tmp22_, &_tmp24_);
		dbus_message_iter_next (&_tmp22_);
		_tmp21_.comment = g_strdup (_tmp24_);
		dbus_message_iter_next (&_tmp20_);
		_tmp19_[_tmp19__length++] = _tmp21_;
	}
	_result_length1 = _tmp19__length1;
	dbus_message_iter_next (&_iter);
	_result = _tmp19_;
	*result_length1 = _result_length1;
	dbus_message_unref (_reply);
	return _result;
}


static UnityPlace_BrowsingState* unity_place_browser_service_dbus_proxy_go_forward (UnityPlaceBrowserService* self, int* result_length1, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	UnityPlace_BrowsingState* _result;
	int _result_length1;
	UnityPlace_BrowsingState* _tmp26_;
	int _tmp26__length;
	int _tmp26__size;
	int _tmp26__length1;
	DBusMessageIter _tmp27_;
	if (((UnityPlaceBrowserServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceBrowser", "GoForward");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp32_;
			_edomain = DBUS_GERROR;
			_tmp32_ = _dbus_error.name + 27;
			if (strcmp (_tmp32_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp32_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp32_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp32_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp32_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp32_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp32_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp32_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp32_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp32_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp32_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp32_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp32_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp32_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp32_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp32_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp32_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp32_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp32_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp32_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp32_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp32_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp32_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp32_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp32_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp32_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp32_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp32_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp32_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp32_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp32_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp32_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp32_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return NULL;
	}
	if (strcmp (dbus_message_get_signature (_reply), "a(bs)")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "a(bs)", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_init (_reply, &_iter);
	_result_length1 = 0;
	_tmp26_ = g_new (UnityPlace_BrowsingState, 5);
	_tmp26__length = 0;
	_tmp26__size = 4;
	_tmp26__length1 = 0;
	dbus_message_iter_recurse (&_iter, &_tmp27_);
	for (; dbus_message_iter_get_arg_type (&_tmp27_); _tmp26__length1++) {
		UnityPlace_BrowsingState _tmp28_;
		DBusMessageIter _tmp29_;
		dbus_bool_t _tmp30_;
		const char* _tmp31_;
		if (_tmp26__size == _tmp26__length) {
			_tmp26__size = 2 * _tmp26__size;
			_tmp26_ = g_renew (UnityPlace_BrowsingState, _tmp26_, _tmp26__size + 1);
		}
		dbus_message_iter_recurse (&_tmp27_, &_tmp29_);
		dbus_message_iter_get_basic (&_tmp29_, &_tmp30_);
		dbus_message_iter_next (&_tmp29_);
		_tmp28_.sensitive = _tmp30_;
		dbus_message_iter_get_basic (&_tmp29_, &_tmp31_);
		dbus_message_iter_next (&_tmp29_);
		_tmp28_.comment = g_strdup (_tmp31_);
		dbus_message_iter_next (&_tmp27_);
		_tmp26_[_tmp26__length++] = _tmp28_;
	}
	_result_length1 = _tmp26__length1;
	dbus_message_iter_next (&_iter);
	_result = _tmp26_;
	*result_length1 = _result_length1;
	dbus_message_unref (_reply);
	return _result;
}


static UnityPlace_BrowsingState* unity_place_browser_service_dbus_proxy_get_state (UnityPlaceBrowserService* self, int* result_length1, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	UnityPlace_BrowsingState* _result;
	int _result_length1;
	UnityPlace_BrowsingState* _tmp33_;
	int _tmp33__length;
	int _tmp33__size;
	int _tmp33__length1;
	DBusMessageIter _tmp34_;
	if (((UnityPlaceBrowserServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceBrowser", "GetState");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp39_;
			_edomain = DBUS_GERROR;
			_tmp39_ = _dbus_error.name + 27;
			if (strcmp (_tmp39_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp39_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp39_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp39_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp39_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp39_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp39_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp39_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp39_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp39_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp39_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp39_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp39_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp39_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp39_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp39_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp39_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp39_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp39_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp39_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp39_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp39_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp39_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp39_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp39_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp39_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp39_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp39_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp39_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp39_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp39_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp39_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp39_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return NULL;
	}
	if (strcmp (dbus_message_get_signature (_reply), "a(bs)")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "a(bs)", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_init (_reply, &_iter);
	_result_length1 = 0;
	_tmp33_ = g_new (UnityPlace_BrowsingState, 5);
	_tmp33__length = 0;
	_tmp33__size = 4;
	_tmp33__length1 = 0;
	dbus_message_iter_recurse (&_iter, &_tmp34_);
	for (; dbus_message_iter_get_arg_type (&_tmp34_); _tmp33__length1++) {
		UnityPlace_BrowsingState _tmp35_;
		DBusMessageIter _tmp36_;
		dbus_bool_t _tmp37_;
		const char* _tmp38_;
		if (_tmp33__size == _tmp33__length) {
			_tmp33__size = 2 * _tmp33__size;
			_tmp33_ = g_renew (UnityPlace_BrowsingState, _tmp33_, _tmp33__size + 1);
		}
		dbus_message_iter_recurse (&_tmp34_, &_tmp36_);
		dbus_message_iter_get_basic (&_tmp36_, &_tmp37_);
		dbus_message_iter_next (&_tmp36_);
		_tmp35_.sensitive = _tmp37_;
		dbus_message_iter_get_basic (&_tmp36_, &_tmp38_);
		dbus_message_iter_next (&_tmp36_);
		_tmp35_.comment = g_strdup (_tmp38_);
		dbus_message_iter_next (&_tmp34_);
		_tmp33_[_tmp33__length++] = _tmp35_;
	}
	_result_length1 = _tmp33__length1;
	dbus_message_iter_next (&_iter);
	_result = _tmp33_;
	*result_length1 = _result_length1;
	dbus_message_unref (_reply);
	return _result;
}


static void unity_place_browser_service_dbus_proxy_unity_place_browser_service__interface_init (UnityPlaceBrowserServiceIface* iface) {
	iface->go_back = unity_place_browser_service_dbus_proxy_go_back;
	iface->go_forward = unity_place_browser_service_dbus_proxy_go_forward;
	iface->get_state = unity_place_browser_service_dbus_proxy_get_state;
}


static void unity_place_browser_service_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
}


static void unity_place_browser_service_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
}


UnityPlaceBrowserServiceImpl* unity_place_browser_service_impl_construct (GType object_type, const char* dbus_path) {
	UnityPlaceBrowserServiceImpl * self;
	UnityPlace_BrowsingState* _tmp1_;
	gint _tmp0__length1;
	UnityPlace_BrowsingState* _tmp0_;
	g_return_val_if_fail (dbus_path != NULL, NULL);
	self = (UnityPlaceBrowserServiceImpl*) g_object_new (object_type, NULL);
	unity_place_browser_service_impl_set_dbus_path (self, dbus_path);
	_tmp1_ = (_tmp0_ = g_new0 (UnityPlace_BrowsingState, UNITY_PLACE_BROWSING_OP_NUM_OPS), _tmp0__length1 = UNITY_PLACE_BROWSING_OP_NUM_OPS, _tmp0_);
	unity_place_browser_service_impl_set_browsing_state (self, _tmp1_, UNITY_PLACE_BROWSING_OP_NUM_OPS);
	_tmp0_ = (_vala_UnityPlace_BrowsingState_array_free (_tmp0_, _tmp0__length1), NULL);
	return self;
}


UnityPlaceBrowserServiceImpl* unity_place_browser_service_impl_new (const char* dbus_path) {
	return unity_place_browser_service_impl_construct (UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL, dbus_path);
}


static UnityPlace_BrowsingState* _vala_array_dup9 (UnityPlace_BrowsingState* self, int length) {
	UnityPlace_BrowsingState* result;
	int i;
	UnityPlace_BrowsingState _tmp1_ = {0};
	gint _tmp0_;
	result = g_new0 (UnityPlace_BrowsingState, length);
	for (i = 0; i < length; i++) {
		result[i] = (unity_place__browsingstate_copy (&self[i], &_tmp1_), _tmp1_);
	}
	return result;
}


static UnityPlace_BrowsingState* unity_place_browser_service_impl_real_go_back (UnityPlaceBrowserService* base, int* result_length1, GError** error) {
	UnityPlaceBrowserServiceImpl * self;
	UnityPlace_BrowsingState* result = NULL;
	UnityPlace_BrowsingState* _tmp2_;
	UnityPlace_BrowsingState _tmp1_ = {0};
	gint _tmp0_;
	UnityPlace_BrowsingState* _tmp3_;
	self = (UnityPlaceBrowserServiceImpl*) base;
	g_signal_emit_by_name (self, "back");
	result = (_tmp3_ = (_tmp2_ = unity_place_browser_service_impl_get_browsing_state (self, &_tmp0_), (_tmp2_ == NULL) ? ((gpointer) _tmp2_) : _vala_array_dup9 (_tmp2_, _tmp0_)), *result_length1 = _tmp0_, _tmp3_);
	return result;
}


static UnityPlace_BrowsingState* _vala_array_dup10 (UnityPlace_BrowsingState* self, int length) {
	UnityPlace_BrowsingState* result;
	int i;
	UnityPlace_BrowsingState _tmp1_ = {0};
	gint _tmp0_;
	result = g_new0 (UnityPlace_BrowsingState, length);
	for (i = 0; i < length; i++) {
		result[i] = (unity_place__browsingstate_copy (&self[i], &_tmp1_), _tmp1_);
	}
	return result;
}


static UnityPlace_BrowsingState* unity_place_browser_service_impl_real_go_forward (UnityPlaceBrowserService* base, int* result_length1, GError** error) {
	UnityPlaceBrowserServiceImpl * self;
	UnityPlace_BrowsingState* result = NULL;
	UnityPlace_BrowsingState* _tmp2_;
	UnityPlace_BrowsingState _tmp1_ = {0};
	gint _tmp0_;
	UnityPlace_BrowsingState* _tmp3_;
	self = (UnityPlaceBrowserServiceImpl*) base;
	g_signal_emit_by_name (self, "forward");
	result = (_tmp3_ = (_tmp2_ = unity_place_browser_service_impl_get_browsing_state (self, &_tmp0_), (_tmp2_ == NULL) ? ((gpointer) _tmp2_) : _vala_array_dup10 (_tmp2_, _tmp0_)), *result_length1 = _tmp0_, _tmp3_);
	return result;
}


static UnityPlace_BrowsingState* _vala_array_dup11 (UnityPlace_BrowsingState* self, int length) {
	UnityPlace_BrowsingState* result;
	int i;
	UnityPlace_BrowsingState _tmp1_ = {0};
	gint _tmp0_;
	result = g_new0 (UnityPlace_BrowsingState, length);
	for (i = 0; i < length; i++) {
		result[i] = (unity_place__browsingstate_copy (&self[i], &_tmp1_), _tmp1_);
	}
	return result;
}


static UnityPlace_BrowsingState* unity_place_browser_service_impl_real_get_state (UnityPlaceBrowserService* base, int* result_length1, GError** error) {
	UnityPlaceBrowserServiceImpl * self;
	UnityPlace_BrowsingState* result = NULL;
	UnityPlace_BrowsingState* _tmp2_;
	UnityPlace_BrowsingState _tmp1_ = {0};
	gint _tmp0_;
	UnityPlace_BrowsingState* _tmp3_;
	self = (UnityPlaceBrowserServiceImpl*) base;
	result = (_tmp3_ = (_tmp2_ = unity_place_browser_service_impl_get_browsing_state (self, &_tmp0_), (_tmp2_ == NULL) ? ((gpointer) _tmp2_) : _vala_array_dup11 (_tmp2_, _tmp0_)), *result_length1 = _tmp0_, _tmp3_);
	return result;
}


const char* unity_place_browser_service_impl_get_dbus_path (UnityPlaceBrowserServiceImpl* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_dbus_path;
	return result;
}


static void unity_place_browser_service_impl_set_dbus_path (UnityPlaceBrowserServiceImpl* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_dbus_path = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_dbus_path), _tmp0_);
	g_object_notify ((GObject *) self, "dbus-path");
}


UnityPlace_BrowsingState* unity_place_browser_service_impl_get_browsing_state (UnityPlaceBrowserServiceImpl* self, int* result_length1) {
	UnityPlace_BrowsingState* result;
	UnityPlace_BrowsingState* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	result = (_tmp0_ = self->priv->_browsing_state, *result_length1 = self->priv->_browsing_state_length1, _tmp0_);
	return result;
}


static UnityPlace_BrowsingState* _vala_array_dup12 (UnityPlace_BrowsingState* self, int length) {
	UnityPlace_BrowsingState* result;
	int i;
	UnityPlace_BrowsingState _tmp1_ = {0};
	result = g_new0 (UnityPlace_BrowsingState, length);
	for (i = 0; i < length; i++) {
		result[i] = (unity_place__browsingstate_copy (&self[i], &_tmp1_), _tmp1_);
	}
	return result;
}


static void unity_place_browser_service_impl_set_browsing_state (UnityPlaceBrowserServiceImpl* self, UnityPlace_BrowsingState* value, int value_length1) {
	UnityPlace_BrowsingState* _tmp3_;
	UnityPlace_BrowsingState* _tmp2_;
	UnityPlace_BrowsingState _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	self->priv->_browsing_state = (_tmp3_ = (_tmp2_ = value, (_tmp2_ == NULL) ? ((gpointer) _tmp2_) : _vala_array_dup12 (_tmp2_, value_length1)), self->priv->_browsing_state = (_vala_UnityPlace_BrowsingState_array_free (self->priv->_browsing_state, self->priv->_browsing_state_length1), NULL), self->priv->_browsing_state_length1 = value_length1, self->priv->__browsing_state_size_ = self->priv->_browsing_state_length1, _tmp3_);
}


void _unity_place_browser_service_impl_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_unity_place_browser_service_impl_introspect (UnityPlaceBrowserServiceImpl* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.canonical.Unity.PlaceBrowser\">\n  <method name=\"GoBack\">\n    <arg name=\"result\" type=\"a(bs)\" direction=\"out\"/>\n  </method>\n  <method name=\"GoForward\">\n    <arg name=\"result\" type=\"a(bs)\" direction=\"out\"/>\n  </method>\n  <method name=\"GetState\">\n    <arg name=\"result\" type=\"a(bs)\" direction=\"out\"/>\n  </method>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult unity_place_browser_service_impl_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_unity_place_browser_service_impl_introspect (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else if (unity_place_browser_service_dbus_message (connection, message, object) == DBUS_HANDLER_RESULT_HANDLED) {
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


void unity_place_browser_service_impl_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_unity_place_browser_service_impl_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	unity_place_browser_service_dbus_register_object (connection, path, object);
}


static void unity_place_browser_service_impl_class_init (UnityPlaceBrowserServiceImplClass * klass) {
	unity_place_browser_service_impl_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceBrowserServiceImplPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_browser_service_impl_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_browser_service_impl_set_property;
	G_OBJECT_CLASS (klass)->finalize = unity_place_browser_service_impl_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_BROWSER_SERVICE_IMPL_DBUS_PATH, g_param_spec_string ("dbus-path", "dbus-path", "dbus-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_signal_new ("back", UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("forward", UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_type_set_qdata (UNITY_PLACE_TYPE_BROWSER_SERVICE_IMPL, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_unity_place_browser_service_impl_dbus_vtable));
}


static void unity_place_browser_service_impl_unity_place_browser_service_interface_init (UnityPlaceBrowserServiceIface * iface) {
	unity_place_browser_service_impl_unity_place_browser_service_parent_iface = g_type_interface_peek_parent (iface);
	iface->go_back = unity_place_browser_service_impl_real_go_back;
	iface->go_forward = unity_place_browser_service_impl_real_go_forward;
	iface->get_state = unity_place_browser_service_impl_real_get_state;
}


static void unity_place_browser_service_impl_instance_init (UnityPlaceBrowserServiceImpl * self) {
	self->priv = UNITY_PLACE_BROWSER_SERVICE_IMPL_GET_PRIVATE (self);
}


static void unity_place_browser_service_impl_finalize (GObject* obj) {
	UnityPlaceBrowserServiceImpl * self;
	self = UNITY_PLACE_BROWSER_SERVICE_IMPL (obj);
	_g_free0 (self->priv->_dbus_path);
	self->priv->_browsing_state = (_vala_UnityPlace_BrowsingState_array_free (self->priv->_browsing_state, self->priv->_browsing_state_length1), NULL);
	G_OBJECT_CLASS (unity_place_browser_service_impl_parent_class)->finalize (obj);
}


GType unity_place_browser_service_impl_get_type (void) {
	static volatile gsize unity_place_browser_service_impl_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_browser_service_impl_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceBrowserServiceImplClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_browser_service_impl_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceBrowserServiceImpl), 0, (GInstanceInitFunc) unity_place_browser_service_impl_instance_init, NULL };
		static const GInterfaceInfo unity_place_browser_service_info = { (GInterfaceInitFunc) unity_place_browser_service_impl_unity_place_browser_service_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType unity_place_browser_service_impl_type_id;
		unity_place_browser_service_impl_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceBrowserServiceImpl", &g_define_type_info, 0);
		g_type_add_interface_static (unity_place_browser_service_impl_type_id, UNITY_PLACE_TYPE_BROWSER_SERVICE, &unity_place_browser_service_info);
		g_once_init_leave (&unity_place_browser_service_impl_type_id__volatile, unity_place_browser_service_impl_type_id);
	}
	return unity_place_browser_service_impl_type_id__volatile;
}


static void unity_place_browser_service_impl_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceBrowserServiceImpl * self;
	self = UNITY_PLACE_BROWSER_SERVICE_IMPL (object);
	switch (property_id) {
		case UNITY_PLACE_BROWSER_SERVICE_IMPL_DBUS_PATH:
		g_value_set_string (value, unity_place_browser_service_impl_get_dbus_path (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_browser_service_impl_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceBrowserServiceImpl * self;
	self = UNITY_PLACE_BROWSER_SERVICE_IMPL (object);
	switch (property_id) {
		case UNITY_PLACE_BROWSER_SERVICE_IMPL_DBUS_PATH:
		unity_place_browser_service_impl_set_dbus_path (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _unity_place_browser_go_back_unity_place_browser_service_impl_back (UnityPlaceBrowserServiceImpl* _sender, gpointer self) {
	unity_place_browser_go_back (self);
}


static void _unity_place_browser_go_forward_unity_place_browser_service_impl_forward (UnityPlaceBrowserServiceImpl* _sender, gpointer self) {
	unity_place_browser_go_forward (self);
}


UnityPlaceBrowser* unity_place_browser_construct (GType object_type, GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func, const char* dbus_path) {
	UnityPlaceBrowser * self;
	UnityPlaceBrowserServiceImpl* _tmp0_;
	UnityPlaceStack* _tmp1_;
	UnityPlaceStack* _tmp2_;
	g_return_val_if_fail (dbus_path != NULL, NULL);
	self = (UnityPlaceBrowser*) g_object_new (object_type, NULL);
	self->priv->e_type = e_type;
	self->priv->e_dup_func = e_dup_func;
	self->priv->e_destroy_func = e_destroy_func;
	unity_place_browser_set_dbus_path (self, dbus_path);
	self->priv->service = (_tmp0_ = unity_place_browser_service_impl_new (dbus_path), _g_object_unref0 (self->priv->service), _tmp0_);
	self->priv->back_stack = (_tmp1_ = unity_place_stack_new (UNITY_PLACE_TYPE_STATE, (GBoxedCopyFunc) unity_place_state_ref, unity_place_state_unref), _unity_place_stack_unref0 (self->priv->back_stack), _tmp1_);
	self->priv->forward_stack = (_tmp2_ = unity_place_stack_new (UNITY_PLACE_TYPE_STATE, (GBoxedCopyFunc) unity_place_state_ref, unity_place_state_unref), _unity_place_stack_unref0 (self->priv->forward_stack), _tmp2_);
	g_signal_connect_object (self->priv->service, "back", (GCallback) _unity_place_browser_go_back_unity_place_browser_service_impl_back, self, 0);
	g_signal_connect_object (self->priv->service, "forward", (GCallback) _unity_place_browser_go_forward_unity_place_browser_service_impl_forward, self, 0);
	unity_place_browser_update_service_state (self);
	return self;
}


UnityPlaceBrowser* unity_place_browser_new (GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func, const char* dbus_path) {
	return unity_place_browser_construct (UNITY_PLACE_TYPE_BROWSER, e_type, e_dup_func, e_destroy_func, dbus_path);
}


static gpointer _unity_place_state_ref0 (gpointer self) {
	return self ? unity_place_state_ref (self) : NULL;
}


void unity_place_browser_record_state (UnityPlaceBrowser* self, gconstpointer state, const char* comment) {
	UnityPlaceState* s;
	gpointer _tmp2_;
	gconstpointer _tmp1_;
	char* _tmp3_;
	UnityPlaceState* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (comment != NULL);
	if (self->priv->current_state != NULL) {
		UnityPlaceStack* _tmp0_;
		_tmp0_ = unity_place_stack_push (self->priv->back_stack, self->priv->current_state);
		_unity_place_stack_unref0 (_tmp0_);
	}
	s = unity_place_state_new (self->priv->e_type, (GBoxedCopyFunc) self->priv->e_dup_func, self->priv->e_destroy_func);
	s->state = (_tmp2_ = (_tmp1_ = state, ((_tmp1_ == NULL) || (self->priv->e_dup_func == NULL)) ? ((gpointer) _tmp1_) : self->priv->e_dup_func ((gpointer) _tmp1_)), ((s->state == NULL) || (self->priv->e_destroy_func == NULL)) ? NULL : (s->state = (self->priv->e_destroy_func (s->state), NULL)), _tmp2_);
	s->comment = (_tmp3_ = g_strdup (comment), _g_free0 (s->comment), _tmp3_);
	self->priv->current_state = (_tmp4_ = _unity_place_state_ref0 (s), _unity_place_state_unref0 (self->priv->current_state), _tmp4_);
	unity_place_browser_update_service_state (self);
	_unity_place_state_unref0 (s);
}


void unity_place_browser_clear (UnityPlaceBrowser* self) {
	UnityPlaceState* _tmp0_;
	g_return_if_fail (self != NULL);
	unity_place_stack_clear (self->priv->back_stack);
	unity_place_stack_clear (self->priv->forward_stack);
	self->priv->current_state = (_tmp0_ = NULL, _unity_place_state_unref0 (self->priv->current_state), _tmp0_);
}


void unity_place_browser_go_back (UnityPlaceBrowser* self) {
	UnityPlaceState* state;
	g_return_if_fail (self != NULL);
	state = (UnityPlaceState*) unity_place_stack_pop (self->priv->back_stack);
	if (state != NULL) {
		UnityPlaceState* _tmp1_;
		if (self->priv->current_state != NULL) {
			UnityPlaceStack* _tmp0_;
			_tmp0_ = unity_place_stack_push (self->priv->forward_stack, self->priv->current_state);
			_unity_place_stack_unref0 (_tmp0_);
		}
		self->priv->current_state = (_tmp1_ = _unity_place_state_ref0 (state), _unity_place_state_unref0 (self->priv->current_state), _tmp1_);
		unity_place_browser_update_service_state (self);
		g_signal_emit_by_name (self, "back", state->state, state->comment);
	}
	_unity_place_state_unref0 (state);
}


void unity_place_browser_go_forward (UnityPlaceBrowser* self) {
	UnityPlaceState* state;
	g_return_if_fail (self != NULL);
	state = (UnityPlaceState*) unity_place_stack_pop (self->priv->forward_stack);
	if (state != NULL) {
		if (self->priv->current_state != NULL) {
			UnityPlaceStack* _tmp0_;
			_tmp0_ = unity_place_stack_push (self->priv->back_stack, self->priv->current_state);
			_unity_place_stack_unref0 (_tmp0_);
		}
		unity_place_browser_update_service_state (self);
		g_signal_emit_by_name (self, "forward", state->state, state->comment);
	}
	_unity_place_state_unref0 (state);
}


static void unity_place_browser_update_service_state (UnityPlaceBrowser* self) {
	gint _tmp0_;
	const char* _tmp1_;
	char* _tmp5_;
	char* *_tmp4_;
	gint _tmp3_;
	gint _tmp6_;
	const char* _tmp7_;
	char* _tmp11_;
	char* *_tmp10_;
	gint _tmp9_;
	g_return_if_fail (self != NULL);
	unity_place_browser_service_impl_get_browsing_state (self->priv->service, &_tmp0_)[UNITY_PLACE_BROWSING_OP_BACK].sensitive = !unity_place_stack_is_empty (self->priv->back_stack);
	_tmp1_ = NULL;
	if (unity_place_stack_is_empty (self->priv->back_stack)) {
		_tmp1_ = "";
	} else {
		UnityPlaceState* _tmp2_;
		_tmp1_ = (_tmp2_ = (UnityPlaceState*) unity_place_stack_peek (self->priv->back_stack))->comment;
		_unity_place_state_unref0 (_tmp2_);
	}
	_tmp4_ = &unity_place_browser_service_impl_get_browsing_state (self->priv->service, &_tmp3_)[UNITY_PLACE_BROWSING_OP_BACK].comment;
	(*_tmp4_) = (_tmp5_ = g_strdup (_tmp1_), _g_free0 ((*_tmp4_)), _tmp5_);
	unity_place_browser_service_impl_get_browsing_state (self->priv->service, &_tmp6_)[UNITY_PLACE_BROWSING_OP_FORWARD].sensitive = !unity_place_stack_is_empty (self->priv->forward_stack);
	_tmp7_ = NULL;
	if (unity_place_stack_is_empty (self->priv->forward_stack)) {
		_tmp7_ = "";
	} else {
		UnityPlaceState* _tmp8_;
		_tmp7_ = (_tmp8_ = (UnityPlaceState*) unity_place_stack_peek (self->priv->forward_stack))->comment;
		_unity_place_state_unref0 (_tmp8_);
	}
	_tmp10_ = &unity_place_browser_service_impl_get_browsing_state (self->priv->service, &_tmp9_)[UNITY_PLACE_BROWSING_OP_FORWARD].comment;
	(*_tmp10_) = (_tmp11_ = g_strdup (_tmp7_), _g_free0 ((*_tmp10_)), _tmp11_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


UnityPlaceBrowserService* unity_place_browser_get_service (UnityPlaceBrowser* self) {
	UnityPlaceBrowserService* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = _g_object_ref0 ((UnityPlaceBrowserService*) self->priv->service);
	return result;
}


const char* unity_place_browser_get_dbus_path (UnityPlaceBrowser* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_dbus_path;
	return result;
}


static void unity_place_browser_set_dbus_path (UnityPlaceBrowser* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_dbus_path = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_dbus_path), _tmp0_);
	g_object_notify ((GObject *) self, "dbus-path");
}


static void unity_place_browser_class_init (UnityPlaceBrowserClass * klass) {
	unity_place_browser_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceBrowserPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_browser_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_browser_set_property;
	G_OBJECT_CLASS (klass)->finalize = unity_place_browser_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_BROWSER_E_TYPE, g_param_spec_gtype ("e-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_BROWSER_E_DUP_FUNC, g_param_spec_pointer ("e-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_BROWSER_E_DESTROY_FUNC, g_param_spec_pointer ("e-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_BROWSER_DBUS_PATH, g_param_spec_string ("dbus-path", "dbus-path", "dbus-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_signal_new ("back", UNITY_PLACE_TYPE_BROWSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__POINTER_STRING, G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_STRING);
	g_signal_new ("forward", UNITY_PLACE_TYPE_BROWSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__POINTER_STRING, G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_STRING);
}


static void unity_place_browser_instance_init (UnityPlaceBrowser * self) {
	self->priv = UNITY_PLACE_BROWSER_GET_PRIVATE (self);
	self->priv->current_state = NULL;
}


static void unity_place_browser_finalize (GObject* obj) {
	UnityPlaceBrowser * self;
	self = UNITY_PLACE_BROWSER (obj);
	_g_object_unref0 (self->priv->service);
	_unity_place_stack_unref0 (self->priv->back_stack);
	_unity_place_stack_unref0 (self->priv->forward_stack);
	_unity_place_state_unref0 (self->priv->current_state);
	_g_free0 (self->priv->_dbus_path);
	G_OBJECT_CLASS (unity_place_browser_parent_class)->finalize (obj);
}


GType unity_place_browser_get_type (void) {
	static volatile gsize unity_place_browser_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_browser_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceBrowserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_browser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceBrowser), 0, (GInstanceInitFunc) unity_place_browser_instance_init, NULL };
		GType unity_place_browser_type_id;
		unity_place_browser_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceBrowser", &g_define_type_info, 0);
		g_once_init_leave (&unity_place_browser_type_id__volatile, unity_place_browser_type_id);
	}
	return unity_place_browser_type_id__volatile;
}


static void unity_place_browser_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceBrowser * self;
	self = UNITY_PLACE_BROWSER (object);
	switch (property_id) {
		case UNITY_PLACE_BROWSER_DBUS_PATH:
		g_value_set_string (value, unity_place_browser_get_dbus_path (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_browser_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceBrowser * self;
	self = UNITY_PLACE_BROWSER (object);
	switch (property_id) {
		case UNITY_PLACE_BROWSER_DBUS_PATH:
		unity_place_browser_set_dbus_path (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
		case UNITY_PLACE_BROWSER_E_TYPE:
		self->priv->e_type = g_value_get_gtype (value);
		break;
		case UNITY_PLACE_BROWSER_E_DUP_FUNC:
		self->priv->e_dup_func = g_value_get_pointer (value);
		break;
		case UNITY_PLACE_BROWSER_E_DESTROY_FUNC:
		self->priv->e_destroy_func = g_value_get_pointer (value);
		break;
	}
}


UnityPlaceState* unity_place_state_construct (GType object_type, GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func) {
	UnityPlaceState* self;
	self = (UnityPlaceState*) g_type_create_instance (object_type);
	self->priv->e_type = e_type;
	self->priv->e_dup_func = e_dup_func;
	self->priv->e_destroy_func = e_destroy_func;
	return self;
}


UnityPlaceState* unity_place_state_new (GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func) {
	return unity_place_state_construct (UNITY_PLACE_TYPE_STATE, e_type, e_dup_func, e_destroy_func);
}


static void unity_place_value_state_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void unity_place_value_state_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		unity_place_state_unref (value->data[0].v_pointer);
	}
}


static void unity_place_value_state_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = unity_place_state_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer unity_place_value_state_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* unity_place_value_state_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		UnityPlaceState* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = unity_place_state_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* unity_place_value_state_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	UnityPlaceState** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = unity_place_state_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* unity_place_param_spec_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	UnityPlaceParamSpecState* spec;
	g_return_val_if_fail (g_type_is_a (object_type, UNITY_PLACE_TYPE_STATE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer unity_place_value_get_state (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_PLACE_TYPE_STATE), NULL);
	return value->data[0].v_pointer;
}


void unity_place_value_set_state (GValue* value, gpointer v_object) {
	UnityPlaceState* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_PLACE_TYPE_STATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_PLACE_TYPE_STATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		unity_place_state_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_place_state_unref (old);
	}
}


void unity_place_value_take_state (GValue* value, gpointer v_object) {
	UnityPlaceState* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_PLACE_TYPE_STATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_PLACE_TYPE_STATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_place_state_unref (old);
	}
}


static void unity_place_state_class_init (UnityPlaceStateClass * klass) {
	unity_place_state_parent_class = g_type_class_peek_parent (klass);
	UNITY_PLACE_STATE_CLASS (klass)->finalize = unity_place_state_finalize;
	g_type_class_add_private (klass, sizeof (UnityPlaceStatePrivate));
}


static void unity_place_state_instance_init (UnityPlaceState * self) {
	self->priv = UNITY_PLACE_STATE_GET_PRIVATE (self);
	self->state = NULL;
	self->comment = NULL;
	self->ref_count = 1;
}


static void unity_place_state_finalize (UnityPlaceState* obj) {
	UnityPlaceState * self;
	self = UNITY_PLACE_STATE (obj);
	((self->state == NULL) || (self->priv->e_destroy_func == NULL)) ? NULL : (self->state = (self->priv->e_destroy_func (self->state), NULL));
	_g_free0 (self->comment);
}


GType unity_place_state_get_type (void) {
	static volatile gsize unity_place_state_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_state_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { unity_place_value_state_init, unity_place_value_state_free_value, unity_place_value_state_copy_value, unity_place_value_state_peek_pointer, "p", unity_place_value_state_collect_value, "p", unity_place_value_state_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceStateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_state_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceState), 0, (GInstanceInitFunc) unity_place_state_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType unity_place_state_type_id;
		unity_place_state_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UnityPlaceState", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&unity_place_state_type_id__volatile, unity_place_state_type_id);
	}
	return unity_place_state_type_id__volatile;
}


gpointer unity_place_state_ref (gpointer instance) {
	UnityPlaceState* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void unity_place_state_unref (gpointer instance) {
	UnityPlaceState* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UNITY_PLACE_STATE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


UnityPlaceStack* unity_place_stack_construct (GType object_type, GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func) {
	UnityPlaceStack* self;
	GeeLinkedList* _tmp0_;
	self = (UnityPlaceStack*) g_type_create_instance (object_type);
	self->priv->e_type = e_type;
	self->priv->e_dup_func = e_dup_func;
	self->priv->e_destroy_func = e_destroy_func;
	self->priv->list = (_tmp0_ = gee_linked_list_new (e_type, (GBoxedCopyFunc) e_dup_func, e_destroy_func, NULL), _g_object_unref0 (self->priv->list), _tmp0_);
	return self;
}


UnityPlaceStack* unity_place_stack_new (GType e_type, GBoxedCopyFunc e_dup_func, GDestroyNotify e_destroy_func) {
	return unity_place_stack_construct (UNITY_PLACE_TYPE_STACK, e_type, e_dup_func, e_destroy_func);
}


static gpointer _unity_place_stack_ref0 (gpointer self) {
	return self ? unity_place_stack_ref (self) : NULL;
}


UnityPlaceStack* unity_place_stack_push (UnityPlaceStack* self, gconstpointer element) {
	UnityPlaceStack* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	gee_deque_offer_head ((GeeDeque*) self->priv->list, element);
	result = _unity_place_stack_ref0 (self);
	return result;
}


gpointer unity_place_stack_pop (UnityPlaceStack* self) {
	gpointer result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = gee_deque_poll_head ((GeeDeque*) self->priv->list);
	return result;
}


gpointer unity_place_stack_peek (UnityPlaceStack* self) {
	gpointer result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = gee_deque_peek_head ((GeeDeque*) self->priv->list);
	return result;
}


gint unity_place_stack_size (UnityPlaceStack* self) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	result = gee_collection_get_size ((GeeCollection*) self->priv->list);
	return result;
}


void unity_place_stack_clear (UnityPlaceStack* self) {
	g_return_if_fail (self != NULL);
	gee_abstract_collection_clear ((GeeAbstractCollection*) self->priv->list);
}


gboolean unity_place_stack_is_empty (UnityPlaceStack* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = unity_place_stack_size (self) == 0;
	return result;
}


static void unity_place_value_stack_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void unity_place_value_stack_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		unity_place_stack_unref (value->data[0].v_pointer);
	}
}


static void unity_place_value_stack_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = unity_place_stack_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer unity_place_value_stack_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* unity_place_value_stack_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		UnityPlaceStack* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = unity_place_stack_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* unity_place_value_stack_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	UnityPlaceStack** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = unity_place_stack_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* unity_place_param_spec_stack (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	UnityPlaceParamSpecStack* spec;
	g_return_val_if_fail (g_type_is_a (object_type, UNITY_PLACE_TYPE_STACK), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer unity_place_value_get_stack (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_PLACE_TYPE_STACK), NULL);
	return value->data[0].v_pointer;
}


void unity_place_value_set_stack (GValue* value, gpointer v_object) {
	UnityPlaceStack* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_PLACE_TYPE_STACK));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_PLACE_TYPE_STACK));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		unity_place_stack_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_place_stack_unref (old);
	}
}


void unity_place_value_take_stack (GValue* value, gpointer v_object) {
	UnityPlaceStack* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_PLACE_TYPE_STACK));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_PLACE_TYPE_STACK));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_place_stack_unref (old);
	}
}


static void unity_place_stack_class_init (UnityPlaceStackClass * klass) {
	unity_place_stack_parent_class = g_type_class_peek_parent (klass);
	UNITY_PLACE_STACK_CLASS (klass)->finalize = unity_place_stack_finalize;
	g_type_class_add_private (klass, sizeof (UnityPlaceStackPrivate));
}


static void unity_place_stack_instance_init (UnityPlaceStack * self) {
	self->priv = UNITY_PLACE_STACK_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void unity_place_stack_finalize (UnityPlaceStack* obj) {
	UnityPlaceStack * self;
	self = UNITY_PLACE_STACK (obj);
	_g_object_unref0 (self->priv->list);
}


GType unity_place_stack_get_type (void) {
	static volatile gsize unity_place_stack_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_stack_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { unity_place_value_stack_init, unity_place_value_stack_free_value, unity_place_value_stack_copy_value, unity_place_value_stack_peek_pointer, "p", unity_place_value_stack_collect_value, "p", unity_place_value_stack_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceStackClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_stack_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceStack), 0, (GInstanceInitFunc) unity_place_stack_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType unity_place_stack_type_id;
		unity_place_stack_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UnityPlaceStack", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&unity_place_stack_type_id__volatile, unity_place_stack_type_id);
	}
	return unity_place_stack_type_id__volatile;
}


gpointer unity_place_stack_ref (gpointer instance) {
	UnityPlaceStack* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void unity_place_stack_unref (gpointer instance) {
	UnityPlaceStack* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UNITY_PLACE_STACK_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



static void g_cclosure_user_marshal_VOID__POINTER_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__POINTER_STRING) (gpointer data1, gpointer arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__POINTER_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__POINTER_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_pointer (param_values + 1), g_value_get_string (param_values + 2), data2);
}



