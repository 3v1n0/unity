/* unity-place.c generated by valac, the Vala compiler
 * generated from unity-place.vala, do not modify */

/*
 * Copyright (C) 2010 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by Mikkel Kamstrup Erlandsen <mikkel.kamstrup@canonical.com>
 *
 */
/*
 * IMPLEMENTATION NOTE:
 * It may appear this code it is bit more bloated than it needs to be
 * (considering the pure number of classes and indirections), but this has
 * some good reasons.
 *
 * Firstly we want to hide away Vala's internal DBus marshalling which would
 * expose raw structs in the API. These structs are hidden away in _RendererInfo,
 * and _EntryInfo. We wrap these in handy GObjects with properties and what not.
 * In fact we want to hide all DBusisms, which is also why the DBus interfaces
 * are declared private.
 *
 * Secondly we want the generatedd C API to be nice and not too Vala-ish. We
 * must anticipate that place daemons consuming libunity will be written in
 * both Vala and C.
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <dee.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <dbus/dbus.h>


#define UNITY_PLACE_TYPE__RENDERERINFO (unity_place__rendererinfo_get_type ())
typedef struct _UnityPlace_RendererInfo UnityPlace_RendererInfo;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define UNITY_PLACE_TYPE_RENDERER_INFO (unity_place_renderer_info_get_type ())
#define UNITY_PLACE_RENDERER_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_RENDERER_INFO, UnityPlaceRendererInfo))
#define UNITY_PLACE_RENDERER_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_RENDERER_INFO, UnityPlaceRendererInfoClass))
#define UNITY_PLACE_IS_RENDERER_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_RENDERER_INFO))
#define UNITY_PLACE_IS_RENDERER_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_RENDERER_INFO))
#define UNITY_PLACE_RENDERER_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_RENDERER_INFO, UnityPlaceRendererInfoClass))

typedef struct _UnityPlaceRendererInfo UnityPlaceRendererInfo;
typedef struct _UnityPlaceRendererInfoClass UnityPlaceRendererInfoClass;
typedef struct _UnityPlaceRendererInfoPrivate UnityPlaceRendererInfoPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define UNITY_PLACE_TYPE_SEARCH (unity_place_search_get_type ())
#define UNITY_PLACE_SEARCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_SEARCH, UnityPlaceSearch))
#define UNITY_PLACE_SEARCH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_SEARCH, UnityPlaceSearchClass))
#define UNITY_PLACE_IS_SEARCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_SEARCH))
#define UNITY_PLACE_IS_SEARCH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_SEARCH))
#define UNITY_PLACE_SEARCH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_SEARCH, UnityPlaceSearchClass))

typedef struct _UnityPlaceSearch UnityPlaceSearch;
typedef struct _UnityPlaceSearchClass UnityPlaceSearchClass;
typedef struct _UnityPlaceSearchPrivate UnityPlaceSearchPrivate;

#define UNITY_PLACE_TYPE__ENTRYINFO (unity_place__entryinfo_get_type ())
typedef struct _UnityPlace_EntryInfo UnityPlace_EntryInfo;

#define UNITY_PLACE_TYPE__ENTRYINFODATA (unity_place__entryinfodata_get_type ())
typedef struct _UnityPlace_EntryInfoData UnityPlace_EntryInfoData;

#define UNITY_PLACE_TYPE_ENTRY_INFO (unity_place_entry_info_get_type ())
#define UNITY_PLACE_ENTRY_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_ENTRY_INFO, UnityPlaceEntryInfo))
#define UNITY_PLACE_ENTRY_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_ENTRY_INFO, UnityPlaceEntryInfoClass))
#define UNITY_PLACE_IS_ENTRY_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_ENTRY_INFO))
#define UNITY_PLACE_IS_ENTRY_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_ENTRY_INFO))
#define UNITY_PLACE_ENTRY_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_ENTRY_INFO, UnityPlaceEntryInfoClass))

typedef struct _UnityPlaceEntryInfo UnityPlaceEntryInfo;
typedef struct _UnityPlaceEntryInfoClass UnityPlaceEntryInfoClass;
typedef struct _UnityPlaceEntryInfoPrivate UnityPlaceEntryInfoPrivate;

#define UNITY_PLACE_TYPE_SERVICE (unity_place_service_get_type ())
#define UNITY_PLACE_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_SERVICE, UnityPlaceService))
#define UNITY_PLACE_IS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_SERVICE))
#define UNITY_PLACE_SERVICE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), UNITY_PLACE_TYPE_SERVICE, UnityPlaceServiceIface))

typedef struct _UnityPlaceService UnityPlaceService;
typedef struct _UnityPlaceServiceIface UnityPlaceServiceIface;
typedef struct _DBusObjectVTable _DBusObjectVTable;
typedef struct _UnityPlaceServiceDBusProxy UnityPlaceServiceDBusProxy;
typedef DBusGProxyClass UnityPlaceServiceDBusProxyClass;

#define UNITY_PLACE_TYPE_ENTRY_SERVICE (unity_place_entry_service_get_type ())
#define UNITY_PLACE_ENTRY_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE, UnityPlaceEntryService))
#define UNITY_PLACE_IS_ENTRY_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE))
#define UNITY_PLACE_ENTRY_SERVICE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE, UnityPlaceEntryServiceIface))

typedef struct _UnityPlaceEntryService UnityPlaceEntryService;
typedef struct _UnityPlaceEntryServiceIface UnityPlaceEntryServiceIface;
typedef struct _UnityPlaceEntryServiceDBusProxy UnityPlaceEntryServiceDBusProxy;
typedef DBusGProxyClass UnityPlaceEntryServiceDBusProxyClass;

#define UNITY_PLACE_TYPE_SERVICE_IMPL (unity_place_service_impl_get_type ())
#define UNITY_PLACE_SERVICE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_SERVICE_IMPL, UnityPlaceServiceImpl))
#define UNITY_PLACE_SERVICE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_SERVICE_IMPL, UnityPlaceServiceImplClass))
#define UNITY_PLACE_IS_SERVICE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_SERVICE_IMPL))
#define UNITY_PLACE_IS_SERVICE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_SERVICE_IMPL))
#define UNITY_PLACE_SERVICE_IMPL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_SERVICE_IMPL, UnityPlaceServiceImplClass))

typedef struct _UnityPlaceServiceImpl UnityPlaceServiceImpl;
typedef struct _UnityPlaceServiceImplClass UnityPlaceServiceImplClass;
typedef struct _UnityPlaceServiceImplPrivate UnityPlaceServiceImplPrivate;

#define UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL (unity_place_entry_service_impl_get_type ())
#define UNITY_PLACE_ENTRY_SERVICE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, UnityPlaceEntryServiceImpl))
#define UNITY_PLACE_ENTRY_SERVICE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, UnityPlaceEntryServiceImplClass))
#define UNITY_PLACE_IS_ENTRY_SERVICE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL))
#define UNITY_PLACE_IS_ENTRY_SERVICE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL))
#define UNITY_PLACE_ENTRY_SERVICE_IMPL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, UnityPlaceEntryServiceImplClass))

typedef struct _UnityPlaceEntryServiceImpl UnityPlaceEntryServiceImpl;
typedef struct _UnityPlaceEntryServiceImplClass UnityPlaceEntryServiceImplClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
typedef struct _UnityPlaceEntryServiceImplPrivate UnityPlaceEntryServiceImplPrivate;

#define UNITY_PLACE_TYPE__ENTRYSIGNALS (unity_place__entrysignals_get_type ())
typedef struct _UnityPlace_EntrySignals UnityPlace_EntrySignals;

#define UNITY_PLACE_TYPE_CONTROLLER (unity_place_controller_get_type ())
#define UNITY_PLACE_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_CONTROLLER, UnityPlaceController))
#define UNITY_PLACE_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_CONTROLLER, UnityPlaceControllerClass))
#define UNITY_PLACE_IS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_CONTROLLER))
#define UNITY_PLACE_IS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_CONTROLLER))
#define UNITY_PLACE_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_CONTROLLER, UnityPlaceControllerClass))

typedef struct _UnityPlaceController UnityPlaceController;
typedef struct _UnityPlaceControllerClass UnityPlaceControllerClass;
typedef struct _UnityPlaceControllerPrivate UnityPlaceControllerPrivate;
typedef struct _Block1Data Block1Data;
#define _unity_place__entrysignals_free0(var) ((var == NULL) ? NULL : (var = (unity_place__entrysignals_free (var), NULL)))

struct _UnityPlace_RendererInfo {
	char* default_renderer;
	char* groups_model;
	char* results_model;
	GHashTable* hints;
};

struct _UnityPlaceRendererInfo {
	GObject parent_instance;
	UnityPlaceRendererInfoPrivate * priv;
};

struct _UnityPlaceRendererInfoClass {
	GObjectClass parent_class;
};

struct _UnityPlaceRendererInfoPrivate {
	UnityPlace_RendererInfo* info;
	DeeModel* _groups_model;
	DeeModel* _results_model;
};

struct _UnityPlaceSearch {
	GInitiallyUnowned parent_instance;
	UnityPlaceSearchPrivate * priv;
};

struct _UnityPlaceSearchClass {
	GInitiallyUnownedClass parent_class;
};

struct _UnityPlaceSearchPrivate {
	char* search;
	GHashTable* hints;
};

struct _UnityPlace_EntryInfo {
	char* dbus_path;
	char* display_name;
	char* icon;
	guint position;
	char** mimetypes;
	gint mimetypes_length1;
	gint _mimetypes_size_;
	gboolean sensitive;
	char* sections_model;
	GHashTable* hints;
	UnityPlace_RendererInfo entry_renderer_info;
	UnityPlace_RendererInfo global_renderer_info;
};

struct _UnityPlace_EntryInfoData {
	char* dbus_path;
	char* display_name;
	char* icon;
	guint position;
	char** mimetypes;
	gint mimetypes_length1;
	gint _mimetypes_size_;
	gboolean sensitive;
	char* sections_model;
	GHashTable* hints;
};

struct _UnityPlaceEntryInfo {
	GObject parent_instance;
	UnityPlaceEntryInfoPrivate * priv;
};

struct _UnityPlaceEntryInfoClass {
	GObjectClass parent_class;
};

struct _UnityPlaceEntryInfoPrivate {
	UnityPlace_EntryInfo info;
	UnityPlaceRendererInfo* _entry_renderer_info;
	UnityPlaceRendererInfo* _global_renderer_info;
	DeeModel* _sections_model;
	gboolean _active;
	guint _active_section;
	UnityPlaceSearch* _active_search;
	UnityPlaceSearch* _active_global_search;
};

struct _UnityPlaceServiceIface {
	GTypeInterface parent_iface;
	UnityPlace_EntryInfo* (*get_entries) (UnityPlaceService* self, int* result_length1, GError** error);
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};

struct _UnityPlaceServiceDBusProxy {
	DBusGProxy parent_instance;
	gboolean disposed;
};

struct _UnityPlaceEntryServiceIface {
	GTypeInterface parent_iface;
	void (*set_global_search) (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
	void (*set_search) (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
	void (*set_active) (UnityPlaceEntryService* self, gboolean is_active, GError** error);
	void (*set_active_section) (UnityPlaceEntryService* self, guint section_id, GError** error);
};

struct _UnityPlaceEntryServiceDBusProxy {
	DBusGProxy parent_instance;
	gboolean disposed;
};

struct _UnityPlaceServiceImpl {
	GObject parent_instance;
	UnityPlaceServiceImplPrivate * priv;
};

struct _UnityPlaceServiceImplClass {
	GObjectClass parent_class;
};

struct _UnityPlaceServiceImplPrivate {
	char* _dbus_path;
	GHashTable* entries;
	gboolean _exported;
};

struct _UnityPlaceEntryServiceImpl {
	GObject parent_instance;
	UnityPlaceEntryServiceImplPrivate * priv;
};

struct _UnityPlaceEntryServiceImplClass {
	GObjectClass parent_class;
};

struct _UnityPlaceEntryServiceImplPrivate {
	gboolean _exported;
	UnityPlaceEntryInfo* _entry_info;
};

struct _UnityPlace_EntrySignals {
	gulong place_entry_info_changed_id;
	gulong entry_renderer_info_changed_id;
	gulong global_renderer_info_changed_id;
};

struct _UnityPlaceController {
	GObject parent_instance;
	UnityPlaceControllerPrivate * priv;
};

struct _UnityPlaceControllerClass {
	GObjectClass parent_class;
};

struct _UnityPlaceControllerPrivate {
	UnityPlaceServiceImpl* service;
	char* _dbus_path;
	gboolean _exported;
	GHashTable* entry_signals;
};

struct _Block1Data {
	int _ref_count_;
	UnityPlaceController * self;
	UnityPlaceEntryInfo* entry;
};


static gpointer unity_place_renderer_info_parent_class = NULL;
static gpointer unity_place_search_parent_class = NULL;
static gpointer unity_place_entry_info_parent_class = NULL;
static gpointer unity_place_service_impl_parent_class = NULL;
static UnityPlaceServiceIface* unity_place_service_impl_unity_place_service_parent_iface = NULL;
static gpointer unity_place_entry_service_impl_parent_class = NULL;
static UnityPlaceEntryServiceIface* unity_place_entry_service_impl_unity_place_entry_service_parent_iface = NULL;
static gpointer unity_place_controller_parent_class = NULL;

GType unity_place__rendererinfo_get_type (void) G_GNUC_CONST;
UnityPlace_RendererInfo* unity_place__rendererinfo_dup (const UnityPlace_RendererInfo* self);
void unity_place__rendererinfo_free (UnityPlace_RendererInfo* self);
void unity_place__rendererinfo_copy (const UnityPlace_RendererInfo* self, UnityPlace_RendererInfo* dest);
void unity_place__rendererinfo_destroy (UnityPlace_RendererInfo* self);
GType unity_place_renderer_info_get_type (void) G_GNUC_CONST;
#define UNITY_PLACE_RENDERER_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_RENDERER_INFO, UnityPlaceRendererInfoPrivate))
enum  {
	UNITY_PLACE_RENDERER_INFO_DUMMY_PROPERTY,
	UNITY_PLACE_RENDERER_INFO_DEFAULT_RENDERER,
	UNITY_PLACE_RENDERER_INFO_GROUPS_MODEL,
	UNITY_PLACE_RENDERER_INFO_RESULTS_MODEL
};
UnityPlaceRendererInfo* unity_place_renderer_info_new (UnityPlace_RendererInfo* info);
UnityPlaceRendererInfo* unity_place_renderer_info_construct (GType object_type, UnityPlace_RendererInfo* info);
void unity_place_renderer_info_set_hint (UnityPlaceRendererInfo* self, const char* hint, const char* val);
char* unity_place_renderer_info_get_hint (UnityPlaceRendererInfo* self, const char* hint);
void unity_place_renderer_info_clear_hint (UnityPlaceRendererInfo* self, const char* hint);
void unity_place_renderer_info_clear_hints (UnityPlaceRendererInfo* self);
guint unity_place_renderer_info_num_hints (UnityPlaceRendererInfo* self);
void unity_place_renderer_info_get_raw (UnityPlaceRendererInfo* self, UnityPlace_RendererInfo* result);
const char* unity_place_renderer_info_get_default_renderer (UnityPlaceRendererInfo* self);
void unity_place_renderer_info_set_default_renderer (UnityPlaceRendererInfo* self, const char* value);
DeeModel* unity_place_renderer_info_get_groups_model (UnityPlaceRendererInfo* self);
void unity_place_renderer_info_set_groups_model (UnityPlaceRendererInfo* self, DeeModel* value);
DeeModel* unity_place_renderer_info_get_results_model (UnityPlaceRendererInfo* self);
void unity_place_renderer_info_set_results_model (UnityPlaceRendererInfo* self, DeeModel* value);
static void unity_place_renderer_info_finalize (GObject* obj);
static void unity_place_renderer_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_renderer_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_place_search_get_type (void) G_GNUC_CONST;
#define UNITY_PLACE_SEARCH_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_SEARCH, UnityPlaceSearchPrivate))
enum  {
	UNITY_PLACE_SEARCH_DUMMY_PROPERTY
};
UnityPlaceSearch* unity_place_search_new (const char* search, GHashTable* hints);
UnityPlaceSearch* unity_place_search_construct (GType object_type, const char* search, GHashTable* hints);
char* unity_place_search_get_search_string (UnityPlaceSearch* self);
void unity_place_search_set_hint (UnityPlaceSearch* self, const char* hint, const char* val);
char* unity_place_search_get_hint (UnityPlaceSearch* self, const char* hint);
void unity_place_search_clear_hint (UnityPlaceSearch* self, const char* hint);
void unity_place_search_clear_hints (UnityPlaceSearch* self);
guint unity_place_search_num_hints (UnityPlaceSearch* self);
static void unity_place_search_finalize (GObject* obj);
GType unity_place__entryinfo_get_type (void) G_GNUC_CONST;
UnityPlace_EntryInfo* unity_place__entryinfo_dup (const UnityPlace_EntryInfo* self);
void unity_place__entryinfo_free (UnityPlace_EntryInfo* self);
void unity_place__entryinfo_copy (const UnityPlace_EntryInfo* self, UnityPlace_EntryInfo* dest);
void unity_place__entryinfo_destroy (UnityPlace_EntryInfo* self);
static char** _vala_array_dup4 (char** self, int length);
GType unity_place__entryinfodata_get_type (void) G_GNUC_CONST;
UnityPlace_EntryInfoData* unity_place__entryinfodata_dup (const UnityPlace_EntryInfoData* self);
void unity_place__entryinfodata_free (UnityPlace_EntryInfoData* self);
void unity_place__entryinfodata_copy (const UnityPlace_EntryInfoData* self, UnityPlace_EntryInfoData* dest);
void unity_place__entryinfodata_destroy (UnityPlace_EntryInfoData* self);
static char** _vala_array_dup5 (char** self, int length);
GType unity_place_entry_info_get_type (void) G_GNUC_CONST;
#define UNITY_PLACE_ENTRY_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_ENTRY_INFO, UnityPlaceEntryInfoPrivate))
enum  {
	UNITY_PLACE_ENTRY_INFO_DUMMY_PROPERTY,
	UNITY_PLACE_ENTRY_INFO_ENTRY_RENDERER_INFO,
	UNITY_PLACE_ENTRY_INFO_GLOBAL_RENDERER_INFO,
	UNITY_PLACE_ENTRY_INFO_DBUS_PATH,
	UNITY_PLACE_ENTRY_INFO_DISPLAY_NAME,
	UNITY_PLACE_ENTRY_INFO_ICON,
	UNITY_PLACE_ENTRY_INFO_POSITION,
	UNITY_PLACE_ENTRY_INFO_MIMETYPES,
	UNITY_PLACE_ENTRY_INFO_SENSITIVE,
	UNITY_PLACE_ENTRY_INFO_SECTIONS_MODEL,
	UNITY_PLACE_ENTRY_INFO_ACTIVE,
	UNITY_PLACE_ENTRY_INFO_ACTIVE_SECTION,
	UNITY_PLACE_ENTRY_INFO_ACTIVE_SEARCH,
	UNITY_PLACE_ENTRY_INFO_ACTIVE_GLOBAL_SEARCH
};
UnityPlaceEntryInfo* unity_place_entry_info_new (const char* dbus_path);
UnityPlaceEntryInfo* unity_place_entry_info_construct (GType object_type, const char* dbus_path);
void unity_place_entry_info_set_hint (UnityPlaceEntryInfo* self, const char* hint, const char* val);
char* unity_place_entry_info_get_hint (UnityPlaceEntryInfo* self, const char* hint);
void unity_place_entry_info_clear_hint (UnityPlaceEntryInfo* self, const char* hint);
void unity_place_entry_info_clear_hints (UnityPlaceEntryInfo* self);
guint unity_place_entry_info_num_hints (UnityPlaceEntryInfo* self);
void unity_place_entry_info_get_raw (UnityPlaceEntryInfo* self, UnityPlace_EntryInfo* result);
UnityPlaceRendererInfo* unity_place_entry_info_get_entry_renderer_info (UnityPlaceEntryInfo* self);
UnityPlaceRendererInfo* unity_place_entry_info_get_global_renderer_info (UnityPlaceEntryInfo* self);
const char* unity_place_entry_info_get_dbus_path (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_dbus_path (UnityPlaceEntryInfo* self, const char* value);
const char* unity_place_entry_info_get_display_name (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_display_name (UnityPlaceEntryInfo* self, const char* value);
const char* unity_place_entry_info_get_icon (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_icon (UnityPlaceEntryInfo* self, const char* value);
guint unity_place_entry_info_get_position (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_position (UnityPlaceEntryInfo* self, guint value);
char** unity_place_entry_info_get_mimetypes (UnityPlaceEntryInfo* self, int* result_length1);
static char** _vala_array_dup6 (char** self, int length);
void unity_place_entry_info_set_mimetypes (UnityPlaceEntryInfo* self, char** value, int value_length1);
gboolean unity_place_entry_info_get_sensitive (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_sensitive (UnityPlaceEntryInfo* self, gboolean value);
DeeModel* unity_place_entry_info_get_sections_model (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_sections_model (UnityPlaceEntryInfo* self, DeeModel* value);
gboolean unity_place_entry_info_get_active (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_active (UnityPlaceEntryInfo* self, gboolean value);
guint unity_place_entry_info_get_active_section (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_active_section (UnityPlaceEntryInfo* self, guint value);
UnityPlaceSearch* unity_place_entry_info_get_active_search (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_active_search (UnityPlaceEntryInfo* self, UnityPlaceSearch* value);
UnityPlaceSearch* unity_place_entry_info_get_active_global_search (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_active_global_search (UnityPlaceEntryInfo* self, UnityPlaceSearch* value);
static GObject * unity_place_entry_info_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_place_entry_info_finalize (GObject* obj);
static void unity_place_entry_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_entry_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
UnityPlaceService* unity_place_service_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path);
GType unity_place_service_get_type (void) G_GNUC_CONST;
UnityPlace_EntryInfo* unity_place_service_get_entries (UnityPlaceService* self, int* result_length1, GError** error);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
void unity_place_service_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _unity_place_service_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult unity_place_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_unity_place_service_introspect (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_service_property_get_all (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message);
static void _vala_UnityPlace_EntryInfo_array_free (UnityPlace_EntryInfo* array, gint array_length);
static DBusHandlerResult _dbus_unity_place_service_get_entries (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_unity_place_service_entry_added (GObject* _sender, UnityPlace_EntryInfo* entry, DBusConnection* _connection);
static void _dbus_unity_place_service_entry_removed (GObject* _sender, const char* entry_dbus_path, DBusConnection* _connection);
GType unity_place_service_dbus_proxy_get_type (void) G_GNUC_CONST;
static void _dbus_handle_unity_place_service_entry_added (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_handle_unity_place_service_entry_removed (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message);
DBusHandlerResult unity_place_service_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
	UNITY_PLACE_SERVICE_DBUS_PROXY_DUMMY_PROPERTY
};
static UnityPlace_EntryInfo* unity_place_service_dbus_proxy_get_entries (UnityPlaceService* self, int* result_length1, GError** error);
static void unity_place_service_dbus_proxy_unity_place_service__interface_init (UnityPlaceServiceIface* iface);
static void unity_place_service_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_service_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
UnityPlaceEntryService* unity_place_entry_service_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path);
GType unity_place_entry_service_get_type (void) G_GNUC_CONST;
void unity_place_entry_service_set_global_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
void unity_place_entry_service_set_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
void unity_place_entry_service_set_active (UnityPlaceEntryService* self, gboolean is_active, GError** error);
void unity_place_entry_service_set_active_section (UnityPlaceEntryService* self, guint section_id, GError** error);
void unity_place_entry_service_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _unity_place_entry_service_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult unity_place_entry_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_unity_place_entry_service_introspect (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_entry_service_property_get_all (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_entry_service_set_global_search (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_entry_service_set_search (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_entry_service_set_active (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_entry_service_set_active_section (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_unity_place_entry_service_entry_renderer_info_changed (GObject* _sender, UnityPlace_RendererInfo* renderer_info, DBusConnection* _connection);
static void _dbus_unity_place_entry_service_global_renderer_info_changed (GObject* _sender, UnityPlace_RendererInfo* renderer_info, DBusConnection* _connection);
static void _dbus_unity_place_entry_service_place_entry_info_changed (GObject* _sender, UnityPlace_EntryInfoData* entry_info_data, DBusConnection* _connection);
GType unity_place_entry_service_dbus_proxy_get_type (void) G_GNUC_CONST;
static void _dbus_handle_unity_place_entry_service_entry_renderer_info_changed (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_handle_unity_place_entry_service_global_renderer_info_changed (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_handle_unity_place_entry_service_place_entry_info_changed (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
DBusHandlerResult unity_place_entry_service_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
	UNITY_PLACE_ENTRY_SERVICE_DBUS_PROXY_DUMMY_PROPERTY
};
static void unity_place_entry_service_dbus_proxy_set_global_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
static void unity_place_entry_service_dbus_proxy_set_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
static void unity_place_entry_service_dbus_proxy_set_active (UnityPlaceEntryService* self, gboolean is_active, GError** error);
static void unity_place_entry_service_dbus_proxy_set_active_section (UnityPlaceEntryService* self, guint section_id, GError** error);
static void unity_place_entry_service_dbus_proxy_unity_place_entry_service__interface_init (UnityPlaceEntryServiceIface* iface);
static void unity_place_entry_service_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_entry_service_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_place_service_impl_get_type (void) G_GNUC_CONST;
GType unity_place_entry_service_impl_get_type (void) G_GNUC_CONST;
#define UNITY_PLACE_SERVICE_IMPL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_SERVICE_IMPL, UnityPlaceServiceImplPrivate))
enum  {
	UNITY_PLACE_SERVICE_IMPL_DUMMY_PROPERTY,
	UNITY_PLACE_SERVICE_IMPL_DBUS_PATH,
	UNITY_PLACE_SERVICE_IMPL_EXPORTED
};
UnityPlaceServiceImpl* unity_place_service_impl_new (const char* dbus_path);
UnityPlaceServiceImpl* unity_place_service_impl_construct (GType object_type, const char* dbus_path);
UnityPlaceEntryInfo* unity_place_entry_service_impl_get_entry_info (UnityPlaceEntryServiceImpl* self);
static UnityPlace_EntryInfo* unity_place_service_impl_real_get_entries (UnityPlaceService* base, int* result_length1, GError** error);
UnityPlaceEntryServiceImpl* unity_place_entry_service_impl_new (UnityPlaceEntryInfo* entry_info);
UnityPlaceEntryServiceImpl* unity_place_entry_service_impl_construct (GType object_type, UnityPlaceEntryInfo* entry_info);
void unity_place_entry_service_impl_export (UnityPlaceEntryServiceImpl* self, GError** error);
void unity_place_service_impl_add_entry (UnityPlaceServiceImpl* self, UnityPlaceEntryInfo* entry_info);
UnityPlaceEntryInfo* unity_place_service_impl_get_entry (UnityPlaceServiceImpl* self, const char* dbus_path);
UnityPlaceEntryServiceImpl* unity_place_service_impl_get_entry_service (UnityPlaceServiceImpl* self, const char* dbus_path);
guint unity_place_service_impl_num_entries (UnityPlaceServiceImpl* self);
char** unity_place_service_impl_get_entry_paths (UnityPlaceServiceImpl* self, int* result_length1);
void unity_place_entry_service_impl_unexport (UnityPlaceEntryServiceImpl* self, GError** error);
void unity_place_service_impl_remove_entry (UnityPlaceServiceImpl* self, const char* dbus_path);
void unity_place_service_impl_export (UnityPlaceServiceImpl* self, GError** error);
void unity_place_service_impl_unexport (UnityPlaceServiceImpl* self, GError** error);
const char* unity_place_service_impl_get_dbus_path (UnityPlaceServiceImpl* self);
static void unity_place_service_impl_set_dbus_path (UnityPlaceServiceImpl* self, const char* value);
gboolean unity_place_service_impl_get_exported (UnityPlaceServiceImpl* self);
static GObject * unity_place_service_impl_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void unity_place_service_impl_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _unity_place_service_impl_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult unity_place_service_impl_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_unity_place_service_impl_introspect (UnityPlaceServiceImpl* self, DBusConnection* connection, DBusMessage* message);
static void unity_place_service_impl_finalize (GObject* obj);
static void unity_place_service_impl_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_service_impl_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define UNITY_PLACE_ENTRY_SERVICE_IMPL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, UnityPlaceEntryServiceImplPrivate))
enum  {
	UNITY_PLACE_ENTRY_SERVICE_IMPL_DUMMY_PROPERTY,
	UNITY_PLACE_ENTRY_SERVICE_IMPL_ENTRY_INFO,
	UNITY_PLACE_ENTRY_SERVICE_IMPL_EXPORTED
};
static void unity_place_entry_service_impl_real_set_global_search (UnityPlaceEntryService* base, const char* search, GHashTable* hints, GError** error);
static void unity_place_entry_service_impl_real_set_search (UnityPlaceEntryService* base, const char* search, GHashTable* hints, GError** error);
static void unity_place_entry_service_impl_real_set_active (UnityPlaceEntryService* base, gboolean is_active, GError** error);
static void unity_place_entry_service_impl_real_set_active_section (UnityPlaceEntryService* base, guint section_id, GError** error);
static void unity_place_entry_service_impl_set_entry_info (UnityPlaceEntryServiceImpl* self, UnityPlaceEntryInfo* value);
gboolean unity_place_entry_service_impl_get_exported (UnityPlaceEntryServiceImpl* self);
void unity_place_entry_service_impl_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _unity_place_entry_service_impl_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult unity_place_entry_service_impl_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_unity_place_entry_service_impl_introspect (UnityPlaceEntryServiceImpl* self, DBusConnection* connection, DBusMessage* message);
static void unity_place_entry_service_impl_finalize (GObject* obj);
static void unity_place_entry_service_impl_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_entry_service_impl_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_place__entrysignals_get_type (void) G_GNUC_CONST;
UnityPlace_EntrySignals* unity_place__entrysignals_dup (const UnityPlace_EntrySignals* self);
void unity_place__entrysignals_free (UnityPlace_EntrySignals* self);
GType unity_place_controller_get_type (void) G_GNUC_CONST;
#define UNITY_PLACE_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_CONTROLLER, UnityPlaceControllerPrivate))
enum  {
	UNITY_PLACE_CONTROLLER_DUMMY_PROPERTY,
	UNITY_PLACE_CONTROLLER_DBUS_PATH,
	UNITY_PLACE_CONTROLLER_EXPORTED
};
UnityPlaceController* unity_place_controller_new (const char* dbus_path);
UnityPlaceController* unity_place_controller_construct (GType object_type, const char* dbus_path);
static void unity_place_controller_on_entry_changed (UnityPlaceController* self, GObject* obj, GParamSpec* psec);
static void _unity_place_controller_on_entry_changed_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void _lambda2_ (GObject* obj, GParamSpec* pspec, Block1Data* _data1_);
static void __lambda2__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void _lambda3_ (GObject* obj, GParamSpec* pspec, Block1Data* _data1_);
static void __lambda3__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
void unity_place_controller_add_entry (UnityPlaceController* self, UnityPlaceEntryInfo* entry);
UnityPlaceEntryInfo* unity_place_controller_get_entry (UnityPlaceController* self, const char* dbus_path);
void unity_place_controller_remove_entry (UnityPlaceController* self, const char* dbus_path);
guint unity_place_controller_num_entries (UnityPlaceController* self);
char** unity_place_controller_get_entry_paths (UnityPlaceController* self, int* result_length1);
UnityPlaceEntryInfo** unity_place_controller_get_entries (UnityPlaceController* self, int* result_length1);
void unity_place_controller_export (UnityPlaceController* self, GError** error);
void unity_place_controller_unexport (UnityPlaceController* self, GError** error);
static char** _vala_array_dup7 (char** self, int length);
const char* unity_place_controller_get_dbus_path (UnityPlaceController* self);
static void unity_place_controller_set_dbus_path (UnityPlaceController* self, const char* value);
gboolean unity_place_controller_get_exported (UnityPlaceController* self);
static GObject * unity_place_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_place_controller_finalize (GObject* obj);
static void unity_place_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const DBusObjectPathVTable _unity_place_service_dbus_path_vtable = {_unity_place_service_dbus_unregister, unity_place_service_dbus_message};
static const _DBusObjectVTable _unity_place_service_dbus_vtable = {unity_place_service_dbus_register_object};
static const DBusObjectPathVTable _unity_place_entry_service_dbus_path_vtable = {_unity_place_entry_service_dbus_unregister, unity_place_entry_service_dbus_message};
static const _DBusObjectVTable _unity_place_entry_service_dbus_vtable = {unity_place_entry_service_dbus_register_object};
static const DBusObjectPathVTable _unity_place_service_impl_dbus_path_vtable = {_unity_place_service_impl_dbus_unregister, unity_place_service_impl_dbus_message};
static const _DBusObjectVTable _unity_place_service_impl_dbus_vtable = {unity_place_service_impl_dbus_register_object};
static const DBusObjectPathVTable _unity_place_entry_service_impl_dbus_path_vtable = {_unity_place_entry_service_impl_dbus_unregister, unity_place_entry_service_impl_dbus_message};
static const _DBusObjectVTable _unity_place_entry_service_impl_dbus_vtable = {unity_place_entry_service_impl_dbus_register_object};

static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


void unity_place__rendererinfo_copy (const UnityPlace_RendererInfo* self, UnityPlace_RendererInfo* dest) {
	dest->default_renderer = g_strdup (self->default_renderer);
	dest->groups_model = g_strdup (self->groups_model);
	dest->results_model = g_strdup (self->results_model);
	dest->hints = _g_hash_table_ref0 (self->hints);
}


void unity_place__rendererinfo_destroy (UnityPlace_RendererInfo* self) {
	_g_free0 (self->default_renderer);
	_g_free0 (self->groups_model);
	_g_free0 (self->results_model);
	_g_hash_table_unref0 (self->hints);
}


UnityPlace_RendererInfo* unity_place__rendererinfo_dup (const UnityPlace_RendererInfo* self) {
	UnityPlace_RendererInfo* dup;
	dup = g_new0 (UnityPlace_RendererInfo, 1);
	unity_place__rendererinfo_copy (self, dup);
	return dup;
}


void unity_place__rendererinfo_free (UnityPlace_RendererInfo* self) {
	unity_place__rendererinfo_destroy (self);
	g_free (self);
}


GType unity_place__rendererinfo_get_type (void) {
	static volatile gsize unity_place__rendererinfo_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place__rendererinfo_type_id__volatile)) {
		GType unity_place__rendererinfo_type_id;
		unity_place__rendererinfo_type_id = g_boxed_type_register_static ("UnityPlace_RendererInfo", (GBoxedCopyFunc) unity_place__rendererinfo_dup, (GBoxedFreeFunc) unity_place__rendererinfo_free);
		g_once_init_leave (&unity_place__rendererinfo_type_id__volatile, unity_place__rendererinfo_type_id);
	}
	return unity_place__rendererinfo_type_id__volatile;
}


UnityPlaceRendererInfo* unity_place_renderer_info_construct (GType object_type, UnityPlace_RendererInfo* info) {
	UnityPlaceRendererInfo * self;
	self = (UnityPlaceRendererInfo*) g_object_new (object_type, NULL);
	self->priv->info = info;
	return self;
}


UnityPlaceRendererInfo* unity_place_renderer_info_new (UnityPlace_RendererInfo* info) {
	return unity_place_renderer_info_construct (UNITY_PLACE_TYPE_RENDERER_INFO, info);
}


void unity_place_renderer_info_set_hint (UnityPlaceRendererInfo* self, const char* hint, const char* val) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (hint != NULL);
	g_return_if_fail (val != NULL);
	g_hash_table_insert ((*self->priv->info).hints, g_strdup (hint), g_strdup (val));
}


char* unity_place_renderer_info_get_hint (UnityPlaceRendererInfo* self, const char* hint) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (hint != NULL, NULL);
	result = g_strdup ((const char*) g_hash_table_lookup ((*self->priv->info).hints, hint));
	return result;
}


void unity_place_renderer_info_clear_hint (UnityPlaceRendererInfo* self, const char* hint) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (hint != NULL);
	g_hash_table_remove ((*self->priv->info).hints, hint);
}


void unity_place_renderer_info_clear_hints (UnityPlaceRendererInfo* self) {
	g_return_if_fail (self != NULL);
	g_hash_table_remove_all ((*self->priv->info).hints);
}


guint unity_place_renderer_info_num_hints (UnityPlaceRendererInfo* self) {
	guint result = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	result = g_hash_table_size ((*self->priv->info).hints);
	return result;
}


void unity_place_renderer_info_get_raw (UnityPlaceRendererInfo* self, UnityPlace_RendererInfo* result) {
	UnityPlace_RendererInfo _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	*result = (unity_place__rendererinfo_copy (self->priv->info, &_tmp0_), _tmp0_);
	return;
}


const char* unity_place_renderer_info_get_default_renderer (UnityPlaceRendererInfo* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = (*self->priv->info).default_renderer;
	return result;
}


void unity_place_renderer_info_set_default_renderer (UnityPlaceRendererInfo* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	(*self->priv->info).default_renderer = (_tmp0_ = g_strdup (value), _g_free0 ((*self->priv->info).default_renderer), _tmp0_);
	g_object_notify ((GObject *) self, "default-renderer");
}


DeeModel* unity_place_renderer_info_get_groups_model (UnityPlaceRendererInfo* self) {
	DeeModel* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_groups_model;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void unity_place_renderer_info_set_groups_model (UnityPlaceRendererInfo* self, DeeModel* value) {
	DeeModel* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_groups_model = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_groups_model), _tmp0_);
	if (DEE_IS_SHARED_MODEL (value)) {
		DeeModel* _tmp1_;
		DeeSharedModel* model;
		char* _tmp2_;
		model = _g_object_ref0 ((_tmp1_ = value, DEE_IS_SHARED_MODEL (_tmp1_) ? ((DeeSharedModel*) _tmp1_) : NULL));
		(*self->priv->info).groups_model = (_tmp2_ = g_strdup (dee_shared_model_get_swarm_name (model)), _g_free0 ((*self->priv->info).groups_model), _tmp2_);
		_g_object_unref0 (model);
	} else {
		char* _tmp3_;
		(*self->priv->info).groups_model = (_tmp3_ = g_strdup ("__local__"), _g_free0 ((*self->priv->info).groups_model), _tmp3_);
	}
	g_object_notify ((GObject *) self, "groups-model");
}


DeeModel* unity_place_renderer_info_get_results_model (UnityPlaceRendererInfo* self) {
	DeeModel* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_results_model;
	return result;
}


void unity_place_renderer_info_set_results_model (UnityPlaceRendererInfo* self, DeeModel* value) {
	DeeModel* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_results_model = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_results_model), _tmp0_);
	if (DEE_IS_SHARED_MODEL (value)) {
		DeeModel* _tmp1_;
		DeeSharedModel* model;
		char* _tmp2_;
		model = _g_object_ref0 ((_tmp1_ = value, DEE_IS_SHARED_MODEL (_tmp1_) ? ((DeeSharedModel*) _tmp1_) : NULL));
		(*self->priv->info).results_model = (_tmp2_ = g_strdup (dee_shared_model_get_swarm_name (model)), _g_free0 ((*self->priv->info).results_model), _tmp2_);
		_g_object_unref0 (model);
	} else {
		char* _tmp3_;
		(*self->priv->info).results_model = (_tmp3_ = g_strdup ("__local__"), _g_free0 ((*self->priv->info).results_model), _tmp3_);
	}
	g_object_notify ((GObject *) self, "results-model");
}


static void unity_place_renderer_info_class_init (UnityPlaceRendererInfoClass * klass) {
	unity_place_renderer_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceRendererInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_renderer_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_renderer_info_set_property;
	G_OBJECT_CLASS (klass)->finalize = unity_place_renderer_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_RENDERER_INFO_DEFAULT_RENDERER, g_param_spec_string ("default-renderer", "default-renderer", "default-renderer", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_RENDERER_INFO_GROUPS_MODEL, g_param_spec_object ("groups-model", "groups-model", "groups-model", DEE_TYPE_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_RENDERER_INFO_RESULTS_MODEL, g_param_spec_object ("results-model", "results-model", "results-model", DEE_TYPE_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void unity_place_renderer_info_instance_init (UnityPlaceRendererInfo * self) {
	self->priv = UNITY_PLACE_RENDERER_INFO_GET_PRIVATE (self);
}


static void unity_place_renderer_info_finalize (GObject* obj) {
	UnityPlaceRendererInfo * self;
	self = UNITY_PLACE_RENDERER_INFO (obj);
	_g_object_unref0 (self->priv->_groups_model);
	_g_object_unref0 (self->priv->_results_model);
	G_OBJECT_CLASS (unity_place_renderer_info_parent_class)->finalize (obj);
}


GType unity_place_renderer_info_get_type (void) {
	static volatile gsize unity_place_renderer_info_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_renderer_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceRendererInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_renderer_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceRendererInfo), 0, (GInstanceInitFunc) unity_place_renderer_info_instance_init, NULL };
		GType unity_place_renderer_info_type_id;
		unity_place_renderer_info_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceRendererInfo", &g_define_type_info, 0);
		g_once_init_leave (&unity_place_renderer_info_type_id__volatile, unity_place_renderer_info_type_id);
	}
	return unity_place_renderer_info_type_id__volatile;
}


static void unity_place_renderer_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceRendererInfo * self;
	self = UNITY_PLACE_RENDERER_INFO (object);
	switch (property_id) {
		case UNITY_PLACE_RENDERER_INFO_DEFAULT_RENDERER:
		g_value_set_string (value, unity_place_renderer_info_get_default_renderer (self));
		break;
		case UNITY_PLACE_RENDERER_INFO_GROUPS_MODEL:
		g_value_set_object (value, unity_place_renderer_info_get_groups_model (self));
		break;
		case UNITY_PLACE_RENDERER_INFO_RESULTS_MODEL:
		g_value_set_object (value, unity_place_renderer_info_get_results_model (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_renderer_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceRendererInfo * self;
	self = UNITY_PLACE_RENDERER_INFO (object);
	switch (property_id) {
		case UNITY_PLACE_RENDERER_INFO_DEFAULT_RENDERER:
		unity_place_renderer_info_set_default_renderer (self, g_value_get_string (value));
		break;
		case UNITY_PLACE_RENDERER_INFO_GROUPS_MODEL:
		unity_place_renderer_info_set_groups_model (self, g_value_get_object (value));
		break;
		case UNITY_PLACE_RENDERER_INFO_RESULTS_MODEL:
		unity_place_renderer_info_set_results_model (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


UnityPlaceSearch* unity_place_search_construct (GType object_type, const char* search, GHashTable* hints) {
	UnityPlaceSearch * self;
	char* _tmp0_;
	GHashTable* _tmp1_;
	g_return_val_if_fail (search != NULL, NULL);
	g_return_val_if_fail (hints != NULL, NULL);
	self = (UnityPlaceSearch*) g_object_new (object_type, NULL);
	self->priv->search = (_tmp0_ = g_strdup (search), _g_free0 (self->priv->search), _tmp0_);
	self->priv->hints = (_tmp1_ = _g_hash_table_ref0 (hints), _g_hash_table_unref0 (self->priv->hints), _tmp1_);
	return self;
}


UnityPlaceSearch* unity_place_search_new (const char* search, GHashTable* hints) {
	return unity_place_search_construct (UNITY_PLACE_TYPE_SEARCH, search, hints);
}


char* unity_place_search_get_search_string (UnityPlaceSearch* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = g_strdup (self->priv->search);
	return result;
}


void unity_place_search_set_hint (UnityPlaceSearch* self, const char* hint, const char* val) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (hint != NULL);
	g_return_if_fail (val != NULL);
	g_hash_table_insert (self->priv->hints, g_strdup (hint), g_strdup (val));
}


char* unity_place_search_get_hint (UnityPlaceSearch* self, const char* hint) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (hint != NULL, NULL);
	result = g_strdup ((const char*) g_hash_table_lookup (self->priv->hints, hint));
	return result;
}


void unity_place_search_clear_hint (UnityPlaceSearch* self, const char* hint) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (hint != NULL);
	g_hash_table_remove (self->priv->hints, hint);
}


void unity_place_search_clear_hints (UnityPlaceSearch* self) {
	g_return_if_fail (self != NULL);
	g_hash_table_remove_all (self->priv->hints);
}


guint unity_place_search_num_hints (UnityPlaceSearch* self) {
	guint result = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	result = g_hash_table_size (self->priv->hints);
	return result;
}


static void unity_place_search_class_init (UnityPlaceSearchClass * klass) {
	unity_place_search_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceSearchPrivate));
	G_OBJECT_CLASS (klass)->finalize = unity_place_search_finalize;
}


static void unity_place_search_instance_init (UnityPlaceSearch * self) {
	self->priv = UNITY_PLACE_SEARCH_GET_PRIVATE (self);
}


static void unity_place_search_finalize (GObject* obj) {
	UnityPlaceSearch * self;
	self = UNITY_PLACE_SEARCH (obj);
	_g_free0 (self->priv->search);
	_g_hash_table_unref0 (self->priv->hints);
	G_OBJECT_CLASS (unity_place_search_parent_class)->finalize (obj);
}


GType unity_place_search_get_type (void) {
	static volatile gsize unity_place_search_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_search_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceSearchClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_search_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceSearch), 0, (GInstanceInitFunc) unity_place_search_instance_init, NULL };
		GType unity_place_search_type_id;
		unity_place_search_type_id = g_type_register_static (G_TYPE_INITIALLY_UNOWNED, "UnityPlaceSearch", &g_define_type_info, 0);
		g_once_init_leave (&unity_place_search_type_id__volatile, unity_place_search_type_id);
	}
	return unity_place_search_type_id__volatile;
}


static char** _vala_array_dup4 (char** self, int length) {
	char** result;
	int i;
	result = g_new0 (char*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


void unity_place__entryinfo_copy (const UnityPlace_EntryInfo* self, UnityPlace_EntryInfo* dest) {
	UnityPlace_RendererInfo _tmp2_ = {0};
	UnityPlace_RendererInfo _tmp1_ = {0};
	char** _tmp0_;
	dest->dbus_path = g_strdup (self->dbus_path);
	dest->display_name = g_strdup (self->display_name);
	dest->icon = g_strdup (self->icon);
	dest->position = self->position;
	dest->mimetypes = (_tmp0_ = self->mimetypes, (_tmp0_ == NULL) ? ((gpointer) _tmp0_) : _vala_array_dup4 (_tmp0_, (*self).mimetypes_length1));
	dest->mimetypes_length1 = self->mimetypes_length1;
	dest->sensitive = self->sensitive;
	dest->sections_model = g_strdup (self->sections_model);
	dest->hints = _g_hash_table_ref0 (self->hints);
	dest->entry_renderer_info = (unity_place__rendererinfo_copy (&self->entry_renderer_info, &_tmp1_), _tmp1_);
	dest->global_renderer_info = (unity_place__rendererinfo_copy (&self->global_renderer_info, &_tmp2_), _tmp2_);
}


void unity_place__entryinfo_destroy (UnityPlace_EntryInfo* self) {
	_g_free0 (self->dbus_path);
	_g_free0 (self->display_name);
	_g_free0 (self->icon);
	self->mimetypes = (_vala_array_free (self->mimetypes, (*self).mimetypes_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (self->sections_model);
	_g_hash_table_unref0 (self->hints);
	unity_place__rendererinfo_destroy (&self->entry_renderer_info);
	unity_place__rendererinfo_destroy (&self->global_renderer_info);
}


UnityPlace_EntryInfo* unity_place__entryinfo_dup (const UnityPlace_EntryInfo* self) {
	UnityPlace_EntryInfo* dup;
	dup = g_new0 (UnityPlace_EntryInfo, 1);
	unity_place__entryinfo_copy (self, dup);
	return dup;
}


void unity_place__entryinfo_free (UnityPlace_EntryInfo* self) {
	unity_place__entryinfo_destroy (self);
	g_free (self);
}


GType unity_place__entryinfo_get_type (void) {
	static volatile gsize unity_place__entryinfo_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place__entryinfo_type_id__volatile)) {
		GType unity_place__entryinfo_type_id;
		unity_place__entryinfo_type_id = g_boxed_type_register_static ("UnityPlace_EntryInfo", (GBoxedCopyFunc) unity_place__entryinfo_dup, (GBoxedFreeFunc) unity_place__entryinfo_free);
		g_once_init_leave (&unity_place__entryinfo_type_id__volatile, unity_place__entryinfo_type_id);
	}
	return unity_place__entryinfo_type_id__volatile;
}


static char** _vala_array_dup5 (char** self, int length) {
	char** result;
	int i;
	result = g_new0 (char*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


void unity_place__entryinfodata_copy (const UnityPlace_EntryInfoData* self, UnityPlace_EntryInfoData* dest) {
	char** _tmp3_;
	dest->dbus_path = g_strdup (self->dbus_path);
	dest->display_name = g_strdup (self->display_name);
	dest->icon = g_strdup (self->icon);
	dest->position = self->position;
	dest->mimetypes = (_tmp3_ = self->mimetypes, (_tmp3_ == NULL) ? ((gpointer) _tmp3_) : _vala_array_dup5 (_tmp3_, (*self).mimetypes_length1));
	dest->mimetypes_length1 = self->mimetypes_length1;
	dest->sensitive = self->sensitive;
	dest->sections_model = g_strdup (self->sections_model);
	dest->hints = _g_hash_table_ref0 (self->hints);
}


void unity_place__entryinfodata_destroy (UnityPlace_EntryInfoData* self) {
	_g_free0 (self->dbus_path);
	_g_free0 (self->display_name);
	_g_free0 (self->icon);
	self->mimetypes = (_vala_array_free (self->mimetypes, (*self).mimetypes_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (self->sections_model);
	_g_hash_table_unref0 (self->hints);
}


UnityPlace_EntryInfoData* unity_place__entryinfodata_dup (const UnityPlace_EntryInfoData* self) {
	UnityPlace_EntryInfoData* dup;
	dup = g_new0 (UnityPlace_EntryInfoData, 1);
	unity_place__entryinfodata_copy (self, dup);
	return dup;
}


void unity_place__entryinfodata_free (UnityPlace_EntryInfoData* self) {
	unity_place__entryinfodata_destroy (self);
	g_free (self);
}


GType unity_place__entryinfodata_get_type (void) {
	static volatile gsize unity_place__entryinfodata_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place__entryinfodata_type_id__volatile)) {
		GType unity_place__entryinfodata_type_id;
		unity_place__entryinfodata_type_id = g_boxed_type_register_static ("UnityPlace_EntryInfoData", (GBoxedCopyFunc) unity_place__entryinfodata_dup, (GBoxedFreeFunc) unity_place__entryinfodata_free);
		g_once_init_leave (&unity_place__entryinfodata_type_id__volatile, unity_place__entryinfodata_type_id);
	}
	return unity_place__entryinfodata_type_id__volatile;
}


UnityPlaceEntryInfo* unity_place_entry_info_construct (GType object_type, const char* dbus_path) {
	UnityPlaceEntryInfo * self;
	char** _tmp0_;
	gint __empty_size_;
	gint _empty_length1;
	char** _empty;
	g_return_val_if_fail (dbus_path != NULL, NULL);
	_empty = (_tmp0_ = g_new0 (char*, 0 + 1), _empty_length1 = 0, __empty_size_ = _empty_length1, _tmp0_);
	self = (UnityPlaceEntryInfo*) g_object_new (object_type, "dbus-path", dbus_path, "mimetypes", _empty, NULL);
	_empty = (_vala_array_free (_empty, _empty_length1, (GDestroyNotify) g_free), NULL);
	return self;
}


UnityPlaceEntryInfo* unity_place_entry_info_new (const char* dbus_path) {
	return unity_place_entry_info_construct (UNITY_PLACE_TYPE_ENTRY_INFO, dbus_path);
}


void unity_place_entry_info_set_hint (UnityPlaceEntryInfo* self, const char* hint, const char* val) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (hint != NULL);
	g_return_if_fail (val != NULL);
	g_hash_table_insert (self->priv->info.hints, g_strdup (hint), g_strdup (val));
}


char* unity_place_entry_info_get_hint (UnityPlaceEntryInfo* self, const char* hint) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (hint != NULL, NULL);
	result = g_strdup ((const char*) g_hash_table_lookup (self->priv->info.hints, hint));
	return result;
}


void unity_place_entry_info_clear_hint (UnityPlaceEntryInfo* self, const char* hint) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (hint != NULL);
	g_hash_table_remove (self->priv->info.hints, hint);
}


void unity_place_entry_info_clear_hints (UnityPlaceEntryInfo* self) {
	g_return_if_fail (self != NULL);
	g_hash_table_remove_all (self->priv->info.hints);
}


guint unity_place_entry_info_num_hints (UnityPlaceEntryInfo* self) {
	guint result = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	result = g_hash_table_size (self->priv->info.hints);
	return result;
}


void unity_place_entry_info_get_raw (UnityPlaceEntryInfo* self, UnityPlace_EntryInfo* result) {
	UnityPlace_EntryInfo _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	*result = (unity_place__entryinfo_copy (&self->priv->info, &_tmp0_), _tmp0_);
	return;
}


UnityPlaceRendererInfo* unity_place_entry_info_get_entry_renderer_info (UnityPlaceEntryInfo* self) {
	UnityPlaceRendererInfo* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_entry_renderer_info;
	return result;
}


UnityPlaceRendererInfo* unity_place_entry_info_get_global_renderer_info (UnityPlaceEntryInfo* self) {
	UnityPlaceRendererInfo* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_global_renderer_info;
	return result;
}


const char* unity_place_entry_info_get_dbus_path (UnityPlaceEntryInfo* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->info.dbus_path;
	return result;
}


void unity_place_entry_info_set_dbus_path (UnityPlaceEntryInfo* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->info.dbus_path = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->info.dbus_path), _tmp0_);
	g_object_notify ((GObject *) self, "dbus-path");
}


const char* unity_place_entry_info_get_display_name (UnityPlaceEntryInfo* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->info.display_name;
	return result;
}


void unity_place_entry_info_set_display_name (UnityPlaceEntryInfo* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->info.display_name = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->info.display_name), _tmp0_);
	g_object_notify ((GObject *) self, "display-name");
}


const char* unity_place_entry_info_get_icon (UnityPlaceEntryInfo* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->info.icon;
	return result;
}


void unity_place_entry_info_set_icon (UnityPlaceEntryInfo* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->info.icon = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->info.icon), _tmp0_);
	g_object_notify ((GObject *) self, "icon");
}


guint unity_place_entry_info_get_position (UnityPlaceEntryInfo* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->info.position;
	return result;
}


void unity_place_entry_info_set_position (UnityPlaceEntryInfo* self, guint value) {
	g_return_if_fail (self != NULL);
	self->priv->info.position = value;
	g_object_notify ((GObject *) self, "position");
}


char** unity_place_entry_info_get_mimetypes (UnityPlaceEntryInfo* self, int* result_length1) {
	char** result;
	char** _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	result = (_tmp0_ = self->priv->info.mimetypes, *result_length1 = self->priv->info.mimetypes_length1, _tmp0_);
	return result;
}


static char** _vala_array_dup6 (char** self, int length) {
	char** result;
	int i;
	result = g_new0 (char*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


void unity_place_entry_info_set_mimetypes (UnityPlaceEntryInfo* self, char** value, int value_length1) {
	char** _tmp2_;
	char** _tmp1_;
	g_return_if_fail (self != NULL);
	self->priv->info.mimetypes = (_tmp2_ = (_tmp1_ = value, (_tmp1_ == NULL) ? ((gpointer) _tmp1_) : _vala_array_dup6 (_tmp1_, value_length1)), self->priv->info.mimetypes = (_vala_array_free (self->priv->info.mimetypes, self->priv->info.mimetypes_length1, (GDestroyNotify) g_free), NULL), self->priv->info.mimetypes_length1 = value_length1, self->priv->info._mimetypes_size_ = self->priv->info.mimetypes_length1, _tmp2_);
	g_object_notify ((GObject *) self, "mimetypes");
}


gboolean unity_place_entry_info_get_sensitive (UnityPlaceEntryInfo* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->info.sensitive;
	return result;
}


void unity_place_entry_info_set_sensitive (UnityPlaceEntryInfo* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->info.sensitive = value;
	g_object_notify ((GObject *) self, "sensitive");
}


DeeModel* unity_place_entry_info_get_sections_model (UnityPlaceEntryInfo* self) {
	DeeModel* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_sections_model;
	return result;
}


void unity_place_entry_info_set_sections_model (UnityPlaceEntryInfo* self, DeeModel* value) {
	DeeModel* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_sections_model = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_sections_model), _tmp0_);
	if (DEE_IS_SHARED_MODEL (value)) {
		DeeModel* _tmp1_;
		DeeSharedModel* model;
		char* _tmp2_;
		model = _g_object_ref0 ((_tmp1_ = value, DEE_IS_SHARED_MODEL (_tmp1_) ? ((DeeSharedModel*) _tmp1_) : NULL));
		self->priv->info.sections_model = (_tmp2_ = g_strdup (dee_shared_model_get_swarm_name (model)), _g_free0 (self->priv->info.sections_model), _tmp2_);
		_g_object_unref0 (model);
	} else {
		char* _tmp3_;
		self->priv->info.sections_model = (_tmp3_ = g_strdup ("__local__"), _g_free0 (self->priv->info.sections_model), _tmp3_);
	}
	g_object_notify ((GObject *) self, "sections-model");
}


gboolean unity_place_entry_info_get_active (UnityPlaceEntryInfo* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_active;
	return result;
}


void unity_place_entry_info_set_active (UnityPlaceEntryInfo* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_active = value;
	g_object_notify ((GObject *) self, "active");
}


guint unity_place_entry_info_get_active_section (UnityPlaceEntryInfo* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_active_section;
	return result;
}


void unity_place_entry_info_set_active_section (UnityPlaceEntryInfo* self, guint value) {
	g_return_if_fail (self != NULL);
	self->priv->_active_section = value;
	g_object_notify ((GObject *) self, "active-section");
}


UnityPlaceSearch* unity_place_entry_info_get_active_search (UnityPlaceEntryInfo* self) {
	UnityPlaceSearch* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_active_search;
	return result;
}


void unity_place_entry_info_set_active_search (UnityPlaceEntryInfo* self, UnityPlaceSearch* value) {
	UnityPlaceSearch* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_active_search = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_active_search), _tmp0_);
	g_object_notify ((GObject *) self, "active-search");
}


UnityPlaceSearch* unity_place_entry_info_get_active_global_search (UnityPlaceEntryInfo* self) {
	UnityPlaceSearch* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_active_global_search;
	return result;
}


void unity_place_entry_info_set_active_global_search (UnityPlaceEntryInfo* self, UnityPlaceSearch* value) {
	UnityPlaceSearch* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_active_global_search = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_active_global_search), _tmp0_);
	g_object_notify ((GObject *) self, "active-global-search");
}


static GObject * unity_place_entry_info_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityPlaceEntryInfo * self;
	parent_class = G_OBJECT_CLASS (unity_place_entry_info_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_PLACE_ENTRY_INFO (obj);
	{
		GHashTable* _tmp10_;
		char* _tmp11_;
		char* _tmp12_;
		char* _tmp13_;
		GHashTable* _tmp14_;
		char* _tmp15_;
		char* _tmp16_;
		char* _tmp17_;
		GHashTable* _tmp18_;
		UnityPlaceRendererInfo* _tmp19_;
		UnityPlaceRendererInfo* _tmp20_;
		if (self->priv->info.dbus_path == NULL) {
			char* _tmp5_;
			g_critical ("unity-place.vala:322: No DBus path set for EntryInfo.\n" \
"'dbus-path' property in the UnityPlaceEntryInfo constructor");
			self->priv->info.dbus_path = (_tmp5_ = g_strdup (""), _g_free0 (self->priv->info.dbus_path), _tmp5_);
		}
		if (self->priv->info.display_name == NULL) {
			char* _tmp6_;
			self->priv->info.display_name = (_tmp6_ = g_strdup (""), _g_free0 (self->priv->info.display_name), _tmp6_);
		}
		if (self->priv->info.icon == NULL) {
			char* _tmp7_;
			self->priv->info.icon = (_tmp7_ = g_strdup (""), _g_free0 (self->priv->info.icon), _tmp7_);
		}
		self->priv->info.position = (guint) 0;
		if (self->priv->info.mimetypes == NULL) {
			char** _tmp8_;
			self->priv->info.mimetypes = (_tmp8_ = g_new0 (char*, 0 + 1), self->priv->info.mimetypes = (_vala_array_free (self->priv->info.mimetypes, self->priv->info.mimetypes_length1, (GDestroyNotify) g_free), NULL), self->priv->info.mimetypes_length1 = 0, self->priv->info._mimetypes_size_ = self->priv->info.mimetypes_length1, _tmp8_);
		}
		self->priv->info.sensitive = TRUE;
		if (self->priv->info.sections_model == NULL) {
			char* _tmp9_;
			self->priv->info.sections_model = (_tmp9_ = g_strdup (""), _g_free0 (self->priv->info.sections_model), _tmp9_);
		}
		self->priv->info.hints = (_tmp10_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free), _g_hash_table_unref0 (self->priv->info.hints), _tmp10_);
		self->priv->info.entry_renderer_info.default_renderer = (_tmp11_ = g_strdup (""), _g_free0 (self->priv->info.entry_renderer_info.default_renderer), _tmp11_);
		self->priv->info.entry_renderer_info.groups_model = (_tmp12_ = g_strdup (""), _g_free0 (self->priv->info.entry_renderer_info.groups_model), _tmp12_);
		self->priv->info.entry_renderer_info.results_model = (_tmp13_ = g_strdup (""), _g_free0 (self->priv->info.entry_renderer_info.results_model), _tmp13_);
		self->priv->info.entry_renderer_info.hints = (_tmp14_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free), _g_hash_table_unref0 (self->priv->info.entry_renderer_info.hints), _tmp14_);
		self->priv->info.global_renderer_info.default_renderer = (_tmp15_ = g_strdup (""), _g_free0 (self->priv->info.global_renderer_info.default_renderer), _tmp15_);
		self->priv->info.global_renderer_info.groups_model = (_tmp16_ = g_strdup (""), _g_free0 (self->priv->info.global_renderer_info.groups_model), _tmp16_);
		self->priv->info.global_renderer_info.results_model = (_tmp17_ = g_strdup (""), _g_free0 (self->priv->info.global_renderer_info.results_model), _tmp17_);
		self->priv->info.global_renderer_info.hints = (_tmp18_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free), _g_hash_table_unref0 (self->priv->info.global_renderer_info.hints), _tmp18_);
		self->priv->_entry_renderer_info = (_tmp19_ = unity_place_renderer_info_new (&self->priv->info.entry_renderer_info), _g_object_unref0 (self->priv->_entry_renderer_info), _tmp19_);
		self->priv->_global_renderer_info = (_tmp20_ = unity_place_renderer_info_new (&self->priv->info.global_renderer_info), _g_object_unref0 (self->priv->_global_renderer_info), _tmp20_);
	}
	return obj;
}


static void unity_place_entry_info_class_init (UnityPlaceEntryInfoClass * klass) {
	unity_place_entry_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceEntryInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_entry_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_entry_info_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_place_entry_info_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_place_entry_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_ENTRY_RENDERER_INFO, g_param_spec_object ("entry-renderer-info", "entry-renderer-info", "entry-renderer-info", UNITY_PLACE_TYPE_RENDERER_INFO, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_GLOBAL_RENDERER_INFO, g_param_spec_object ("global-renderer-info", "global-renderer-info", "global-renderer-info", UNITY_PLACE_TYPE_RENDERER_INFO, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_DBUS_PATH, g_param_spec_string ("dbus-path", "dbus-path", "dbus-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_DISPLAY_NAME, g_param_spec_string ("display-name", "display-name", "display-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_ICON, g_param_spec_string ("icon", "icon", "icon", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_POSITION, g_param_spec_uint ("position", "position", "position", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_MIMETYPES, g_param_spec_boxed ("mimetypes", "mimetypes", "mimetypes", G_TYPE_STRV, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_SENSITIVE, g_param_spec_boolean ("sensitive", "sensitive", "sensitive", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_SECTIONS_MODEL, g_param_spec_object ("sections-model", "sections-model", "sections-model", DEE_TYPE_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_ACTIVE, g_param_spec_boolean ("active", "active", "active", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_ACTIVE_SECTION, g_param_spec_uint ("active-section", "active-section", "active-section", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_ACTIVE_SEARCH, g_param_spec_object ("active-search", "active-search", "active-search", UNITY_PLACE_TYPE_SEARCH, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_ACTIVE_GLOBAL_SEARCH, g_param_spec_object ("active-global-search", "active-global-search", "active-global-search", UNITY_PLACE_TYPE_SEARCH, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void unity_place_entry_info_instance_init (UnityPlaceEntryInfo * self) {
	UnityPlace_EntryInfo _tmp4_ = {0};
	self->priv = UNITY_PLACE_ENTRY_INFO_GET_PRIVATE (self);
	self->priv->info = (memset (&_tmp4_, 0, sizeof (UnityPlace_EntryInfo)), _tmp4_);
	self->priv->_active = FALSE;
	self->priv->_active_section = (guint) 0;
}


static void unity_place_entry_info_finalize (GObject* obj) {
	UnityPlaceEntryInfo * self;
	self = UNITY_PLACE_ENTRY_INFO (obj);
	unity_place__entryinfo_destroy (&self->priv->info);
	_g_object_unref0 (self->priv->_entry_renderer_info);
	_g_object_unref0 (self->priv->_global_renderer_info);
	_g_object_unref0 (self->priv->_sections_model);
	_g_object_unref0 (self->priv->_active_search);
	_g_object_unref0 (self->priv->_active_global_search);
	G_OBJECT_CLASS (unity_place_entry_info_parent_class)->finalize (obj);
}


GType unity_place_entry_info_get_type (void) {
	static volatile gsize unity_place_entry_info_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_entry_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceEntryInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_entry_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceEntryInfo), 0, (GInstanceInitFunc) unity_place_entry_info_instance_init, NULL };
		GType unity_place_entry_info_type_id;
		unity_place_entry_info_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceEntryInfo", &g_define_type_info, 0);
		g_once_init_leave (&unity_place_entry_info_type_id__volatile, unity_place_entry_info_type_id);
	}
	return unity_place_entry_info_type_id__volatile;
}


static void unity_place_entry_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceEntryInfo * self;
	int length;
	self = UNITY_PLACE_ENTRY_INFO (object);
	switch (property_id) {
		case UNITY_PLACE_ENTRY_INFO_ENTRY_RENDERER_INFO:
		g_value_set_object (value, unity_place_entry_info_get_entry_renderer_info (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_GLOBAL_RENDERER_INFO:
		g_value_set_object (value, unity_place_entry_info_get_global_renderer_info (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_DBUS_PATH:
		g_value_set_string (value, unity_place_entry_info_get_dbus_path (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_DISPLAY_NAME:
		g_value_set_string (value, unity_place_entry_info_get_display_name (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_ICON:
		g_value_set_string (value, unity_place_entry_info_get_icon (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_POSITION:
		g_value_set_uint (value, unity_place_entry_info_get_position (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_MIMETYPES:
		g_value_set_boxed (value, unity_place_entry_info_get_mimetypes (self, &length));
		break;
		case UNITY_PLACE_ENTRY_INFO_SENSITIVE:
		g_value_set_boolean (value, unity_place_entry_info_get_sensitive (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_SECTIONS_MODEL:
		g_value_set_object (value, unity_place_entry_info_get_sections_model (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE:
		g_value_set_boolean (value, unity_place_entry_info_get_active (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE_SECTION:
		g_value_set_uint (value, unity_place_entry_info_get_active_section (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE_SEARCH:
		g_value_set_object (value, unity_place_entry_info_get_active_search (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE_GLOBAL_SEARCH:
		g_value_set_object (value, unity_place_entry_info_get_active_global_search (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_entry_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceEntryInfo * self;
	gpointer boxed;
	self = UNITY_PLACE_ENTRY_INFO (object);
	switch (property_id) {
		case UNITY_PLACE_ENTRY_INFO_DBUS_PATH:
		unity_place_entry_info_set_dbus_path (self, g_value_get_string (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_DISPLAY_NAME:
		unity_place_entry_info_set_display_name (self, g_value_get_string (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_ICON:
		unity_place_entry_info_set_icon (self, g_value_get_string (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_POSITION:
		unity_place_entry_info_set_position (self, g_value_get_uint (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_MIMETYPES:
		boxed = g_value_get_boxed (value);
		unity_place_entry_info_set_mimetypes (self, boxed, g_strv_length (boxed));
		break;
		case UNITY_PLACE_ENTRY_INFO_SENSITIVE:
		unity_place_entry_info_set_sensitive (self, g_value_get_boolean (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_SECTIONS_MODEL:
		unity_place_entry_info_set_sections_model (self, g_value_get_object (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE:
		unity_place_entry_info_set_active (self, g_value_get_boolean (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE_SECTION:
		unity_place_entry_info_set_active_section (self, g_value_get_uint (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE_SEARCH:
		unity_place_entry_info_set_active_search (self, g_value_get_object (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE_GLOBAL_SEARCH:
		unity_place_entry_info_set_active_global_search (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


UnityPlace_EntryInfo* unity_place_service_get_entries (UnityPlaceService* self, int* result_length1, GError** error) {
	return UNITY_PLACE_SERVICE_GET_INTERFACE (self)->get_entries (self, result_length1, error);
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}


void _unity_place_service_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_unity_place_service_introspect (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.canonical.Unity.Place\">\n  <method name=\"GetEntries\">\n    <arg name=\"result\" type=\"a(sssuasbsa{ss}(sssa{ss})(sssa{ss}))\" direction=\"out\"/>\n  </method>\n  <signal name=\"EntryAdded\">\n    <arg name=\"entry\" type=\"(sssuasbsa{ss}(sssa{ss})(sssa{ss}))\"/>\n  </signal>\n  <signal name=\"EntryRemoved\">\n    <arg name=\"entry_dbus_path\" type=\"s\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_service_property_get_all (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp21_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp21_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp21_);
	if (strcmp (interface_name, "com.canonical.Unity.Place") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _vala_UnityPlace_EntryInfo_array_free (UnityPlace_EntryInfo* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			unity_place__entryinfo_destroy (&array[i]);
		}
	}
	g_free (array);
}


static DBusHandlerResult _dbus_unity_place_service_get_entries (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	UnityPlace_EntryInfo* result;
	int result_length1;
	DBusMessage* reply;
	UnityPlace_EntryInfo* _tmp22_;
	DBusMessageIter _tmp23_;
	int _tmp24_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result_length1 = 0;
	result = unity_place_service_get_entries (self, &result_length1, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp22_ = result;
	dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "(sssuasbsa{ss}(sssa{ss})(sssa{ss}))", &_tmp23_);
	for (_tmp24_ = 0; _tmp24_ < result_length1; _tmp24_++) {
		DBusMessageIter _tmp25_;
		const char* _tmp26_;
		const char* _tmp27_;
		const char* _tmp28_;
		dbus_uint32_t _tmp29_;
		char** _tmp30_;
		DBusMessageIter _tmp31_;
		int _tmp32_;
		dbus_bool_t _tmp34_;
		const char* _tmp35_;
		DBusMessageIter _tmp36_, _tmp37_;
		GHashTableIter _tmp38_;
		gpointer _tmp39_, _tmp40_;
		DBusMessageIter _tmp43_;
		const char* _tmp44_;
		const char* _tmp45_;
		const char* _tmp46_;
		DBusMessageIter _tmp47_, _tmp48_;
		GHashTableIter _tmp49_;
		gpointer _tmp50_, _tmp51_;
		DBusMessageIter _tmp54_;
		const char* _tmp55_;
		const char* _tmp56_;
		const char* _tmp57_;
		DBusMessageIter _tmp58_, _tmp59_;
		GHashTableIter _tmp60_;
		gpointer _tmp61_, _tmp62_;
		dbus_message_iter_open_container (&_tmp23_, DBUS_TYPE_STRUCT, NULL, &_tmp25_);
		_tmp26_ = (*_tmp22_).dbus_path;
		dbus_message_iter_append_basic (&_tmp25_, DBUS_TYPE_STRING, &_tmp26_);
		_tmp27_ = (*_tmp22_).display_name;
		dbus_message_iter_append_basic (&_tmp25_, DBUS_TYPE_STRING, &_tmp27_);
		_tmp28_ = (*_tmp22_).icon;
		dbus_message_iter_append_basic (&_tmp25_, DBUS_TYPE_STRING, &_tmp28_);
		_tmp29_ = (*_tmp22_).position;
		dbus_message_iter_append_basic (&_tmp25_, DBUS_TYPE_UINT32, &_tmp29_);
		_tmp30_ = (*_tmp22_).mimetypes;
		dbus_message_iter_open_container (&_tmp25_, DBUS_TYPE_ARRAY, "s", &_tmp31_);
		for (_tmp32_ = 0; _tmp32_ < (*_tmp22_).mimetypes_length1; _tmp32_++) {
			const char* _tmp33_;
			_tmp33_ = *_tmp30_;
			dbus_message_iter_append_basic (&_tmp31_, DBUS_TYPE_STRING, &_tmp33_);
			_tmp30_++;
		}
		dbus_message_iter_close_container (&_tmp25_, &_tmp31_);
		_tmp34_ = (*_tmp22_).sensitive;
		dbus_message_iter_append_basic (&_tmp25_, DBUS_TYPE_BOOLEAN, &_tmp34_);
		_tmp35_ = (*_tmp22_).sections_model;
		dbus_message_iter_append_basic (&_tmp25_, DBUS_TYPE_STRING, &_tmp35_);
		dbus_message_iter_open_container (&_tmp25_, DBUS_TYPE_ARRAY, "{ss}", &_tmp36_);
		g_hash_table_iter_init (&_tmp38_, (*_tmp22_).hints);
		while (g_hash_table_iter_next (&_tmp38_, &_tmp39_, &_tmp40_)) {
			char* _key;
			char* _value;
			const char* _tmp41_;
			const char* _tmp42_;
			dbus_message_iter_open_container (&_tmp36_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp37_);
			_key = (char*) _tmp39_;
			_value = (char*) _tmp40_;
			_tmp41_ = _key;
			dbus_message_iter_append_basic (&_tmp37_, DBUS_TYPE_STRING, &_tmp41_);
			_tmp42_ = _value;
			dbus_message_iter_append_basic (&_tmp37_, DBUS_TYPE_STRING, &_tmp42_);
			dbus_message_iter_close_container (&_tmp36_, &_tmp37_);
		}
		dbus_message_iter_close_container (&_tmp25_, &_tmp36_);
		dbus_message_iter_open_container (&_tmp25_, DBUS_TYPE_STRUCT, NULL, &_tmp43_);
		_tmp44_ = (*_tmp22_).entry_renderer_info.default_renderer;
		dbus_message_iter_append_basic (&_tmp43_, DBUS_TYPE_STRING, &_tmp44_);
		_tmp45_ = (*_tmp22_).entry_renderer_info.groups_model;
		dbus_message_iter_append_basic (&_tmp43_, DBUS_TYPE_STRING, &_tmp45_);
		_tmp46_ = (*_tmp22_).entry_renderer_info.results_model;
		dbus_message_iter_append_basic (&_tmp43_, DBUS_TYPE_STRING, &_tmp46_);
		dbus_message_iter_open_container (&_tmp43_, DBUS_TYPE_ARRAY, "{ss}", &_tmp47_);
		g_hash_table_iter_init (&_tmp49_, (*_tmp22_).entry_renderer_info.hints);
		while (g_hash_table_iter_next (&_tmp49_, &_tmp50_, &_tmp51_)) {
			char* _key;
			char* _value;
			const char* _tmp52_;
			const char* _tmp53_;
			dbus_message_iter_open_container (&_tmp47_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp48_);
			_key = (char*) _tmp50_;
			_value = (char*) _tmp51_;
			_tmp52_ = _key;
			dbus_message_iter_append_basic (&_tmp48_, DBUS_TYPE_STRING, &_tmp52_);
			_tmp53_ = _value;
			dbus_message_iter_append_basic (&_tmp48_, DBUS_TYPE_STRING, &_tmp53_);
			dbus_message_iter_close_container (&_tmp47_, &_tmp48_);
		}
		dbus_message_iter_close_container (&_tmp43_, &_tmp47_);
		dbus_message_iter_close_container (&_tmp25_, &_tmp43_);
		dbus_message_iter_open_container (&_tmp25_, DBUS_TYPE_STRUCT, NULL, &_tmp54_);
		_tmp55_ = (*_tmp22_).global_renderer_info.default_renderer;
		dbus_message_iter_append_basic (&_tmp54_, DBUS_TYPE_STRING, &_tmp55_);
		_tmp56_ = (*_tmp22_).global_renderer_info.groups_model;
		dbus_message_iter_append_basic (&_tmp54_, DBUS_TYPE_STRING, &_tmp56_);
		_tmp57_ = (*_tmp22_).global_renderer_info.results_model;
		dbus_message_iter_append_basic (&_tmp54_, DBUS_TYPE_STRING, &_tmp57_);
		dbus_message_iter_open_container (&_tmp54_, DBUS_TYPE_ARRAY, "{ss}", &_tmp58_);
		g_hash_table_iter_init (&_tmp60_, (*_tmp22_).global_renderer_info.hints);
		while (g_hash_table_iter_next (&_tmp60_, &_tmp61_, &_tmp62_)) {
			char* _key;
			char* _value;
			const char* _tmp63_;
			const char* _tmp64_;
			dbus_message_iter_open_container (&_tmp58_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp59_);
			_key = (char*) _tmp61_;
			_value = (char*) _tmp62_;
			_tmp63_ = _key;
			dbus_message_iter_append_basic (&_tmp59_, DBUS_TYPE_STRING, &_tmp63_);
			_tmp64_ = _value;
			dbus_message_iter_append_basic (&_tmp59_, DBUS_TYPE_STRING, &_tmp64_);
			dbus_message_iter_close_container (&_tmp58_, &_tmp59_);
		}
		dbus_message_iter_close_container (&_tmp54_, &_tmp58_);
		dbus_message_iter_close_container (&_tmp25_, &_tmp54_);
		dbus_message_iter_close_container (&_tmp23_, &_tmp25_);
		_tmp22_++;
	}
	dbus_message_iter_close_container (&iter, &_tmp23_);
	result = (_vala_UnityPlace_EntryInfo_array_free (result,  result_length1), NULL);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult unity_place_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_unity_place_service_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_unity_place_service_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.Place", "GetEntries")) {
		result = _dbus_unity_place_service_get_entries (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _dbus_unity_place_service_entry_added (GObject* _sender, UnityPlace_EntryInfo* entry, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	DBusMessageIter _tmp65_;
	const char* _tmp66_;
	const char* _tmp67_;
	const char* _tmp68_;
	dbus_uint32_t _tmp69_;
	char** _tmp70_;
	DBusMessageIter _tmp71_;
	int _tmp72_;
	dbus_bool_t _tmp74_;
	const char* _tmp75_;
	DBusMessageIter _tmp76_, _tmp77_;
	GHashTableIter _tmp78_;
	gpointer _tmp79_, _tmp80_;
	DBusMessageIter _tmp83_;
	const char* _tmp84_;
	const char* _tmp85_;
	const char* _tmp86_;
	DBusMessageIter _tmp87_, _tmp88_;
	GHashTableIter _tmp89_;
	gpointer _tmp90_, _tmp91_;
	DBusMessageIter _tmp94_;
	const char* _tmp95_;
	const char* _tmp96_;
	const char* _tmp97_;
	DBusMessageIter _tmp98_, _tmp99_;
	GHashTableIter _tmp100_;
	gpointer _tmp101_, _tmp102_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.canonical.Unity.Place", "EntryAdded");
	dbus_message_iter_init_append (_message, &_iter);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_STRUCT, NULL, &_tmp65_);
	_tmp66_ = (*entry).dbus_path;
	dbus_message_iter_append_basic (&_tmp65_, DBUS_TYPE_STRING, &_tmp66_);
	_tmp67_ = (*entry).display_name;
	dbus_message_iter_append_basic (&_tmp65_, DBUS_TYPE_STRING, &_tmp67_);
	_tmp68_ = (*entry).icon;
	dbus_message_iter_append_basic (&_tmp65_, DBUS_TYPE_STRING, &_tmp68_);
	_tmp69_ = (*entry).position;
	dbus_message_iter_append_basic (&_tmp65_, DBUS_TYPE_UINT32, &_tmp69_);
	_tmp70_ = (*entry).mimetypes;
	dbus_message_iter_open_container (&_tmp65_, DBUS_TYPE_ARRAY, "s", &_tmp71_);
	for (_tmp72_ = 0; _tmp72_ < (*entry).mimetypes_length1; _tmp72_++) {
		const char* _tmp73_;
		_tmp73_ = *_tmp70_;
		dbus_message_iter_append_basic (&_tmp71_, DBUS_TYPE_STRING, &_tmp73_);
		_tmp70_++;
	}
	dbus_message_iter_close_container (&_tmp65_, &_tmp71_);
	_tmp74_ = (*entry).sensitive;
	dbus_message_iter_append_basic (&_tmp65_, DBUS_TYPE_BOOLEAN, &_tmp74_);
	_tmp75_ = (*entry).sections_model;
	dbus_message_iter_append_basic (&_tmp65_, DBUS_TYPE_STRING, &_tmp75_);
	dbus_message_iter_open_container (&_tmp65_, DBUS_TYPE_ARRAY, "{ss}", &_tmp76_);
	g_hash_table_iter_init (&_tmp78_, (*entry).hints);
	while (g_hash_table_iter_next (&_tmp78_, &_tmp79_, &_tmp80_)) {
		char* _key;
		char* _value;
		const char* _tmp81_;
		const char* _tmp82_;
		dbus_message_iter_open_container (&_tmp76_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp77_);
		_key = (char*) _tmp79_;
		_value = (char*) _tmp80_;
		_tmp81_ = _key;
		dbus_message_iter_append_basic (&_tmp77_, DBUS_TYPE_STRING, &_tmp81_);
		_tmp82_ = _value;
		dbus_message_iter_append_basic (&_tmp77_, DBUS_TYPE_STRING, &_tmp82_);
		dbus_message_iter_close_container (&_tmp76_, &_tmp77_);
	}
	dbus_message_iter_close_container (&_tmp65_, &_tmp76_);
	dbus_message_iter_open_container (&_tmp65_, DBUS_TYPE_STRUCT, NULL, &_tmp83_);
	_tmp84_ = (*entry).entry_renderer_info.default_renderer;
	dbus_message_iter_append_basic (&_tmp83_, DBUS_TYPE_STRING, &_tmp84_);
	_tmp85_ = (*entry).entry_renderer_info.groups_model;
	dbus_message_iter_append_basic (&_tmp83_, DBUS_TYPE_STRING, &_tmp85_);
	_tmp86_ = (*entry).entry_renderer_info.results_model;
	dbus_message_iter_append_basic (&_tmp83_, DBUS_TYPE_STRING, &_tmp86_);
	dbus_message_iter_open_container (&_tmp83_, DBUS_TYPE_ARRAY, "{ss}", &_tmp87_);
	g_hash_table_iter_init (&_tmp89_, (*entry).entry_renderer_info.hints);
	while (g_hash_table_iter_next (&_tmp89_, &_tmp90_, &_tmp91_)) {
		char* _key;
		char* _value;
		const char* _tmp92_;
		const char* _tmp93_;
		dbus_message_iter_open_container (&_tmp87_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp88_);
		_key = (char*) _tmp90_;
		_value = (char*) _tmp91_;
		_tmp92_ = _key;
		dbus_message_iter_append_basic (&_tmp88_, DBUS_TYPE_STRING, &_tmp92_);
		_tmp93_ = _value;
		dbus_message_iter_append_basic (&_tmp88_, DBUS_TYPE_STRING, &_tmp93_);
		dbus_message_iter_close_container (&_tmp87_, &_tmp88_);
	}
	dbus_message_iter_close_container (&_tmp83_, &_tmp87_);
	dbus_message_iter_close_container (&_tmp65_, &_tmp83_);
	dbus_message_iter_open_container (&_tmp65_, DBUS_TYPE_STRUCT, NULL, &_tmp94_);
	_tmp95_ = (*entry).global_renderer_info.default_renderer;
	dbus_message_iter_append_basic (&_tmp94_, DBUS_TYPE_STRING, &_tmp95_);
	_tmp96_ = (*entry).global_renderer_info.groups_model;
	dbus_message_iter_append_basic (&_tmp94_, DBUS_TYPE_STRING, &_tmp96_);
	_tmp97_ = (*entry).global_renderer_info.results_model;
	dbus_message_iter_append_basic (&_tmp94_, DBUS_TYPE_STRING, &_tmp97_);
	dbus_message_iter_open_container (&_tmp94_, DBUS_TYPE_ARRAY, "{ss}", &_tmp98_);
	g_hash_table_iter_init (&_tmp100_, (*entry).global_renderer_info.hints);
	while (g_hash_table_iter_next (&_tmp100_, &_tmp101_, &_tmp102_)) {
		char* _key;
		char* _value;
		const char* _tmp103_;
		const char* _tmp104_;
		dbus_message_iter_open_container (&_tmp98_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp99_);
		_key = (char*) _tmp101_;
		_value = (char*) _tmp102_;
		_tmp103_ = _key;
		dbus_message_iter_append_basic (&_tmp99_, DBUS_TYPE_STRING, &_tmp103_);
		_tmp104_ = _value;
		dbus_message_iter_append_basic (&_tmp99_, DBUS_TYPE_STRING, &_tmp104_);
		dbus_message_iter_close_container (&_tmp98_, &_tmp99_);
	}
	dbus_message_iter_close_container (&_tmp94_, &_tmp98_);
	dbus_message_iter_close_container (&_tmp65_, &_tmp94_);
	dbus_message_iter_close_container (&_iter, &_tmp65_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_unity_place_service_entry_removed (GObject* _sender, const char* entry_dbus_path, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	const char* _tmp105_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.canonical.Unity.Place", "EntryRemoved");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp105_ = entry_dbus_path;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp105_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


void unity_place_service_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_unity_place_service_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	g_signal_connect (object, "entry-added", (GCallback) _dbus_unity_place_service_entry_added, connection);
	g_signal_connect (object, "entry-removed", (GCallback) _dbus_unity_place_service_entry_removed, connection);
}


static void unity_place_service_base_init (UnityPlaceServiceIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("entry_added", UNITY_PLACE_TYPE_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, UNITY_PLACE_TYPE__ENTRYINFO);
		g_signal_new ("entry_removed", UNITY_PLACE_TYPE_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
		g_type_set_qdata (UNITY_PLACE_TYPE_SERVICE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_unity_place_service_dbus_vtable));
	}
}


GType unity_place_service_get_type (void) {
	static volatile gsize unity_place_service_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_service_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceServiceIface), (GBaseInitFunc) unity_place_service_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType unity_place_service_type_id;
		unity_place_service_type_id = g_type_register_static (G_TYPE_INTERFACE, "UnityPlaceService", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (unity_place_service_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (unity_place_service_type_id, g_quark_from_string ("ValaDBusInterfaceProxyType"), &unity_place_service_dbus_proxy_get_type);
		g_once_init_leave (&unity_place_service_type_id__volatile, unity_place_service_type_id);
	}
	return unity_place_service_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (UnityPlaceServiceDBusProxy, unity_place_service_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE (UNITY_PLACE_TYPE_SERVICE, unity_place_service_dbus_proxy_unity_place_service__interface_init) );
UnityPlaceService* unity_place_service_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path) {
	UnityPlaceService* self;
	self = g_object_new (unity_place_service_dbus_proxy_get_type (), "connection", connection, "name", name, "path", path, "interface", "com.canonical.Unity.Place", NULL);
	return self;
}


static GObject* unity_place_service_dbus_proxy_construct (GType gtype, guint n_properties, GObjectConstructParam* properties) {
	GObject* self;
	DBusGConnection *connection;
	char* path;
	char* filter;
	self = G_OBJECT_CLASS (unity_place_service_dbus_proxy_parent_class)->constructor (gtype, n_properties, properties);
	g_object_get (self, "connection", &connection, NULL);
	g_object_get (self, "path", &path, NULL);
	dbus_connection_add_filter (dbus_g_connection_get_connection (connection), unity_place_service_dbus_proxy_filter, self, NULL);
	filter = g_strdup_printf ("type='signal',path='%s'", path);
	dbus_bus_add_match (dbus_g_connection_get_connection (connection), filter, NULL);
	dbus_g_connection_unref (connection);
	g_free (path);
	g_free (filter);
	return self;
}


static void _dbus_handle_unity_place_service_entry_added (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	UnityPlace_EntryInfo entry = {0};
	UnityPlace_EntryInfo _tmp106_;
	DBusMessageIter _tmp107_;
	const char* _tmp108_;
	const char* _tmp109_;
	const char* _tmp110_;
	dbus_uint32_t _tmp111_;
	char** _tmp112_;
	int _tmp112__length;
	int _tmp112__size;
	int _tmp112__length1;
	DBusMessageIter _tmp113_;
	dbus_bool_t _tmp115_;
	const char* _tmp116_;
	GHashTable* _tmp117_;
	DBusMessageIter _tmp118_;
	DBusMessageIter _tmp119_;
	UnityPlace_RendererInfo _tmp122_;
	DBusMessageIter _tmp123_;
	const char* _tmp124_;
	const char* _tmp125_;
	const char* _tmp126_;
	GHashTable* _tmp127_;
	DBusMessageIter _tmp128_;
	DBusMessageIter _tmp129_;
	UnityPlace_RendererInfo _tmp132_;
	DBusMessageIter _tmp133_;
	const char* _tmp134_;
	const char* _tmp135_;
	const char* _tmp136_;
	GHashTable* _tmp137_;
	DBusMessageIter _tmp138_;
	DBusMessageIter _tmp139_;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "(sssuasbsa{ss}(sssa{ss})(sssa{ss}))")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_recurse (&iter, &_tmp107_);
	dbus_message_iter_get_basic (&_tmp107_, &_tmp108_);
	dbus_message_iter_next (&_tmp107_);
	_tmp106_.dbus_path = g_strdup (_tmp108_);
	dbus_message_iter_get_basic (&_tmp107_, &_tmp109_);
	dbus_message_iter_next (&_tmp107_);
	_tmp106_.display_name = g_strdup (_tmp109_);
	dbus_message_iter_get_basic (&_tmp107_, &_tmp110_);
	dbus_message_iter_next (&_tmp107_);
	_tmp106_.icon = g_strdup (_tmp110_);
	dbus_message_iter_get_basic (&_tmp107_, &_tmp111_);
	dbus_message_iter_next (&_tmp107_);
	_tmp106_.position = _tmp111_;
	_tmp112_ = g_new (char*, 5);
	_tmp112__length = 0;
	_tmp112__size = 4;
	_tmp112__length1 = 0;
	dbus_message_iter_recurse (&_tmp107_, &_tmp113_);
	for (; dbus_message_iter_get_arg_type (&_tmp113_); _tmp112__length1++) {
		const char* _tmp114_;
		if (_tmp112__size == _tmp112__length) {
			_tmp112__size = 2 * _tmp112__size;
			_tmp112_ = g_renew (char*, _tmp112_, _tmp112__size + 1);
		}
		dbus_message_iter_get_basic (&_tmp113_, &_tmp114_);
		dbus_message_iter_next (&_tmp113_);
		_tmp112_[_tmp112__length++] = g_strdup (_tmp114_);
	}
	_tmp106_.mimetypes_length1 = _tmp112__length1;
	_tmp112_[_tmp112__length] = NULL;
	dbus_message_iter_next (&_tmp107_);
	_tmp106_.mimetypes = _tmp112_;
	dbus_message_iter_get_basic (&_tmp107_, &_tmp115_);
	dbus_message_iter_next (&_tmp107_);
	_tmp106_.sensitive = _tmp115_;
	dbus_message_iter_get_basic (&_tmp107_, &_tmp116_);
	dbus_message_iter_next (&_tmp107_);
	_tmp106_.sections_model = g_strdup (_tmp116_);
	_tmp117_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&_tmp107_, &_tmp118_);
	while (dbus_message_iter_get_arg_type (&_tmp118_)) {
		char* _key;
		char* _value;
		const char* _tmp120_;
		const char* _tmp121_;
		dbus_message_iter_recurse (&_tmp118_, &_tmp119_);
		dbus_message_iter_get_basic (&_tmp119_, &_tmp120_);
		dbus_message_iter_next (&_tmp119_);
		_key = g_strdup (_tmp120_);
		dbus_message_iter_get_basic (&_tmp119_, &_tmp121_);
		dbus_message_iter_next (&_tmp119_);
		_value = g_strdup (_tmp121_);
		g_hash_table_insert (_tmp117_, _key, _value);
		dbus_message_iter_next (&_tmp118_);
	}
	dbus_message_iter_next (&_tmp107_);
	_tmp106_.hints = _tmp117_;
	dbus_message_iter_recurse (&_tmp107_, &_tmp123_);
	dbus_message_iter_get_basic (&_tmp123_, &_tmp124_);
	dbus_message_iter_next (&_tmp123_);
	_tmp122_.default_renderer = g_strdup (_tmp124_);
	dbus_message_iter_get_basic (&_tmp123_, &_tmp125_);
	dbus_message_iter_next (&_tmp123_);
	_tmp122_.groups_model = g_strdup (_tmp125_);
	dbus_message_iter_get_basic (&_tmp123_, &_tmp126_);
	dbus_message_iter_next (&_tmp123_);
	_tmp122_.results_model = g_strdup (_tmp126_);
	_tmp127_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&_tmp123_, &_tmp128_);
	while (dbus_message_iter_get_arg_type (&_tmp128_)) {
		char* _key;
		char* _value;
		const char* _tmp130_;
		const char* _tmp131_;
		dbus_message_iter_recurse (&_tmp128_, &_tmp129_);
		dbus_message_iter_get_basic (&_tmp129_, &_tmp130_);
		dbus_message_iter_next (&_tmp129_);
		_key = g_strdup (_tmp130_);
		dbus_message_iter_get_basic (&_tmp129_, &_tmp131_);
		dbus_message_iter_next (&_tmp129_);
		_value = g_strdup (_tmp131_);
		g_hash_table_insert (_tmp127_, _key, _value);
		dbus_message_iter_next (&_tmp128_);
	}
	dbus_message_iter_next (&_tmp123_);
	_tmp122_.hints = _tmp127_;
	dbus_message_iter_next (&_tmp107_);
	_tmp106_.entry_renderer_info = _tmp122_;
	dbus_message_iter_recurse (&_tmp107_, &_tmp133_);
	dbus_message_iter_get_basic (&_tmp133_, &_tmp134_);
	dbus_message_iter_next (&_tmp133_);
	_tmp132_.default_renderer = g_strdup (_tmp134_);
	dbus_message_iter_get_basic (&_tmp133_, &_tmp135_);
	dbus_message_iter_next (&_tmp133_);
	_tmp132_.groups_model = g_strdup (_tmp135_);
	dbus_message_iter_get_basic (&_tmp133_, &_tmp136_);
	dbus_message_iter_next (&_tmp133_);
	_tmp132_.results_model = g_strdup (_tmp136_);
	_tmp137_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&_tmp133_, &_tmp138_);
	while (dbus_message_iter_get_arg_type (&_tmp138_)) {
		char* _key;
		char* _value;
		const char* _tmp140_;
		const char* _tmp141_;
		dbus_message_iter_recurse (&_tmp138_, &_tmp139_);
		dbus_message_iter_get_basic (&_tmp139_, &_tmp140_);
		dbus_message_iter_next (&_tmp139_);
		_key = g_strdup (_tmp140_);
		dbus_message_iter_get_basic (&_tmp139_, &_tmp141_);
		dbus_message_iter_next (&_tmp139_);
		_value = g_strdup (_tmp141_);
		g_hash_table_insert (_tmp137_, _key, _value);
		dbus_message_iter_next (&_tmp138_);
	}
	dbus_message_iter_next (&_tmp133_);
	_tmp132_.hints = _tmp137_;
	dbus_message_iter_next (&_tmp107_);
	_tmp106_.global_renderer_info = _tmp132_;
	dbus_message_iter_next (&iter);
	entry = _tmp106_;
	g_signal_emit_by_name (self, "entry-added", &entry);
	unity_place__entryinfo_destroy (&entry);
}


static void _dbus_handle_unity_place_service_entry_removed (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	char* entry_dbus_path = NULL;
	const char* _tmp142_;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp142_);
	dbus_message_iter_next (&iter);
	entry_dbus_path = g_strdup (_tmp142_);
	g_signal_emit_by_name (self, "entry-removed", entry_dbus_path);
	_g_free0 (entry_dbus_path);
}


DBusHandlerResult unity_place_service_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data) {
	if (dbus_message_has_path (message, dbus_g_proxy_get_path (user_data))) {
		if (dbus_message_is_signal (message, "com.canonical.Unity.Place", "EntryAdded")) {
			_dbus_handle_unity_place_service_entry_added (user_data, connection, message);
		} else if (dbus_message_is_signal (message, "com.canonical.Unity.Place", "EntryRemoved")) {
			_dbus_handle_unity_place_service_entry_removed (user_data, connection, message);
		}
	}
	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void unity_place_service_dbus_proxy_dispose (GObject* self) {
	DBusGConnection *connection;
	if (((UnityPlaceServiceDBusProxy*) self)->disposed) {
		return;
	}
	((UnityPlaceServiceDBusProxy*) self)->disposed = TRUE;
	g_object_get (self, "connection", &connection, NULL);
	dbus_connection_remove_filter (dbus_g_connection_get_connection (connection), unity_place_service_dbus_proxy_filter, self);
	G_OBJECT_CLASS (unity_place_service_dbus_proxy_parent_class)->dispose (self);
}


static void unity_place_service_dbus_proxy_class_init (UnityPlaceServiceDBusProxyClass* klass) {
	G_OBJECT_CLASS (klass)->constructor = unity_place_service_dbus_proxy_construct;
	G_OBJECT_CLASS (klass)->dispose = unity_place_service_dbus_proxy_dispose;
	G_OBJECT_CLASS (klass)->get_property = unity_place_service_dbus_proxy_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_service_dbus_proxy_set_property;
}


static void unity_place_service_dbus_proxy_init (UnityPlaceServiceDBusProxy* self) {
}


static UnityPlace_EntryInfo* unity_place_service_dbus_proxy_get_entries (UnityPlaceService* self, int* result_length1, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	UnityPlace_EntryInfo* _result;
	int _result_length1;
	UnityPlace_EntryInfo* _tmp143_;
	int _tmp143__length;
	int _tmp143__size;
	int _tmp143__length1;
	DBusMessageIter _tmp144_;
	if (((UnityPlaceServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.Place", "GetEntries");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp181_;
			_edomain = DBUS_GERROR;
			_tmp181_ = _dbus_error.name + 27;
			if (strcmp (_tmp181_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp181_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp181_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp181_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp181_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp181_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp181_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp181_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp181_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp181_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp181_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp181_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp181_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp181_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp181_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp181_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp181_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp181_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp181_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp181_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp181_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp181_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp181_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp181_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp181_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp181_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp181_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp181_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp181_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp181_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp181_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp181_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp181_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return NULL;
	}
	if (strcmp (dbus_message_get_signature (_reply), "a(sssuasbsa{ss}(sssa{ss})(sssa{ss}))")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "a(sssuasbsa{ss}(sssa{ss})(sssa{ss}))", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_init (_reply, &_iter);
	_result_length1 = 0;
	_tmp143_ = g_new (UnityPlace_EntryInfo, 5);
	_tmp143__length = 0;
	_tmp143__size = 4;
	_tmp143__length1 = 0;
	dbus_message_iter_recurse (&_iter, &_tmp144_);
	for (; dbus_message_iter_get_arg_type (&_tmp144_); _tmp143__length1++) {
		UnityPlace_EntryInfo _tmp145_;
		DBusMessageIter _tmp146_;
		const char* _tmp147_;
		const char* _tmp148_;
		const char* _tmp149_;
		dbus_uint32_t _tmp150_;
		char** _tmp151_;
		int _tmp151__length;
		int _tmp151__size;
		int _tmp151__length1;
		DBusMessageIter _tmp152_;
		dbus_bool_t _tmp154_;
		const char* _tmp155_;
		GHashTable* _tmp156_;
		DBusMessageIter _tmp157_;
		DBusMessageIter _tmp158_;
		UnityPlace_RendererInfo _tmp161_;
		DBusMessageIter _tmp162_;
		const char* _tmp163_;
		const char* _tmp164_;
		const char* _tmp165_;
		GHashTable* _tmp166_;
		DBusMessageIter _tmp167_;
		DBusMessageIter _tmp168_;
		UnityPlace_RendererInfo _tmp171_;
		DBusMessageIter _tmp172_;
		const char* _tmp173_;
		const char* _tmp174_;
		const char* _tmp175_;
		GHashTable* _tmp176_;
		DBusMessageIter _tmp177_;
		DBusMessageIter _tmp178_;
		if (_tmp143__size == _tmp143__length) {
			_tmp143__size = 2 * _tmp143__size;
			_tmp143_ = g_renew (UnityPlace_EntryInfo, _tmp143_, _tmp143__size + 1);
		}
		dbus_message_iter_recurse (&_tmp144_, &_tmp146_);
		dbus_message_iter_get_basic (&_tmp146_, &_tmp147_);
		dbus_message_iter_next (&_tmp146_);
		_tmp145_.dbus_path = g_strdup (_tmp147_);
		dbus_message_iter_get_basic (&_tmp146_, &_tmp148_);
		dbus_message_iter_next (&_tmp146_);
		_tmp145_.display_name = g_strdup (_tmp148_);
		dbus_message_iter_get_basic (&_tmp146_, &_tmp149_);
		dbus_message_iter_next (&_tmp146_);
		_tmp145_.icon = g_strdup (_tmp149_);
		dbus_message_iter_get_basic (&_tmp146_, &_tmp150_);
		dbus_message_iter_next (&_tmp146_);
		_tmp145_.position = _tmp150_;
		_tmp151_ = g_new (char*, 5);
		_tmp151__length = 0;
		_tmp151__size = 4;
		_tmp151__length1 = 0;
		dbus_message_iter_recurse (&_tmp146_, &_tmp152_);
		for (; dbus_message_iter_get_arg_type (&_tmp152_); _tmp151__length1++) {
			const char* _tmp153_;
			if (_tmp151__size == _tmp151__length) {
				_tmp151__size = 2 * _tmp151__size;
				_tmp151_ = g_renew (char*, _tmp151_, _tmp151__size + 1);
			}
			dbus_message_iter_get_basic (&_tmp152_, &_tmp153_);
			dbus_message_iter_next (&_tmp152_);
			_tmp151_[_tmp151__length++] = g_strdup (_tmp153_);
		}
		_tmp145_.mimetypes_length1 = _tmp151__length1;
		_tmp151_[_tmp151__length] = NULL;
		dbus_message_iter_next (&_tmp146_);
		_tmp145_.mimetypes = _tmp151_;
		dbus_message_iter_get_basic (&_tmp146_, &_tmp154_);
		dbus_message_iter_next (&_tmp146_);
		_tmp145_.sensitive = _tmp154_;
		dbus_message_iter_get_basic (&_tmp146_, &_tmp155_);
		dbus_message_iter_next (&_tmp146_);
		_tmp145_.sections_model = g_strdup (_tmp155_);
		_tmp156_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
		dbus_message_iter_recurse (&_tmp146_, &_tmp157_);
		while (dbus_message_iter_get_arg_type (&_tmp157_)) {
			char* _key;
			char* _value;
			const char* _tmp159_;
			const char* _tmp160_;
			dbus_message_iter_recurse (&_tmp157_, &_tmp158_);
			dbus_message_iter_get_basic (&_tmp158_, &_tmp159_);
			dbus_message_iter_next (&_tmp158_);
			_key = g_strdup (_tmp159_);
			dbus_message_iter_get_basic (&_tmp158_, &_tmp160_);
			dbus_message_iter_next (&_tmp158_);
			_value = g_strdup (_tmp160_);
			g_hash_table_insert (_tmp156_, _key, _value);
			dbus_message_iter_next (&_tmp157_);
		}
		dbus_message_iter_next (&_tmp146_);
		_tmp145_.hints = _tmp156_;
		dbus_message_iter_recurse (&_tmp146_, &_tmp162_);
		dbus_message_iter_get_basic (&_tmp162_, &_tmp163_);
		dbus_message_iter_next (&_tmp162_);
		_tmp161_.default_renderer = g_strdup (_tmp163_);
		dbus_message_iter_get_basic (&_tmp162_, &_tmp164_);
		dbus_message_iter_next (&_tmp162_);
		_tmp161_.groups_model = g_strdup (_tmp164_);
		dbus_message_iter_get_basic (&_tmp162_, &_tmp165_);
		dbus_message_iter_next (&_tmp162_);
		_tmp161_.results_model = g_strdup (_tmp165_);
		_tmp166_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
		dbus_message_iter_recurse (&_tmp162_, &_tmp167_);
		while (dbus_message_iter_get_arg_type (&_tmp167_)) {
			char* _key;
			char* _value;
			const char* _tmp169_;
			const char* _tmp170_;
			dbus_message_iter_recurse (&_tmp167_, &_tmp168_);
			dbus_message_iter_get_basic (&_tmp168_, &_tmp169_);
			dbus_message_iter_next (&_tmp168_);
			_key = g_strdup (_tmp169_);
			dbus_message_iter_get_basic (&_tmp168_, &_tmp170_);
			dbus_message_iter_next (&_tmp168_);
			_value = g_strdup (_tmp170_);
			g_hash_table_insert (_tmp166_, _key, _value);
			dbus_message_iter_next (&_tmp167_);
		}
		dbus_message_iter_next (&_tmp162_);
		_tmp161_.hints = _tmp166_;
		dbus_message_iter_next (&_tmp146_);
		_tmp145_.entry_renderer_info = _tmp161_;
		dbus_message_iter_recurse (&_tmp146_, &_tmp172_);
		dbus_message_iter_get_basic (&_tmp172_, &_tmp173_);
		dbus_message_iter_next (&_tmp172_);
		_tmp171_.default_renderer = g_strdup (_tmp173_);
		dbus_message_iter_get_basic (&_tmp172_, &_tmp174_);
		dbus_message_iter_next (&_tmp172_);
		_tmp171_.groups_model = g_strdup (_tmp174_);
		dbus_message_iter_get_basic (&_tmp172_, &_tmp175_);
		dbus_message_iter_next (&_tmp172_);
		_tmp171_.results_model = g_strdup (_tmp175_);
		_tmp176_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
		dbus_message_iter_recurse (&_tmp172_, &_tmp177_);
		while (dbus_message_iter_get_arg_type (&_tmp177_)) {
			char* _key;
			char* _value;
			const char* _tmp179_;
			const char* _tmp180_;
			dbus_message_iter_recurse (&_tmp177_, &_tmp178_);
			dbus_message_iter_get_basic (&_tmp178_, &_tmp179_);
			dbus_message_iter_next (&_tmp178_);
			_key = g_strdup (_tmp179_);
			dbus_message_iter_get_basic (&_tmp178_, &_tmp180_);
			dbus_message_iter_next (&_tmp178_);
			_value = g_strdup (_tmp180_);
			g_hash_table_insert (_tmp176_, _key, _value);
			dbus_message_iter_next (&_tmp177_);
		}
		dbus_message_iter_next (&_tmp172_);
		_tmp171_.hints = _tmp176_;
		dbus_message_iter_next (&_tmp146_);
		_tmp145_.global_renderer_info = _tmp171_;
		dbus_message_iter_next (&_tmp144_);
		_tmp143_[_tmp143__length++] = _tmp145_;
	}
	_result_length1 = _tmp143__length1;
	dbus_message_iter_next (&_iter);
	_result = _tmp143_;
	*result_length1 = _result_length1;
	dbus_message_unref (_reply);
	return _result;
}


static void unity_place_service_dbus_proxy_unity_place_service__interface_init (UnityPlaceServiceIface* iface) {
	iface->get_entries = unity_place_service_dbus_proxy_get_entries;
}


static void unity_place_service_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
}


static void unity_place_service_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
}


void unity_place_entry_service_set_global_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error) {
	UNITY_PLACE_ENTRY_SERVICE_GET_INTERFACE (self)->set_global_search (self, search, hints, error);
}


void unity_place_entry_service_set_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error) {
	UNITY_PLACE_ENTRY_SERVICE_GET_INTERFACE (self)->set_search (self, search, hints, error);
}


void unity_place_entry_service_set_active (UnityPlaceEntryService* self, gboolean is_active, GError** error) {
	UNITY_PLACE_ENTRY_SERVICE_GET_INTERFACE (self)->set_active (self, is_active, error);
}


void unity_place_entry_service_set_active_section (UnityPlaceEntryService* self, guint section_id, GError** error) {
	UNITY_PLACE_ENTRY_SERVICE_GET_INTERFACE (self)->set_active_section (self, section_id, error);
}


void _unity_place_entry_service_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_unity_place_entry_service_introspect (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.canonical.Unity.PlaceEntry\">\n  <method name=\"SetGlobalSearch\">\n    <arg name=\"search\" type=\"s\" direction=\"in\"/>\n    <arg name=\"hints\" type=\"a{ss}\" direction=\"in\"/>\n  </method>\n  <method name=\"SetSearch\">\n    <arg name=\"search\" type=\"s\" direction=\"in\"/>\n    <arg name=\"hints\" type=\"a{ss}\" direction=\"in\"/>\n  </method>\n  <method name=\"SetActive\">\n    <arg name=\"is_active\" type=\"b\" direction=\"in\"/>\n  </method>\n  <method name=\"SetActiveSection\">\n    <arg name=\"section_id\" type=\"u\" direction=\"in\"/>\n  </method>\n  <signal name=\"EntryRendererInfoChanged\">\n    <arg name=\"renderer_info\" type=\"(sssa{ss})\"/>\n  </signal>\n  <signal name=\"GlobalRendererInfoChanged\">\n    <arg name=\"renderer_info\" type=\"(sssa{ss})\"/>\n  </signal>\n  <signal name=\"PlaceEntryInfoChanged\">\n    <arg name=\"entry_info_data\" type=\"(sssuasbsa{ss})\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_entry_service_property_get_all (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp182_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp182_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp182_);
	if (strcmp (interface_name, "com.canonical.Unity.PlaceEntry") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_entry_service_set_global_search (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* search = NULL;
	const char* _tmp183_;
	GHashTable* hints = NULL;
	GHashTable* _tmp184_;
	DBusMessageIter _tmp185_;
	DBusMessageIter _tmp186_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "sa{ss}")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp183_);
	dbus_message_iter_next (&iter);
	search = g_strdup (_tmp183_);
	_tmp184_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&iter, &_tmp185_);
	while (dbus_message_iter_get_arg_type (&_tmp185_)) {
		char* _key;
		char* _value;
		const char* _tmp187_;
		const char* _tmp188_;
		dbus_message_iter_recurse (&_tmp185_, &_tmp186_);
		dbus_message_iter_get_basic (&_tmp186_, &_tmp187_);
		dbus_message_iter_next (&_tmp186_);
		_key = g_strdup (_tmp187_);
		dbus_message_iter_get_basic (&_tmp186_, &_tmp188_);
		dbus_message_iter_next (&_tmp186_);
		_value = g_strdup (_tmp188_);
		g_hash_table_insert (_tmp184_, _key, _value);
		dbus_message_iter_next (&_tmp185_);
	}
	dbus_message_iter_next (&iter);
	hints = _tmp184_;
	unity_place_entry_service_set_global_search (self, search, hints, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (search);
	_g_hash_table_unref0 (hints);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_entry_service_set_search (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* search = NULL;
	const char* _tmp189_;
	GHashTable* hints = NULL;
	GHashTable* _tmp190_;
	DBusMessageIter _tmp191_;
	DBusMessageIter _tmp192_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "sa{ss}")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp189_);
	dbus_message_iter_next (&iter);
	search = g_strdup (_tmp189_);
	_tmp190_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&iter, &_tmp191_);
	while (dbus_message_iter_get_arg_type (&_tmp191_)) {
		char* _key;
		char* _value;
		const char* _tmp193_;
		const char* _tmp194_;
		dbus_message_iter_recurse (&_tmp191_, &_tmp192_);
		dbus_message_iter_get_basic (&_tmp192_, &_tmp193_);
		dbus_message_iter_next (&_tmp192_);
		_key = g_strdup (_tmp193_);
		dbus_message_iter_get_basic (&_tmp192_, &_tmp194_);
		dbus_message_iter_next (&_tmp192_);
		_value = g_strdup (_tmp194_);
		g_hash_table_insert (_tmp190_, _key, _value);
		dbus_message_iter_next (&_tmp191_);
	}
	dbus_message_iter_next (&iter);
	hints = _tmp190_;
	unity_place_entry_service_set_search (self, search, hints, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (search);
	_g_hash_table_unref0 (hints);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_entry_service_set_active (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gboolean is_active = FALSE;
	dbus_bool_t _tmp195_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "b")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp195_);
	dbus_message_iter_next (&iter);
	is_active = _tmp195_;
	unity_place_entry_service_set_active (self, is_active, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_entry_service_set_active_section (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	guint section_id = 0U;
	dbus_uint32_t _tmp196_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "u")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp196_);
	dbus_message_iter_next (&iter);
	section_id = _tmp196_;
	unity_place_entry_service_set_active_section (self, section_id, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult unity_place_entry_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_unity_place_entry_service_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_unity_place_entry_service_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceEntry", "SetGlobalSearch")) {
		result = _dbus_unity_place_entry_service_set_global_search (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceEntry", "SetSearch")) {
		result = _dbus_unity_place_entry_service_set_search (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceEntry", "SetActive")) {
		result = _dbus_unity_place_entry_service_set_active (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceEntry", "SetActiveSection")) {
		result = _dbus_unity_place_entry_service_set_active_section (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _dbus_unity_place_entry_service_entry_renderer_info_changed (GObject* _sender, UnityPlace_RendererInfo* renderer_info, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	DBusMessageIter _tmp197_;
	const char* _tmp198_;
	const char* _tmp199_;
	const char* _tmp200_;
	DBusMessageIter _tmp201_, _tmp202_;
	GHashTableIter _tmp203_;
	gpointer _tmp204_, _tmp205_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.canonical.Unity.PlaceEntry", "EntryRendererInfoChanged");
	dbus_message_iter_init_append (_message, &_iter);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_STRUCT, NULL, &_tmp197_);
	_tmp198_ = (*renderer_info).default_renderer;
	dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_STRING, &_tmp198_);
	_tmp199_ = (*renderer_info).groups_model;
	dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_STRING, &_tmp199_);
	_tmp200_ = (*renderer_info).results_model;
	dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_STRING, &_tmp200_);
	dbus_message_iter_open_container (&_tmp197_, DBUS_TYPE_ARRAY, "{ss}", &_tmp201_);
	g_hash_table_iter_init (&_tmp203_, (*renderer_info).hints);
	while (g_hash_table_iter_next (&_tmp203_, &_tmp204_, &_tmp205_)) {
		char* _key;
		char* _value;
		const char* _tmp206_;
		const char* _tmp207_;
		dbus_message_iter_open_container (&_tmp201_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp202_);
		_key = (char*) _tmp204_;
		_value = (char*) _tmp205_;
		_tmp206_ = _key;
		dbus_message_iter_append_basic (&_tmp202_, DBUS_TYPE_STRING, &_tmp206_);
		_tmp207_ = _value;
		dbus_message_iter_append_basic (&_tmp202_, DBUS_TYPE_STRING, &_tmp207_);
		dbus_message_iter_close_container (&_tmp201_, &_tmp202_);
	}
	dbus_message_iter_close_container (&_tmp197_, &_tmp201_);
	dbus_message_iter_close_container (&_iter, &_tmp197_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_unity_place_entry_service_global_renderer_info_changed (GObject* _sender, UnityPlace_RendererInfo* renderer_info, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	DBusMessageIter _tmp208_;
	const char* _tmp209_;
	const char* _tmp210_;
	const char* _tmp211_;
	DBusMessageIter _tmp212_, _tmp213_;
	GHashTableIter _tmp214_;
	gpointer _tmp215_, _tmp216_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.canonical.Unity.PlaceEntry", "GlobalRendererInfoChanged");
	dbus_message_iter_init_append (_message, &_iter);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_STRUCT, NULL, &_tmp208_);
	_tmp209_ = (*renderer_info).default_renderer;
	dbus_message_iter_append_basic (&_tmp208_, DBUS_TYPE_STRING, &_tmp209_);
	_tmp210_ = (*renderer_info).groups_model;
	dbus_message_iter_append_basic (&_tmp208_, DBUS_TYPE_STRING, &_tmp210_);
	_tmp211_ = (*renderer_info).results_model;
	dbus_message_iter_append_basic (&_tmp208_, DBUS_TYPE_STRING, &_tmp211_);
	dbus_message_iter_open_container (&_tmp208_, DBUS_TYPE_ARRAY, "{ss}", &_tmp212_);
	g_hash_table_iter_init (&_tmp214_, (*renderer_info).hints);
	while (g_hash_table_iter_next (&_tmp214_, &_tmp215_, &_tmp216_)) {
		char* _key;
		char* _value;
		const char* _tmp217_;
		const char* _tmp218_;
		dbus_message_iter_open_container (&_tmp212_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp213_);
		_key = (char*) _tmp215_;
		_value = (char*) _tmp216_;
		_tmp217_ = _key;
		dbus_message_iter_append_basic (&_tmp213_, DBUS_TYPE_STRING, &_tmp217_);
		_tmp218_ = _value;
		dbus_message_iter_append_basic (&_tmp213_, DBUS_TYPE_STRING, &_tmp218_);
		dbus_message_iter_close_container (&_tmp212_, &_tmp213_);
	}
	dbus_message_iter_close_container (&_tmp208_, &_tmp212_);
	dbus_message_iter_close_container (&_iter, &_tmp208_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_unity_place_entry_service_place_entry_info_changed (GObject* _sender, UnityPlace_EntryInfoData* entry_info_data, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	DBusMessageIter _tmp219_;
	const char* _tmp220_;
	const char* _tmp221_;
	const char* _tmp222_;
	dbus_uint32_t _tmp223_;
	char** _tmp224_;
	DBusMessageIter _tmp225_;
	int _tmp226_;
	dbus_bool_t _tmp228_;
	const char* _tmp229_;
	DBusMessageIter _tmp230_, _tmp231_;
	GHashTableIter _tmp232_;
	gpointer _tmp233_, _tmp234_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.canonical.Unity.PlaceEntry", "PlaceEntryInfoChanged");
	dbus_message_iter_init_append (_message, &_iter);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_STRUCT, NULL, &_tmp219_);
	_tmp220_ = (*entry_info_data).dbus_path;
	dbus_message_iter_append_basic (&_tmp219_, DBUS_TYPE_STRING, &_tmp220_);
	_tmp221_ = (*entry_info_data).display_name;
	dbus_message_iter_append_basic (&_tmp219_, DBUS_TYPE_STRING, &_tmp221_);
	_tmp222_ = (*entry_info_data).icon;
	dbus_message_iter_append_basic (&_tmp219_, DBUS_TYPE_STRING, &_tmp222_);
	_tmp223_ = (*entry_info_data).position;
	dbus_message_iter_append_basic (&_tmp219_, DBUS_TYPE_UINT32, &_tmp223_);
	_tmp224_ = (*entry_info_data).mimetypes;
	dbus_message_iter_open_container (&_tmp219_, DBUS_TYPE_ARRAY, "s", &_tmp225_);
	for (_tmp226_ = 0; _tmp226_ < (*entry_info_data).mimetypes_length1; _tmp226_++) {
		const char* _tmp227_;
		_tmp227_ = *_tmp224_;
		dbus_message_iter_append_basic (&_tmp225_, DBUS_TYPE_STRING, &_tmp227_);
		_tmp224_++;
	}
	dbus_message_iter_close_container (&_tmp219_, &_tmp225_);
	_tmp228_ = (*entry_info_data).sensitive;
	dbus_message_iter_append_basic (&_tmp219_, DBUS_TYPE_BOOLEAN, &_tmp228_);
	_tmp229_ = (*entry_info_data).sections_model;
	dbus_message_iter_append_basic (&_tmp219_, DBUS_TYPE_STRING, &_tmp229_);
	dbus_message_iter_open_container (&_tmp219_, DBUS_TYPE_ARRAY, "{ss}", &_tmp230_);
	g_hash_table_iter_init (&_tmp232_, (*entry_info_data).hints);
	while (g_hash_table_iter_next (&_tmp232_, &_tmp233_, &_tmp234_)) {
		char* _key;
		char* _value;
		const char* _tmp235_;
		const char* _tmp236_;
		dbus_message_iter_open_container (&_tmp230_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp231_);
		_key = (char*) _tmp233_;
		_value = (char*) _tmp234_;
		_tmp235_ = _key;
		dbus_message_iter_append_basic (&_tmp231_, DBUS_TYPE_STRING, &_tmp235_);
		_tmp236_ = _value;
		dbus_message_iter_append_basic (&_tmp231_, DBUS_TYPE_STRING, &_tmp236_);
		dbus_message_iter_close_container (&_tmp230_, &_tmp231_);
	}
	dbus_message_iter_close_container (&_tmp219_, &_tmp230_);
	dbus_message_iter_close_container (&_iter, &_tmp219_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


void unity_place_entry_service_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_unity_place_entry_service_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	g_signal_connect (object, "entry-renderer-info-changed", (GCallback) _dbus_unity_place_entry_service_entry_renderer_info_changed, connection);
	g_signal_connect (object, "global-renderer-info-changed", (GCallback) _dbus_unity_place_entry_service_global_renderer_info_changed, connection);
	g_signal_connect (object, "place-entry-info-changed", (GCallback) _dbus_unity_place_entry_service_place_entry_info_changed, connection);
}


static void unity_place_entry_service_base_init (UnityPlaceEntryServiceIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("entry_renderer_info_changed", UNITY_PLACE_TYPE_ENTRY_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, UNITY_PLACE_TYPE__RENDERERINFO);
		g_signal_new ("global_renderer_info_changed", UNITY_PLACE_TYPE_ENTRY_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, UNITY_PLACE_TYPE__RENDERERINFO);
		g_signal_new ("place_entry_info_changed", UNITY_PLACE_TYPE_ENTRY_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, UNITY_PLACE_TYPE__ENTRYINFODATA);
		g_type_set_qdata (UNITY_PLACE_TYPE_ENTRY_SERVICE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_unity_place_entry_service_dbus_vtable));
	}
}


GType unity_place_entry_service_get_type (void) {
	static volatile gsize unity_place_entry_service_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_entry_service_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceEntryServiceIface), (GBaseInitFunc) unity_place_entry_service_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType unity_place_entry_service_type_id;
		unity_place_entry_service_type_id = g_type_register_static (G_TYPE_INTERFACE, "UnityPlaceEntryService", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (unity_place_entry_service_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (unity_place_entry_service_type_id, g_quark_from_string ("ValaDBusInterfaceProxyType"), &unity_place_entry_service_dbus_proxy_get_type);
		g_once_init_leave (&unity_place_entry_service_type_id__volatile, unity_place_entry_service_type_id);
	}
	return unity_place_entry_service_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (UnityPlaceEntryServiceDBusProxy, unity_place_entry_service_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE (UNITY_PLACE_TYPE_ENTRY_SERVICE, unity_place_entry_service_dbus_proxy_unity_place_entry_service__interface_init) );
UnityPlaceEntryService* unity_place_entry_service_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path) {
	UnityPlaceEntryService* self;
	self = g_object_new (unity_place_entry_service_dbus_proxy_get_type (), "connection", connection, "name", name, "path", path, "interface", "com.canonical.Unity.PlaceEntry", NULL);
	return self;
}


static GObject* unity_place_entry_service_dbus_proxy_construct (GType gtype, guint n_properties, GObjectConstructParam* properties) {
	GObject* self;
	DBusGConnection *connection;
	char* path;
	char* filter;
	self = G_OBJECT_CLASS (unity_place_entry_service_dbus_proxy_parent_class)->constructor (gtype, n_properties, properties);
	g_object_get (self, "connection", &connection, NULL);
	g_object_get (self, "path", &path, NULL);
	dbus_connection_add_filter (dbus_g_connection_get_connection (connection), unity_place_entry_service_dbus_proxy_filter, self, NULL);
	filter = g_strdup_printf ("type='signal',path='%s'", path);
	dbus_bus_add_match (dbus_g_connection_get_connection (connection), filter, NULL);
	dbus_g_connection_unref (connection);
	g_free (path);
	g_free (filter);
	return self;
}


static void _dbus_handle_unity_place_entry_service_entry_renderer_info_changed (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	UnityPlace_RendererInfo renderer_info = {0};
	UnityPlace_RendererInfo _tmp237_;
	DBusMessageIter _tmp238_;
	const char* _tmp239_;
	const char* _tmp240_;
	const char* _tmp241_;
	GHashTable* _tmp242_;
	DBusMessageIter _tmp243_;
	DBusMessageIter _tmp244_;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "(sssa{ss})")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_recurse (&iter, &_tmp238_);
	dbus_message_iter_get_basic (&_tmp238_, &_tmp239_);
	dbus_message_iter_next (&_tmp238_);
	_tmp237_.default_renderer = g_strdup (_tmp239_);
	dbus_message_iter_get_basic (&_tmp238_, &_tmp240_);
	dbus_message_iter_next (&_tmp238_);
	_tmp237_.groups_model = g_strdup (_tmp240_);
	dbus_message_iter_get_basic (&_tmp238_, &_tmp241_);
	dbus_message_iter_next (&_tmp238_);
	_tmp237_.results_model = g_strdup (_tmp241_);
	_tmp242_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&_tmp238_, &_tmp243_);
	while (dbus_message_iter_get_arg_type (&_tmp243_)) {
		char* _key;
		char* _value;
		const char* _tmp245_;
		const char* _tmp246_;
		dbus_message_iter_recurse (&_tmp243_, &_tmp244_);
		dbus_message_iter_get_basic (&_tmp244_, &_tmp245_);
		dbus_message_iter_next (&_tmp244_);
		_key = g_strdup (_tmp245_);
		dbus_message_iter_get_basic (&_tmp244_, &_tmp246_);
		dbus_message_iter_next (&_tmp244_);
		_value = g_strdup (_tmp246_);
		g_hash_table_insert (_tmp242_, _key, _value);
		dbus_message_iter_next (&_tmp243_);
	}
	dbus_message_iter_next (&_tmp238_);
	_tmp237_.hints = _tmp242_;
	dbus_message_iter_next (&iter);
	renderer_info = _tmp237_;
	g_signal_emit_by_name (self, "entry-renderer-info-changed", &renderer_info);
	unity_place__rendererinfo_destroy (&renderer_info);
}


static void _dbus_handle_unity_place_entry_service_global_renderer_info_changed (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	UnityPlace_RendererInfo renderer_info = {0};
	UnityPlace_RendererInfo _tmp247_;
	DBusMessageIter _tmp248_;
	const char* _tmp249_;
	const char* _tmp250_;
	const char* _tmp251_;
	GHashTable* _tmp252_;
	DBusMessageIter _tmp253_;
	DBusMessageIter _tmp254_;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "(sssa{ss})")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_recurse (&iter, &_tmp248_);
	dbus_message_iter_get_basic (&_tmp248_, &_tmp249_);
	dbus_message_iter_next (&_tmp248_);
	_tmp247_.default_renderer = g_strdup (_tmp249_);
	dbus_message_iter_get_basic (&_tmp248_, &_tmp250_);
	dbus_message_iter_next (&_tmp248_);
	_tmp247_.groups_model = g_strdup (_tmp250_);
	dbus_message_iter_get_basic (&_tmp248_, &_tmp251_);
	dbus_message_iter_next (&_tmp248_);
	_tmp247_.results_model = g_strdup (_tmp251_);
	_tmp252_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&_tmp248_, &_tmp253_);
	while (dbus_message_iter_get_arg_type (&_tmp253_)) {
		char* _key;
		char* _value;
		const char* _tmp255_;
		const char* _tmp256_;
		dbus_message_iter_recurse (&_tmp253_, &_tmp254_);
		dbus_message_iter_get_basic (&_tmp254_, &_tmp255_);
		dbus_message_iter_next (&_tmp254_);
		_key = g_strdup (_tmp255_);
		dbus_message_iter_get_basic (&_tmp254_, &_tmp256_);
		dbus_message_iter_next (&_tmp254_);
		_value = g_strdup (_tmp256_);
		g_hash_table_insert (_tmp252_, _key, _value);
		dbus_message_iter_next (&_tmp253_);
	}
	dbus_message_iter_next (&_tmp248_);
	_tmp247_.hints = _tmp252_;
	dbus_message_iter_next (&iter);
	renderer_info = _tmp247_;
	g_signal_emit_by_name (self, "global-renderer-info-changed", &renderer_info);
	unity_place__rendererinfo_destroy (&renderer_info);
}


static void _dbus_handle_unity_place_entry_service_place_entry_info_changed (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	UnityPlace_EntryInfoData entry_info_data = {0};
	UnityPlace_EntryInfoData _tmp257_;
	DBusMessageIter _tmp258_;
	const char* _tmp259_;
	const char* _tmp260_;
	const char* _tmp261_;
	dbus_uint32_t _tmp262_;
	char** _tmp263_;
	int _tmp263__length;
	int _tmp263__size;
	int _tmp263__length1;
	DBusMessageIter _tmp264_;
	dbus_bool_t _tmp266_;
	const char* _tmp267_;
	GHashTable* _tmp268_;
	DBusMessageIter _tmp269_;
	DBusMessageIter _tmp270_;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "(sssuasbsa{ss})")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_recurse (&iter, &_tmp258_);
	dbus_message_iter_get_basic (&_tmp258_, &_tmp259_);
	dbus_message_iter_next (&_tmp258_);
	_tmp257_.dbus_path = g_strdup (_tmp259_);
	dbus_message_iter_get_basic (&_tmp258_, &_tmp260_);
	dbus_message_iter_next (&_tmp258_);
	_tmp257_.display_name = g_strdup (_tmp260_);
	dbus_message_iter_get_basic (&_tmp258_, &_tmp261_);
	dbus_message_iter_next (&_tmp258_);
	_tmp257_.icon = g_strdup (_tmp261_);
	dbus_message_iter_get_basic (&_tmp258_, &_tmp262_);
	dbus_message_iter_next (&_tmp258_);
	_tmp257_.position = _tmp262_;
	_tmp263_ = g_new (char*, 5);
	_tmp263__length = 0;
	_tmp263__size = 4;
	_tmp263__length1 = 0;
	dbus_message_iter_recurse (&_tmp258_, &_tmp264_);
	for (; dbus_message_iter_get_arg_type (&_tmp264_); _tmp263__length1++) {
		const char* _tmp265_;
		if (_tmp263__size == _tmp263__length) {
			_tmp263__size = 2 * _tmp263__size;
			_tmp263_ = g_renew (char*, _tmp263_, _tmp263__size + 1);
		}
		dbus_message_iter_get_basic (&_tmp264_, &_tmp265_);
		dbus_message_iter_next (&_tmp264_);
		_tmp263_[_tmp263__length++] = g_strdup (_tmp265_);
	}
	_tmp257_.mimetypes_length1 = _tmp263__length1;
	_tmp263_[_tmp263__length] = NULL;
	dbus_message_iter_next (&_tmp258_);
	_tmp257_.mimetypes = _tmp263_;
	dbus_message_iter_get_basic (&_tmp258_, &_tmp266_);
	dbus_message_iter_next (&_tmp258_);
	_tmp257_.sensitive = _tmp266_;
	dbus_message_iter_get_basic (&_tmp258_, &_tmp267_);
	dbus_message_iter_next (&_tmp258_);
	_tmp257_.sections_model = g_strdup (_tmp267_);
	_tmp268_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&_tmp258_, &_tmp269_);
	while (dbus_message_iter_get_arg_type (&_tmp269_)) {
		char* _key;
		char* _value;
		const char* _tmp271_;
		const char* _tmp272_;
		dbus_message_iter_recurse (&_tmp269_, &_tmp270_);
		dbus_message_iter_get_basic (&_tmp270_, &_tmp271_);
		dbus_message_iter_next (&_tmp270_);
		_key = g_strdup (_tmp271_);
		dbus_message_iter_get_basic (&_tmp270_, &_tmp272_);
		dbus_message_iter_next (&_tmp270_);
		_value = g_strdup (_tmp272_);
		g_hash_table_insert (_tmp268_, _key, _value);
		dbus_message_iter_next (&_tmp269_);
	}
	dbus_message_iter_next (&_tmp258_);
	_tmp257_.hints = _tmp268_;
	dbus_message_iter_next (&iter);
	entry_info_data = _tmp257_;
	g_signal_emit_by_name (self, "place-entry-info-changed", &entry_info_data);
	unity_place__entryinfodata_destroy (&entry_info_data);
}


DBusHandlerResult unity_place_entry_service_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data) {
	if (dbus_message_has_path (message, dbus_g_proxy_get_path (user_data))) {
		if (dbus_message_is_signal (message, "com.canonical.Unity.PlaceEntry", "EntryRendererInfoChanged")) {
			_dbus_handle_unity_place_entry_service_entry_renderer_info_changed (user_data, connection, message);
		} else if (dbus_message_is_signal (message, "com.canonical.Unity.PlaceEntry", "GlobalRendererInfoChanged")) {
			_dbus_handle_unity_place_entry_service_global_renderer_info_changed (user_data, connection, message);
		} else if (dbus_message_is_signal (message, "com.canonical.Unity.PlaceEntry", "PlaceEntryInfoChanged")) {
			_dbus_handle_unity_place_entry_service_place_entry_info_changed (user_data, connection, message);
		}
	}
	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void unity_place_entry_service_dbus_proxy_dispose (GObject* self) {
	DBusGConnection *connection;
	if (((UnityPlaceEntryServiceDBusProxy*) self)->disposed) {
		return;
	}
	((UnityPlaceEntryServiceDBusProxy*) self)->disposed = TRUE;
	g_object_get (self, "connection", &connection, NULL);
	dbus_connection_remove_filter (dbus_g_connection_get_connection (connection), unity_place_entry_service_dbus_proxy_filter, self);
	G_OBJECT_CLASS (unity_place_entry_service_dbus_proxy_parent_class)->dispose (self);
}


static void unity_place_entry_service_dbus_proxy_class_init (UnityPlaceEntryServiceDBusProxyClass* klass) {
	G_OBJECT_CLASS (klass)->constructor = unity_place_entry_service_dbus_proxy_construct;
	G_OBJECT_CLASS (klass)->dispose = unity_place_entry_service_dbus_proxy_dispose;
	G_OBJECT_CLASS (klass)->get_property = unity_place_entry_service_dbus_proxy_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_entry_service_dbus_proxy_set_property;
}


static void unity_place_entry_service_dbus_proxy_init (UnityPlaceEntryServiceDBusProxy* self) {
}


static void unity_place_entry_service_dbus_proxy_set_global_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	const char* _tmp273_;
	DBusMessageIter _tmp274_, _tmp275_;
	GHashTableIter _tmp276_;
	gpointer _tmp277_, _tmp278_;
	if (((UnityPlaceEntryServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceEntry", "SetGlobalSearch");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp273_ = search;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp273_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_ARRAY, "{ss}", &_tmp274_);
	g_hash_table_iter_init (&_tmp276_, hints);
	while (g_hash_table_iter_next (&_tmp276_, &_tmp277_, &_tmp278_)) {
		char* _key;
		char* _value;
		const char* _tmp279_;
		const char* _tmp280_;
		dbus_message_iter_open_container (&_tmp274_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp275_);
		_key = (char*) _tmp277_;
		_value = (char*) _tmp278_;
		_tmp279_ = _key;
		dbus_message_iter_append_basic (&_tmp275_, DBUS_TYPE_STRING, &_tmp279_);
		_tmp280_ = _value;
		dbus_message_iter_append_basic (&_tmp275_, DBUS_TYPE_STRING, &_tmp280_);
		dbus_message_iter_close_container (&_tmp274_, &_tmp275_);
	}
	dbus_message_iter_close_container (&_iter, &_tmp274_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp281_;
			_edomain = DBUS_GERROR;
			_tmp281_ = _dbus_error.name + 27;
			if (strcmp (_tmp281_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp281_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp281_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp281_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp281_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp281_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp281_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp281_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp281_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp281_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp281_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp281_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp281_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp281_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp281_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp281_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp281_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp281_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp281_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp281_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp281_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp281_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp281_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp281_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp281_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp281_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp281_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp281_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp281_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp281_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp281_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp281_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp281_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void unity_place_entry_service_dbus_proxy_set_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	const char* _tmp282_;
	DBusMessageIter _tmp283_, _tmp284_;
	GHashTableIter _tmp285_;
	gpointer _tmp286_, _tmp287_;
	if (((UnityPlaceEntryServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceEntry", "SetSearch");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp282_ = search;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp282_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_ARRAY, "{ss}", &_tmp283_);
	g_hash_table_iter_init (&_tmp285_, hints);
	while (g_hash_table_iter_next (&_tmp285_, &_tmp286_, &_tmp287_)) {
		char* _key;
		char* _value;
		const char* _tmp288_;
		const char* _tmp289_;
		dbus_message_iter_open_container (&_tmp283_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp284_);
		_key = (char*) _tmp286_;
		_value = (char*) _tmp287_;
		_tmp288_ = _key;
		dbus_message_iter_append_basic (&_tmp284_, DBUS_TYPE_STRING, &_tmp288_);
		_tmp289_ = _value;
		dbus_message_iter_append_basic (&_tmp284_, DBUS_TYPE_STRING, &_tmp289_);
		dbus_message_iter_close_container (&_tmp283_, &_tmp284_);
	}
	dbus_message_iter_close_container (&_iter, &_tmp283_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp290_;
			_edomain = DBUS_GERROR;
			_tmp290_ = _dbus_error.name + 27;
			if (strcmp (_tmp290_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp290_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp290_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp290_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp290_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp290_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp290_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp290_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp290_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp290_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp290_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp290_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp290_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp290_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp290_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp290_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp290_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp290_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp290_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp290_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp290_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp290_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp290_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp290_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp290_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp290_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp290_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp290_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp290_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp290_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp290_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp290_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp290_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void unity_place_entry_service_dbus_proxy_set_active (UnityPlaceEntryService* self, gboolean is_active, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	dbus_bool_t _tmp291_;
	if (((UnityPlaceEntryServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceEntry", "SetActive");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp291_ = is_active;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_BOOLEAN, &_tmp291_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp292_;
			_edomain = DBUS_GERROR;
			_tmp292_ = _dbus_error.name + 27;
			if (strcmp (_tmp292_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp292_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp292_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp292_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp292_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp292_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp292_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp292_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp292_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp292_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp292_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp292_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp292_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp292_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp292_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp292_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp292_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp292_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp292_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp292_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp292_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp292_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp292_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp292_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp292_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp292_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp292_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp292_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp292_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp292_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp292_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp292_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp292_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void unity_place_entry_service_dbus_proxy_set_active_section (UnityPlaceEntryService* self, guint section_id, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	dbus_uint32_t _tmp293_;
	if (((UnityPlaceEntryServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceEntry", "SetActiveSection");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp293_ = section_id;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT32, &_tmp293_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp294_;
			_edomain = DBUS_GERROR;
			_tmp294_ = _dbus_error.name + 27;
			if (strcmp (_tmp294_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp294_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp294_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp294_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp294_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp294_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp294_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp294_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp294_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp294_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp294_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp294_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp294_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp294_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp294_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp294_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp294_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp294_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp294_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp294_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp294_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp294_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp294_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp294_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp294_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp294_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp294_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp294_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp294_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp294_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp294_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp294_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp294_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void unity_place_entry_service_dbus_proxy_unity_place_entry_service__interface_init (UnityPlaceEntryServiceIface* iface) {
	iface->set_global_search = unity_place_entry_service_dbus_proxy_set_global_search;
	iface->set_search = unity_place_entry_service_dbus_proxy_set_search;
	iface->set_active = unity_place_entry_service_dbus_proxy_set_active;
	iface->set_active_section = unity_place_entry_service_dbus_proxy_set_active_section;
}


static void unity_place_entry_service_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
}


static void unity_place_entry_service_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
}


UnityPlaceServiceImpl* unity_place_service_impl_construct (GType object_type, const char* dbus_path) {
	UnityPlaceServiceImpl * self;
	g_return_val_if_fail (dbus_path != NULL, NULL);
	self = (UnityPlaceServiceImpl*) g_object_new (object_type, "dbus-path", dbus_path, NULL);
	return self;
}


UnityPlaceServiceImpl* unity_place_service_impl_new (const char* dbus_path) {
	return unity_place_service_impl_construct (UNITY_PLACE_TYPE_SERVICE_IMPL, dbus_path);
}


static UnityPlace_EntryInfo* unity_place_service_impl_real_get_entries (UnityPlaceService* base, int* result_length1, GError** error) {
	UnityPlaceServiceImpl * self;
	UnityPlace_EntryInfo* result = NULL;
	UnityPlace_EntryInfo* _tmp1_;
	gint __result__size_;
	gint _result__length1;
	gint _tmp0_;
	UnityPlace_EntryInfo* _result_;
	gint i;
	UnityPlace_EntryInfo* _tmp4_;
	self = (UnityPlaceServiceImpl*) base;
	_result_ = (_tmp1_ = g_new0 (UnityPlace_EntryInfo, _tmp0_ = g_hash_table_size (self->priv->entries)), _result__length1 = _tmp0_, __result__size_ = _result__length1, _tmp1_);
	i = 0;
	{
		GList* entry_collection;
		GList* entry_it;
		entry_collection = g_hash_table_get_values (self->priv->entries);
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			UnityPlaceEntryServiceImpl* entry;
			entry = (UnityPlaceEntryServiceImpl*) entry_it->data;
			{
				UnityPlace_EntryInfo _tmp3_;
				UnityPlace_EntryInfo _tmp2_ = {0};
				_result_[i] = (_tmp3_ = (unity_place_entry_info_get_raw (unity_place_entry_service_impl_get_entry_info (entry), &_tmp2_), _tmp2_), unity_place__entryinfo_destroy (&_result_[i]), _tmp3_);
				i++;
			}
		}
		_g_list_free0 (entry_collection);
	}
	result = (_tmp4_ = _result_, *result_length1 = _result__length1, _tmp4_);
	return result;
	_result_ = (_vala_UnityPlace_EntryInfo_array_free (_result_, _result__length1), NULL);
}


void unity_place_service_impl_add_entry (UnityPlaceServiceImpl* self, UnityPlaceEntryInfo* entry_info) {
	GError * _inner_error_;
	UnityPlaceEntryServiceImpl* entry;
	UnityPlace_EntryInfo _tmp2_;
	UnityPlace_EntryInfo _tmp1_;
	UnityPlace_EntryInfo _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry_info != NULL);
	_inner_error_ = NULL;
	if (((UnityPlaceEntryServiceImpl*) g_hash_table_lookup (self->priv->entries, unity_place_entry_info_get_dbus_path (entry_info))) != NULL) {
		return;
	}
	entry = unity_place_entry_service_impl_new (entry_info);
	g_hash_table_insert (self->priv->entries, g_strdup (unity_place_entry_info_get_dbus_path (entry_info)), _g_object_ref0 (entry));
	if (self->priv->_exported) {
		{
			unity_place_entry_service_impl_export (entry, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == DBUS_GERROR) {
					goto __catch30_dbus_gerror;
				}
				_g_object_unref0 (entry);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		goto __finally30;
		__catch30_dbus_gerror:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				g_critical ("unity-place.vala:516: Failed to export place entry '%s': %s", unity_place_entry_info_get_dbus_path (entry_info), e->message);
				_g_error_free0 (e);
			}
		}
		__finally30:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (entry);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	g_signal_emit_by_name ((UnityPlaceService*) self, "entry-added", (_tmp2_ = _tmp1_ = (unity_place_entry_info_get_raw (entry_info, &_tmp0_), _tmp0_), &_tmp2_));
	unity_place__entryinfo_destroy (&_tmp1_);
	_g_object_unref0 (entry);
}


UnityPlaceEntryInfo* unity_place_service_impl_get_entry (UnityPlaceServiceImpl* self, const char* dbus_path) {
	UnityPlaceEntryInfo* result = NULL;
	UnityPlaceEntryServiceImpl* entry;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (dbus_path != NULL, NULL);
	entry = _g_object_ref0 ((UnityPlaceEntryServiceImpl*) g_hash_table_lookup (self->priv->entries, dbus_path));
	if (entry != NULL) {
		result = _g_object_ref0 (unity_place_entry_service_impl_get_entry_info (entry));
		_g_object_unref0 (entry);
		return result;
	} else {
		result = NULL;
		_g_object_unref0 (entry);
		return result;
	}
	_g_object_unref0 (entry);
}


UnityPlaceEntryServiceImpl* unity_place_service_impl_get_entry_service (UnityPlaceServiceImpl* self, const char* dbus_path) {
	UnityPlaceEntryServiceImpl* result = NULL;
	UnityPlaceEntryServiceImpl* entry;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (dbus_path != NULL, NULL);
	entry = _g_object_ref0 ((UnityPlaceEntryServiceImpl*) g_hash_table_lookup (self->priv->entries, dbus_path));
	if (entry != NULL) {
		result = entry;
		return result;
	} else {
		result = NULL;
		_g_object_unref0 (entry);
		return result;
	}
	_g_object_unref0 (entry);
}


guint unity_place_service_impl_num_entries (UnityPlaceServiceImpl* self) {
	guint result = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	result = g_hash_table_size (self->priv->entries);
	return result;
}


char** unity_place_service_impl_get_entry_paths (UnityPlaceServiceImpl* self, int* result_length1) {
	char** result = NULL;
	char** _tmp1_;
	gint __result__size_;
	gint _result__length1;
	gint _tmp0_;
	char** _result_;
	gint i;
	char** _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = (_tmp1_ = g_new0 (char*, (_tmp0_ = g_hash_table_size (self->priv->entries)) + 1), _result__length1 = _tmp0_, __result__size_ = _result__length1, _tmp1_);
	i = 0;
	{
		GList* entry_collection;
		GList* entry_it;
		entry_collection = g_hash_table_get_values (self->priv->entries);
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			UnityPlaceEntryServiceImpl* entry;
			entry = (UnityPlaceEntryServiceImpl*) entry_it->data;
			{
				char* _tmp2_;
				_result_[i] = (_tmp2_ = g_strdup (unity_place_entry_info_get_dbus_path (unity_place_entry_service_impl_get_entry_info (entry))), _g_free0 (_result_[i]), _tmp2_);
				i++;
			}
		}
		_g_list_free0 (entry_collection);
	}
	result = (_tmp3_ = _result_, *result_length1 = _result__length1, _tmp3_);
	return result;
	_result_ = (_vala_array_free (_result_, _result__length1, (GDestroyNotify) g_free), NULL);
}


void unity_place_service_impl_remove_entry (UnityPlaceServiceImpl* self, const char* dbus_path) {
	GError * _inner_error_;
	UnityPlaceEntryServiceImpl* entry;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dbus_path != NULL);
	_inner_error_ = NULL;
	entry = _g_object_ref0 ((UnityPlaceEntryServiceImpl*) g_hash_table_lookup (self->priv->entries, dbus_path));
	if (entry == NULL) {
		_g_object_unref0 (entry);
		return;
	}
	g_signal_emit_by_name ((UnityPlaceService*) self, "entry-removed", dbus_path);
	if (self->priv->_exported) {
		{
			unity_place_entry_service_impl_unexport (entry, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == DBUS_GERROR) {
					goto __catch31_dbus_gerror;
				}
				_g_object_unref0 (entry);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		goto __finally31;
		__catch31_dbus_gerror:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				g_critical ("unity-place.vala:573: Failed to unexport place entry '%s': %s", unity_place_entry_info_get_dbus_path (unity_place_entry_service_impl_get_entry_info (entry)), e->message);
				_g_error_free0 (e);
			}
		}
		__finally31:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (entry);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	g_hash_table_remove (self->priv->entries, dbus_path);
	_g_object_unref0 (entry);
}


void unity_place_service_impl_export (UnityPlaceServiceImpl* self, GError** error) {
	GError * _inner_error_;
	DBusGConnection* conn;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	conn = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DBUS_GERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_vala_dbus_register_object (dbus_g_connection_get_connection (conn), self->priv->_dbus_path, (GObject*) self);
	{
		GList* entry_collection;
		GList* entry_it;
		entry_collection = g_hash_table_get_values (self->priv->entries);
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			UnityPlaceEntryServiceImpl* entry;
			entry = (UnityPlaceEntryServiceImpl*) entry_it->data;
			{
				unity_place_entry_service_impl_export (entry, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == DBUS_GERROR) {
						g_propagate_error (error, _inner_error_);
						_g_list_free0 (entry_collection);
						_dbus_g_connection_unref0 (conn);
						return;
					} else {
						_g_list_free0 (entry_collection);
						_dbus_g_connection_unref0 (conn);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
		}
		_g_list_free0 (entry_collection);
	}
	self->priv->_exported = TRUE;
	g_object_notify ((GObject*) self, "exported");
	_dbus_g_connection_unref0 (conn);
}


void unity_place_service_impl_unexport (UnityPlaceServiceImpl* self, GError** error) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	{
		GList* entry_collection;
		GList* entry_it;
		entry_collection = g_hash_table_get_values (self->priv->entries);
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			UnityPlaceEntryServiceImpl* entry;
			entry = (UnityPlaceEntryServiceImpl*) entry_it->data;
			{
				unity_place_entry_service_impl_unexport (entry, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == DBUS_GERROR) {
						g_propagate_error (error, _inner_error_);
						_g_list_free0 (entry_collection);
						return;
					} else {
						_g_list_free0 (entry_collection);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
		}
		_g_list_free0 (entry_collection);
	}
	self->priv->_exported = FALSE;
	g_object_notify ((GObject*) self, "exported");
}


const char* unity_place_service_impl_get_dbus_path (UnityPlaceServiceImpl* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_dbus_path;
	return result;
}


static void unity_place_service_impl_set_dbus_path (UnityPlaceServiceImpl* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_dbus_path = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_dbus_path), _tmp0_);
	g_object_notify ((GObject *) self, "dbus-path");
}


gboolean unity_place_service_impl_get_exported (UnityPlaceServiceImpl* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_exported;
	return result;
}


static GObject * unity_place_service_impl_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityPlaceServiceImpl * self;
	parent_class = G_OBJECT_CLASS (unity_place_service_impl_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_PLACE_SERVICE_IMPL (obj);
	{
		GHashTable* _tmp295_;
		self->priv->entries = (_tmp295_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref), _g_hash_table_unref0 (self->priv->entries), _tmp295_);
	}
	return obj;
}


void _unity_place_service_impl_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_unity_place_service_impl_introspect (UnityPlaceServiceImpl* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.canonical.Unity.Place\">\n  <method name=\"GetEntries\">\n    <arg name=\"result\" type=\"a(sssuasbsa{ss}(sssa{ss})(sssa{ss}))\" direction=\"out\"/>\n  </method>\n  <signal name=\"EntryAdded\">\n    <arg name=\"entry\" type=\"(sssuasbsa{ss}(sssa{ss})(sssa{ss}))\"/>\n  </signal>\n  <signal name=\"EntryRemoved\">\n    <arg name=\"entry_dbus_path\" type=\"s\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult unity_place_service_impl_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_unity_place_service_impl_introspect (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else if (unity_place_service_dbus_message (connection, message, object) == DBUS_HANDLER_RESULT_HANDLED) {
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


void unity_place_service_impl_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_unity_place_service_impl_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	unity_place_service_dbus_register_object (connection, path, object);
}


static void unity_place_service_impl_class_init (UnityPlaceServiceImplClass * klass) {
	unity_place_service_impl_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceServiceImplPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_service_impl_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_service_impl_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_place_service_impl_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_place_service_impl_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_SERVICE_IMPL_DBUS_PATH, g_param_spec_string ("dbus-path", "dbus-path", "dbus-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_SERVICE_IMPL_EXPORTED, g_param_spec_boolean ("exported", "exported", "exported", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_type_set_qdata (UNITY_PLACE_TYPE_SERVICE_IMPL, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_unity_place_service_impl_dbus_vtable));
}


static void unity_place_service_impl_unity_place_service_interface_init (UnityPlaceServiceIface * iface) {
	unity_place_service_impl_unity_place_service_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_entries = unity_place_service_impl_real_get_entries;
}


static void unity_place_service_impl_instance_init (UnityPlaceServiceImpl * self) {
	self->priv = UNITY_PLACE_SERVICE_IMPL_GET_PRIVATE (self);
}


static void unity_place_service_impl_finalize (GObject* obj) {
	UnityPlaceServiceImpl * self;
	self = UNITY_PLACE_SERVICE_IMPL (obj);
	_g_free0 (self->priv->_dbus_path);
	_g_hash_table_unref0 (self->priv->entries);
	G_OBJECT_CLASS (unity_place_service_impl_parent_class)->finalize (obj);
}


GType unity_place_service_impl_get_type (void) {
	static volatile gsize unity_place_service_impl_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_service_impl_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceServiceImplClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_service_impl_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceServiceImpl), 0, (GInstanceInitFunc) unity_place_service_impl_instance_init, NULL };
		static const GInterfaceInfo unity_place_service_info = { (GInterfaceInitFunc) unity_place_service_impl_unity_place_service_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType unity_place_service_impl_type_id;
		unity_place_service_impl_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceServiceImpl", &g_define_type_info, 0);
		g_type_add_interface_static (unity_place_service_impl_type_id, UNITY_PLACE_TYPE_SERVICE, &unity_place_service_info);
		g_once_init_leave (&unity_place_service_impl_type_id__volatile, unity_place_service_impl_type_id);
	}
	return unity_place_service_impl_type_id__volatile;
}


static void unity_place_service_impl_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceServiceImpl * self;
	self = UNITY_PLACE_SERVICE_IMPL (object);
	switch (property_id) {
		case UNITY_PLACE_SERVICE_IMPL_DBUS_PATH:
		g_value_set_string (value, unity_place_service_impl_get_dbus_path (self));
		break;
		case UNITY_PLACE_SERVICE_IMPL_EXPORTED:
		g_value_set_boolean (value, unity_place_service_impl_get_exported (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_service_impl_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceServiceImpl * self;
	self = UNITY_PLACE_SERVICE_IMPL (object);
	switch (property_id) {
		case UNITY_PLACE_SERVICE_IMPL_DBUS_PATH:
		unity_place_service_impl_set_dbus_path (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


UnityPlaceEntryServiceImpl* unity_place_entry_service_impl_construct (GType object_type, UnityPlaceEntryInfo* entry_info) {
	UnityPlaceEntryServiceImpl * self;
	g_return_val_if_fail (entry_info != NULL, NULL);
	self = (UnityPlaceEntryServiceImpl*) g_object_new (object_type, "entry-info", entry_info, NULL);
	return self;
}


UnityPlaceEntryServiceImpl* unity_place_entry_service_impl_new (UnityPlaceEntryInfo* entry_info) {
	return unity_place_entry_service_impl_construct (UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, entry_info);
}


static void unity_place_entry_service_impl_real_set_global_search (UnityPlaceEntryService* base, const char* search, GHashTable* hints, GError** error) {
	UnityPlaceEntryServiceImpl * self;
	UnityPlaceSearch* _tmp0_;
	self = (UnityPlaceEntryServiceImpl*) base;
	g_return_if_fail (search != NULL);
	g_return_if_fail (hints != NULL);
	unity_place_entry_info_set_active_global_search (self->priv->_entry_info, _tmp0_ = g_object_ref_sink (unity_place_search_new (search, hints)));
	_g_object_unref0 (_tmp0_);
}


static void unity_place_entry_service_impl_real_set_search (UnityPlaceEntryService* base, const char* search, GHashTable* hints, GError** error) {
	UnityPlaceEntryServiceImpl * self;
	UnityPlaceSearch* _tmp0_;
	self = (UnityPlaceEntryServiceImpl*) base;
	g_return_if_fail (search != NULL);
	g_return_if_fail (hints != NULL);
	unity_place_entry_info_set_active_search (self->priv->_entry_info, _tmp0_ = g_object_ref_sink (unity_place_search_new (search, hints)));
	_g_object_unref0 (_tmp0_);
}


static void unity_place_entry_service_impl_real_set_active (UnityPlaceEntryService* base, gboolean is_active, GError** error) {
	UnityPlaceEntryServiceImpl * self;
	self = (UnityPlaceEntryServiceImpl*) base;
	unity_place_entry_info_set_active (self->priv->_entry_info, is_active);
}


static void unity_place_entry_service_impl_real_set_active_section (UnityPlaceEntryService* base, guint section_id, GError** error) {
	UnityPlaceEntryServiceImpl * self;
	self = (UnityPlaceEntryServiceImpl*) base;
	unity_place_entry_info_set_active_section (self->priv->_entry_info, section_id);
}


void unity_place_entry_service_impl_export (UnityPlaceEntryServiceImpl* self, GError** error) {
	GError * _inner_error_;
	DBusGConnection* conn;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	conn = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DBUS_GERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_vala_dbus_register_object (dbus_g_connection_get_connection (conn), unity_place_entry_info_get_dbus_path (self->priv->_entry_info), (GObject*) self);
	self->priv->_exported = TRUE;
	g_object_notify ((GObject*) self, "exported");
	_dbus_g_connection_unref0 (conn);
}


void unity_place_entry_service_impl_unexport (UnityPlaceEntryServiceImpl* self, GError** error) {
	g_return_if_fail (self != NULL);
	self->priv->_exported = FALSE;
	g_object_notify ((GObject*) self, "exported");
}


UnityPlaceEntryInfo* unity_place_entry_service_impl_get_entry_info (UnityPlaceEntryServiceImpl* self) {
	UnityPlaceEntryInfo* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_entry_info;
	return result;
}


static void unity_place_entry_service_impl_set_entry_info (UnityPlaceEntryServiceImpl* self, UnityPlaceEntryInfo* value) {
	UnityPlaceEntryInfo* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_entry_info = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_entry_info), _tmp0_);
	g_object_notify ((GObject *) self, "entry-info");
}


gboolean unity_place_entry_service_impl_get_exported (UnityPlaceEntryServiceImpl* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_exported;
	return result;
}


void _unity_place_entry_service_impl_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_unity_place_entry_service_impl_introspect (UnityPlaceEntryServiceImpl* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.canonical.Unity.PlaceEntry\">\n  <method name=\"SetGlobalSearch\">\n    <arg name=\"search\" type=\"s\" direction=\"in\"/>\n    <arg name=\"hints\" type=\"a{ss}\" direction=\"in\"/>\n  </method>\n  <method name=\"SetSearch\">\n    <arg name=\"search\" type=\"s\" direction=\"in\"/>\n    <arg name=\"hints\" type=\"a{ss}\" direction=\"in\"/>\n  </method>\n  <method name=\"SetActive\">\n    <arg name=\"is_active\" type=\"b\" direction=\"in\"/>\n  </method>\n  <method name=\"SetActiveSection\">\n    <arg name=\"section_id\" type=\"u\" direction=\"in\"/>\n  </method>\n  <signal name=\"EntryRendererInfoChanged\">\n    <arg name=\"renderer_info\" type=\"(sssa{ss})\"/>\n  </signal>\n  <signal name=\"GlobalRendererInfoChanged\">\n    <arg name=\"renderer_info\" type=\"(sssa{ss})\"/>\n  </signal>\n  <signal name=\"PlaceEntryInfoChanged\">\n    <arg name=\"entry_info_data\" type=\"(sssuasbsa{ss})\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult unity_place_entry_service_impl_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_unity_place_entry_service_impl_introspect (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else if (unity_place_entry_service_dbus_message (connection, message, object) == DBUS_HANDLER_RESULT_HANDLED) {
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


void unity_place_entry_service_impl_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_unity_place_entry_service_impl_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	unity_place_entry_service_dbus_register_object (connection, path, object);
}


static void unity_place_entry_service_impl_class_init (UnityPlaceEntryServiceImplClass * klass) {
	unity_place_entry_service_impl_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceEntryServiceImplPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_entry_service_impl_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_entry_service_impl_set_property;
	G_OBJECT_CLASS (klass)->finalize = unity_place_entry_service_impl_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_SERVICE_IMPL_ENTRY_INFO, g_param_spec_object ("entry-info", "entry-info", "entry-info", UNITY_PLACE_TYPE_ENTRY_INFO, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_SERVICE_IMPL_EXPORTED, g_param_spec_boolean ("exported", "exported", "exported", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_type_set_qdata (UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_unity_place_entry_service_impl_dbus_vtable));
}


static void unity_place_entry_service_impl_unity_place_entry_service_interface_init (UnityPlaceEntryServiceIface * iface) {
	unity_place_entry_service_impl_unity_place_entry_service_parent_iface = g_type_interface_peek_parent (iface);
	iface->set_global_search = unity_place_entry_service_impl_real_set_global_search;
	iface->set_search = unity_place_entry_service_impl_real_set_search;
	iface->set_active = unity_place_entry_service_impl_real_set_active;
	iface->set_active_section = unity_place_entry_service_impl_real_set_active_section;
}


static void unity_place_entry_service_impl_instance_init (UnityPlaceEntryServiceImpl * self) {
	self->priv = UNITY_PLACE_ENTRY_SERVICE_IMPL_GET_PRIVATE (self);
	self->priv->_exported = FALSE;
}


static void unity_place_entry_service_impl_finalize (GObject* obj) {
	UnityPlaceEntryServiceImpl * self;
	self = UNITY_PLACE_ENTRY_SERVICE_IMPL (obj);
	_g_object_unref0 (self->priv->_entry_info);
	G_OBJECT_CLASS (unity_place_entry_service_impl_parent_class)->finalize (obj);
}


GType unity_place_entry_service_impl_get_type (void) {
	static volatile gsize unity_place_entry_service_impl_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_entry_service_impl_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceEntryServiceImplClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_entry_service_impl_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceEntryServiceImpl), 0, (GInstanceInitFunc) unity_place_entry_service_impl_instance_init, NULL };
		static const GInterfaceInfo unity_place_entry_service_info = { (GInterfaceInitFunc) unity_place_entry_service_impl_unity_place_entry_service_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType unity_place_entry_service_impl_type_id;
		unity_place_entry_service_impl_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceEntryServiceImpl", &g_define_type_info, 0);
		g_type_add_interface_static (unity_place_entry_service_impl_type_id, UNITY_PLACE_TYPE_ENTRY_SERVICE, &unity_place_entry_service_info);
		g_once_init_leave (&unity_place_entry_service_impl_type_id__volatile, unity_place_entry_service_impl_type_id);
	}
	return unity_place_entry_service_impl_type_id__volatile;
}


static void unity_place_entry_service_impl_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceEntryServiceImpl * self;
	self = UNITY_PLACE_ENTRY_SERVICE_IMPL (object);
	switch (property_id) {
		case UNITY_PLACE_ENTRY_SERVICE_IMPL_ENTRY_INFO:
		g_value_set_object (value, unity_place_entry_service_impl_get_entry_info (self));
		break;
		case UNITY_PLACE_ENTRY_SERVICE_IMPL_EXPORTED:
		g_value_set_boolean (value, unity_place_entry_service_impl_get_exported (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_entry_service_impl_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceEntryServiceImpl * self;
	self = UNITY_PLACE_ENTRY_SERVICE_IMPL (object);
	switch (property_id) {
		case UNITY_PLACE_ENTRY_SERVICE_IMPL_ENTRY_INFO:
		unity_place_entry_service_impl_set_entry_info (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


UnityPlace_EntrySignals* unity_place__entrysignals_dup (const UnityPlace_EntrySignals* self) {
	UnityPlace_EntrySignals* dup;
	dup = g_new0 (UnityPlace_EntrySignals, 1);
	memcpy (dup, self, sizeof (UnityPlace_EntrySignals));
	return dup;
}


void unity_place__entrysignals_free (UnityPlace_EntrySignals* self) {
	g_free (self);
}


GType unity_place__entrysignals_get_type (void) {
	static volatile gsize unity_place__entrysignals_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place__entrysignals_type_id__volatile)) {
		GType unity_place__entrysignals_type_id;
		unity_place__entrysignals_type_id = g_boxed_type_register_static ("UnityPlace_EntrySignals", (GBoxedCopyFunc) unity_place__entrysignals_dup, (GBoxedFreeFunc) unity_place__entrysignals_free);
		g_once_init_leave (&unity_place__entrysignals_type_id__volatile, unity_place__entrysignals_type_id);
	}
	return unity_place__entrysignals_type_id__volatile;
}


UnityPlaceController* unity_place_controller_construct (GType object_type, const char* dbus_path) {
	UnityPlaceController * self;
	g_return_val_if_fail (dbus_path != NULL, NULL);
	self = (UnityPlaceController*) g_object_new (object_type, "dbus-path", dbus_path, NULL);
	return self;
}


UnityPlaceController* unity_place_controller_new (const char* dbus_path) {
	return unity_place_controller_construct (UNITY_PLACE_TYPE_CONTROLLER, dbus_path);
}


static void _unity_place_controller_on_entry_changed_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	unity_place_controller_on_entry_changed (self, _sender, pspec);
}


static void _lambda2_ (GObject* obj, GParamSpec* pspec, Block1Data* _data1_) {
	UnityPlaceController * self;
	GObject* _tmp0_;
	UnityPlaceRendererInfo* renderer_info;
	UnityPlaceEntryServiceImpl* entry_service;
	self = _data1_->self;
	g_return_if_fail (obj != NULL);
	g_return_if_fail (pspec != NULL);
	renderer_info = _g_object_ref0 ((_tmp0_ = obj, UNITY_PLACE_IS_RENDERER_INFO (_tmp0_) ? ((UnityPlaceRendererInfo*) _tmp0_) : NULL));
	entry_service = unity_place_service_impl_get_entry_service (self->priv->service, unity_place_entry_info_get_dbus_path (_data1_->entry));
	if (entry_service == NULL) {
		g_warning ("unity-place.vala:764: Entry renderer info changed for unknown entry '%" \
"s'", unity_place_entry_info_get_dbus_path (_data1_->entry));
	} else {
		UnityPlace_RendererInfo _tmp3_;
		UnityPlace_RendererInfo _tmp2_;
		UnityPlace_RendererInfo _tmp1_ = {0};
		g_signal_emit_by_name ((UnityPlaceEntryService*) entry_service, "entry-renderer-info-changed", (_tmp3_ = _tmp2_ = (unity_place_renderer_info_get_raw (renderer_info, &_tmp1_), _tmp1_), &_tmp3_));
		unity_place__rendererinfo_destroy (&_tmp2_);
	}
	_g_object_unref0 (entry_service);
	_g_object_unref0 (renderer_info);
}


static void __lambda2__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_lambda2_ (_sender, pspec, self);
}


static void _lambda3_ (GObject* obj, GParamSpec* pspec, Block1Data* _data1_) {
	UnityPlaceController * self;
	GObject* _tmp0_;
	UnityPlaceRendererInfo* renderer_info;
	UnityPlaceEntryServiceImpl* entry_service;
	self = _data1_->self;
	g_return_if_fail (obj != NULL);
	g_return_if_fail (pspec != NULL);
	renderer_info = _g_object_ref0 ((_tmp0_ = obj, UNITY_PLACE_IS_RENDERER_INFO (_tmp0_) ? ((UnityPlaceRendererInfo*) _tmp0_) : NULL));
	entry_service = unity_place_service_impl_get_entry_service (self->priv->service, unity_place_entry_info_get_dbus_path (_data1_->entry));
	if (entry_service == NULL) {
		g_warning ("unity-place.vala:780: Global renderer info changed for unknown entry '" \
"%s'", unity_place_entry_info_get_dbus_path (_data1_->entry));
	} else {
		UnityPlace_RendererInfo _tmp3_;
		UnityPlace_RendererInfo _tmp2_;
		UnityPlace_RendererInfo _tmp1_ = {0};
		g_signal_emit_by_name ((UnityPlaceEntryService*) entry_service, "global-renderer-info-changed", (_tmp3_ = _tmp2_ = (unity_place_renderer_info_get_raw (renderer_info, &_tmp1_), _tmp1_), &_tmp3_));
		unity_place__rendererinfo_destroy (&_tmp2_);
	}
	_g_object_unref0 (entry_service);
	_g_object_unref0 (renderer_info);
}


static void __lambda3__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_lambda3_ (_sender, pspec, self);
}


static gpointer _unity_place__entrysignals_dup0 (gpointer self) {
	return self ? unity_place__entrysignals_dup (self) : NULL;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->self);
		_g_object_unref0 (_data1_->entry);
		g_slice_free (Block1Data, _data1_);
	}
}


void unity_place_controller_add_entry (UnityPlaceController* self, UnityPlaceEntryInfo* entry) {
	Block1Data* _data1_;
	UnityPlace_EntrySignals signals = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_data1_->entry = _g_object_ref0 (entry);
	unity_place_service_impl_add_entry (self->priv->service, _data1_->entry);
	memset (&signals, 0, sizeof (UnityPlace_EntrySignals));
	signals.place_entry_info_changed_id = g_signal_connect_object ((GObject*) _data1_->entry, "notify", (GCallback) _unity_place_controller_on_entry_changed_g_object_notify, self, 0);
	signals.entry_renderer_info_changed_id = g_signal_connect_data ((GObject*) unity_place_entry_info_get_entry_renderer_info (_data1_->entry), "notify", (GCallback) __lambda2__g_object_notify, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	signals.global_renderer_info_changed_id = g_signal_connect_data ((GObject*) unity_place_entry_info_get_global_renderer_info (_data1_->entry), "notify", (GCallback) __lambda3__g_object_notify, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	g_hash_table_insert (self->priv->entry_signals, g_strdup (unity_place_entry_info_get_dbus_path (_data1_->entry)), _unity_place__entrysignals_dup0 (&signals));
	block1_data_unref (_data1_);
}


UnityPlaceEntryInfo* unity_place_controller_get_entry (UnityPlaceController* self, const char* dbus_path) {
	UnityPlaceEntryInfo* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (dbus_path != NULL, NULL);
	result = unity_place_service_impl_get_entry (self->priv->service, dbus_path);
	return result;
}


void unity_place_controller_remove_entry (UnityPlaceController* self, const char* dbus_path) {
	UnityPlace_EntrySignals* signals;
	UnityPlaceEntryInfo* entry;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dbus_path != NULL);
	signals = _unity_place__entrysignals_dup0 ((UnityPlace_EntrySignals*) g_hash_table_lookup (self->priv->entry_signals, dbus_path));
	if (signals == NULL) {
		g_warning ("unity-place.vala:804: No signals connected for unknown entry '%s'", dbus_path);
		unity_place_service_impl_remove_entry (self->priv->service, dbus_path);
		_unity_place__entrysignals_free0 (signals);
		return;
	}
	entry = unity_place_service_impl_get_entry (self->priv->service, dbus_path);
	if (entry == NULL) {
		g_warning ("unity-place.vala:813: Can not disconnect signals for unknown entry '%s" \
"'", dbus_path);
		g_hash_table_remove (self->priv->entry_signals, dbus_path);
		_g_object_unref0 (entry);
		_unity_place__entrysignals_free0 (signals);
		return;
	}
	g_signal_handler_disconnect ((GObject*) entry, (*signals).place_entry_info_changed_id);
	g_signal_handler_disconnect ((GObject*) unity_place_entry_info_get_entry_renderer_info (entry), (*signals).entry_renderer_info_changed_id);
	g_signal_handler_disconnect ((GObject*) unity_place_entry_info_get_global_renderer_info (entry), (*signals).global_renderer_info_changed_id);
	unity_place_service_impl_remove_entry (self->priv->service, dbus_path);
	_g_object_unref0 (entry);
	_unity_place__entrysignals_free0 (signals);
}


guint unity_place_controller_num_entries (UnityPlaceController* self) {
	guint result = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	result = unity_place_service_impl_num_entries (self->priv->service);
	return result;
}


char** unity_place_controller_get_entry_paths (UnityPlaceController* self, int* result_length1) {
	char** result = NULL;
	gint _tmp0_;
	char** _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	result = (_tmp1_ = unity_place_service_impl_get_entry_paths (self->priv->service, &_tmp0_), *result_length1 = _tmp0_, _tmp1_);
	return result;
}


UnityPlaceEntryInfo** unity_place_controller_get_entries (UnityPlaceController* self, int* result_length1) {
	UnityPlaceEntryInfo** result = NULL;
	guint len;
	UnityPlaceEntryInfo** _tmp0_;
	gint __result__size_;
	gint _result__length1;
	UnityPlaceEntryInfo** _result_;
	char** _tmp2_;
	gint _entry_paths_size_;
	gint entry_paths_length1;
	gint _tmp1_;
	char** entry_paths;
	gint i;
	UnityPlaceEntryInfo** _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	len = unity_place_controller_num_entries (self);
	_result_ = (_tmp0_ = g_new0 (UnityPlaceEntryInfo*, len + 1), _result__length1 = len, __result__size_ = _result__length1, _tmp0_);
	entry_paths = (_tmp2_ = unity_place_controller_get_entry_paths (self, &_tmp1_), entry_paths_length1 = _tmp1_, _entry_paths_size_ = entry_paths_length1, _tmp2_);
	i = 0;
	{
		gboolean _tmp3_;
		i = 0;
		_tmp3_ = TRUE;
		while (TRUE) {
			UnityPlaceEntryInfo* _tmp4_;
			if (!_tmp3_) {
				i++;
			}
			_tmp3_ = FALSE;
			if (!(i < len)) {
				break;
			}
			_result_[i] = (_tmp4_ = unity_place_controller_get_entry (self, entry_paths[i]), _g_object_unref0 (_result_[i]), _tmp4_);
		}
	}
	result = (_tmp5_ = _result_, *result_length1 = _result__length1, _tmp5_);
	entry_paths = (_vala_array_free (entry_paths, entry_paths_length1, (GDestroyNotify) g_free), NULL);
	return result;
	entry_paths = (_vala_array_free (entry_paths, entry_paths_length1, (GDestroyNotify) g_free), NULL);
	_result_ = (_vala_array_free (_result_, _result__length1, (GDestroyNotify) g_object_unref), NULL);
}


void unity_place_controller_export (UnityPlaceController* self, GError** error) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	unity_place_service_impl_export (self->priv->service, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DBUS_GERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	self->priv->_exported = TRUE;
	g_object_notify ((GObject*) self, "exported");
}


void unity_place_controller_unexport (UnityPlaceController* self, GError** error) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	unity_place_service_impl_unexport (self->priv->service, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DBUS_GERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	self->priv->_exported = FALSE;
	g_object_notify ((GObject*) self, "exported");
}


static char** _vala_array_dup7 (char** self, int length) {
	char** result;
	int i;
	result = g_new0 (char*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


static void unity_place_controller_on_entry_changed (UnityPlaceController* self, GObject* obj, GParamSpec* psec) {
	GObject* _tmp0_;
	UnityPlaceEntryInfo* entry;
	UnityPlace_EntryInfoData entry_data = {0};
	UnityPlaceEntryServiceImpl* entry_service;
	UnityPlace_EntryInfo _tmp1_ = {0};
	UnityPlace_EntryInfo _entry;
	char* _tmp2_;
	char* _tmp3_;
	char* _tmp4_;
	char** _tmp6_;
	char** _tmp5_;
	char* _tmp7_;
	GHashTable* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (psec != NULL);
	entry = _g_object_ref0 ((_tmp0_ = obj, UNITY_PLACE_IS_ENTRY_INFO (_tmp0_) ? ((UnityPlaceEntryInfo*) _tmp0_) : NULL));
	memset (&entry_data, 0, sizeof (UnityPlace_EntryInfoData));
	entry_service = unity_place_service_impl_get_entry_service (self->priv->service, unity_place_entry_info_get_dbus_path (entry));
	if (entry_service == NULL) {
		g_warning ("unity-place.vala:874: Got change signal from unknown entry service '%s" \
"'", unity_place_entry_info_get_dbus_path (entry));
		_g_object_unref0 (entry_service);
		unity_place__entryinfodata_destroy (&entry_data);
		_g_object_unref0 (entry);
		return;
	}
	_entry = (unity_place_entry_info_get_raw (entry, &_tmp1_), _tmp1_);
	entry_data.dbus_path = (_tmp2_ = g_strdup (_entry.dbus_path), _g_free0 (entry_data.dbus_path), _tmp2_);
	entry_data.display_name = (_tmp3_ = g_strdup (_entry.display_name), _g_free0 (entry_data.display_name), _tmp3_);
	entry_data.icon = (_tmp4_ = g_strdup (_entry.icon), _g_free0 (entry_data.icon), _tmp4_);
	entry_data.position = _entry.position;
	entry_data.mimetypes = (_tmp6_ = (_tmp5_ = _entry.mimetypes, (_tmp5_ == NULL) ? ((gpointer) _tmp5_) : _vala_array_dup7 (_tmp5_, _entry.mimetypes_length1)), entry_data.mimetypes = (_vala_array_free (entry_data.mimetypes, entry_data.mimetypes_length1, (GDestroyNotify) g_free), NULL), entry_data.mimetypes_length1 = _entry.mimetypes_length1, entry_data._mimetypes_size_ = entry_data.mimetypes_length1, _tmp6_);
	entry_data.sensitive = _entry.sensitive;
	entry_data.sections_model = (_tmp7_ = g_strdup (_entry.sections_model), _g_free0 (entry_data.sections_model), _tmp7_);
	entry_data.hints = (_tmp8_ = _g_hash_table_ref0 (_entry.hints), _g_hash_table_unref0 (entry_data.hints), _tmp8_);
	g_signal_emit_by_name ((UnityPlaceEntryService*) entry_service, "place-entry-info-changed", &entry_data);
	unity_place__entryinfo_destroy (&_entry);
	_g_object_unref0 (entry_service);
	unity_place__entryinfodata_destroy (&entry_data);
	_g_object_unref0 (entry);
}


const char* unity_place_controller_get_dbus_path (UnityPlaceController* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_dbus_path;
	return result;
}


static void unity_place_controller_set_dbus_path (UnityPlaceController* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_dbus_path = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_dbus_path), _tmp0_);
	g_object_notify ((GObject *) self, "dbus-path");
}


gboolean unity_place_controller_get_exported (UnityPlaceController* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_exported;
	return result;
}


static GObject * unity_place_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityPlaceController * self;
	parent_class = G_OBJECT_CLASS (unity_place_controller_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_PLACE_CONTROLLER (obj);
	{
		UnityPlaceServiceImpl* _tmp296_;
		GHashTable* _tmp297_;
		self->priv->service = (_tmp296_ = unity_place_service_impl_new (self->priv->_dbus_path), _g_object_unref0 (self->priv->service), _tmp296_);
		self->priv->entry_signals = (_tmp297_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, unity_place__entrysignals_free), _g_hash_table_unref0 (self->priv->entry_signals), _tmp297_);
	}
	return obj;
}


static void unity_place_controller_class_init (UnityPlaceControllerClass * klass) {
	unity_place_controller_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceControllerPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_controller_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_controller_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_place_controller_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_place_controller_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_CONTROLLER_DBUS_PATH, g_param_spec_string ("dbus-path", "dbus-path", "dbus-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_CONTROLLER_EXPORTED, g_param_spec_boolean ("exported", "exported", "exported", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void unity_place_controller_instance_init (UnityPlaceController * self) {
	self->priv = UNITY_PLACE_CONTROLLER_GET_PRIVATE (self);
	self->priv->_exported = FALSE;
}


static void unity_place_controller_finalize (GObject* obj) {
	UnityPlaceController * self;
	self = UNITY_PLACE_CONTROLLER (obj);
	_g_object_unref0 (self->priv->service);
	_g_free0 (self->priv->_dbus_path);
	_g_hash_table_unref0 (self->priv->entry_signals);
	G_OBJECT_CLASS (unity_place_controller_parent_class)->finalize (obj);
}


GType unity_place_controller_get_type (void) {
	static volatile gsize unity_place_controller_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_controller_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceController), 0, (GInstanceInitFunc) unity_place_controller_instance_init, NULL };
		GType unity_place_controller_type_id;
		unity_place_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceController", &g_define_type_info, 0);
		g_once_init_leave (&unity_place_controller_type_id__volatile, unity_place_controller_type_id);
	}
	return unity_place_controller_type_id__volatile;
}


static void unity_place_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceController * self;
	self = UNITY_PLACE_CONTROLLER (object);
	switch (property_id) {
		case UNITY_PLACE_CONTROLLER_DBUS_PATH:
		g_value_set_string (value, unity_place_controller_get_dbus_path (self));
		break;
		case UNITY_PLACE_CONTROLLER_EXPORTED:
		g_value_set_boolean (value, unity_place_controller_get_exported (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceController * self;
	self = UNITY_PLACE_CONTROLLER (object);
	switch (property_id) {
		case UNITY_PLACE_CONTROLLER_DBUS_PATH:
		unity_place_controller_set_dbus_path (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__BOXED callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), data2);
}



