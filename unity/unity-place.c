/* unity-place.c generated by valac, the Vala compiler
 * generated from unity-place.vala, do not modify */

/*
 * Copyright (C) 2010 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by Mikkel Kamstrup Erlandsen <mikkel.kamstrup@canonical.com>
 *
 */
/*
 * IMPLEMENTATION NOTE:
 * It may appear this code it is bit more bloated than it needs to be
 * (considering the pure number of classes and indirections), but this has
 * some good reasons.
 *
 * Firstly we want to hide away Vala's internal DBus marshalling which would
 * expose raw structs in the API. These structs are hidden away in _RendererInfo,
 * and _EntryInfo. We wrap these in handy GObjects with properties and what not.
 * In fact we want to hide all DBusisms, which is also why the DBus interfaces
 * are declared private.
 *
 * Secondly we want the generatedd C API to be nice and not too Vala-ish. We
 * must anticipate that place daemons consuming libunity will be written in
 * both Vala and C.
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <dee.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <dbus/dbus.h>


#define UNITY_PLACE_TYPE__RENDERERINFO (unity_place__rendererinfo_get_type ())
typedef struct _UnityPlace_RendererInfo UnityPlace_RendererInfo;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define UNITY_PLACE_TYPE_RENDERER_INFO (unity_place_renderer_info_get_type ())
#define UNITY_PLACE_RENDERER_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_RENDERER_INFO, UnityPlaceRendererInfo))
#define UNITY_PLACE_RENDERER_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_RENDERER_INFO, UnityPlaceRendererInfoClass))
#define UNITY_PLACE_IS_RENDERER_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_RENDERER_INFO))
#define UNITY_PLACE_IS_RENDERER_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_RENDERER_INFO))
#define UNITY_PLACE_RENDERER_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_RENDERER_INFO, UnityPlaceRendererInfoClass))

typedef struct _UnityPlaceRendererInfo UnityPlaceRendererInfo;
typedef struct _UnityPlaceRendererInfoClass UnityPlaceRendererInfoClass;
typedef struct _UnityPlaceRendererInfoPrivate UnityPlaceRendererInfoPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define UNITY_PLACE_TYPE_SEARCH (unity_place_search_get_type ())
#define UNITY_PLACE_SEARCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_SEARCH, UnityPlaceSearch))
#define UNITY_PLACE_SEARCH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_SEARCH, UnityPlaceSearchClass))
#define UNITY_PLACE_IS_SEARCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_SEARCH))
#define UNITY_PLACE_IS_SEARCH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_SEARCH))
#define UNITY_PLACE_SEARCH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_SEARCH, UnityPlaceSearchClass))

typedef struct _UnityPlaceSearch UnityPlaceSearch;
typedef struct _UnityPlaceSearchClass UnityPlaceSearchClass;
typedef struct _UnityPlaceSearchPrivate UnityPlaceSearchPrivate;

#define UNITY_PLACE_TYPE__ENTRYINFO (unity_place__entryinfo_get_type ())
typedef struct _UnityPlace_EntryInfo UnityPlace_EntryInfo;

#define UNITY_PLACE_TYPE_ENTRY_INFO (unity_place_entry_info_get_type ())
#define UNITY_PLACE_ENTRY_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_ENTRY_INFO, UnityPlaceEntryInfo))
#define UNITY_PLACE_ENTRY_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_ENTRY_INFO, UnityPlaceEntryInfoClass))
#define UNITY_PLACE_IS_ENTRY_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_ENTRY_INFO))
#define UNITY_PLACE_IS_ENTRY_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_ENTRY_INFO))
#define UNITY_PLACE_ENTRY_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_ENTRY_INFO, UnityPlaceEntryInfoClass))

typedef struct _UnityPlaceEntryInfo UnityPlaceEntryInfo;
typedef struct _UnityPlaceEntryInfoClass UnityPlaceEntryInfoClass;
typedef struct _UnityPlaceEntryInfoPrivate UnityPlaceEntryInfoPrivate;

#define UNITY_PLACE_TYPE_SERVICE (unity_place_service_get_type ())
#define UNITY_PLACE_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_SERVICE, UnityPlaceService))
#define UNITY_PLACE_IS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_SERVICE))
#define UNITY_PLACE_SERVICE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), UNITY_PLACE_TYPE_SERVICE, UnityPlaceServiceIface))

typedef struct _UnityPlaceService UnityPlaceService;
typedef struct _UnityPlaceServiceIface UnityPlaceServiceIface;
typedef struct _UnityPlaceServiceDBusProxy UnityPlaceServiceDBusProxy;
typedef DBusGProxyClass UnityPlaceServiceDBusProxyClass;

#define UNITY_PLACE_TYPE_ENTRY_SERVICE (unity_place_entry_service_get_type ())
#define UNITY_PLACE_ENTRY_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE, UnityPlaceEntryService))
#define UNITY_PLACE_IS_ENTRY_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE))
#define UNITY_PLACE_ENTRY_SERVICE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE, UnityPlaceEntryServiceIface))

typedef struct _UnityPlaceEntryService UnityPlaceEntryService;
typedef struct _UnityPlaceEntryServiceIface UnityPlaceEntryServiceIface;
typedef struct _UnityPlaceEntryServiceDBusProxy UnityPlaceEntryServiceDBusProxy;
typedef DBusGProxyClass UnityPlaceEntryServiceDBusProxyClass;

#define UNITY_PLACE_TYPE_SERVICE_IMPL (unity_place_service_impl_get_type ())
#define UNITY_PLACE_SERVICE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_SERVICE_IMPL, UnityPlaceServiceImpl))
#define UNITY_PLACE_SERVICE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_SERVICE_IMPL, UnityPlaceServiceImplClass))
#define UNITY_PLACE_IS_SERVICE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_SERVICE_IMPL))
#define UNITY_PLACE_IS_SERVICE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_SERVICE_IMPL))
#define UNITY_PLACE_SERVICE_IMPL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_SERVICE_IMPL, UnityPlaceServiceImplClass))

typedef struct _UnityPlaceServiceImpl UnityPlaceServiceImpl;
typedef struct _UnityPlaceServiceImplClass UnityPlaceServiceImplClass;
typedef struct _UnityPlaceServiceImplPrivate UnityPlaceServiceImplPrivate;

#define UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL (unity_place_entry_service_impl_get_type ())
#define UNITY_PLACE_ENTRY_SERVICE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, UnityPlaceEntryServiceImpl))
#define UNITY_PLACE_ENTRY_SERVICE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, UnityPlaceEntryServiceImplClass))
#define UNITY_PLACE_IS_ENTRY_SERVICE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL))
#define UNITY_PLACE_IS_ENTRY_SERVICE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL))
#define UNITY_PLACE_ENTRY_SERVICE_IMPL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, UnityPlaceEntryServiceImplClass))

typedef struct _UnityPlaceEntryServiceImpl UnityPlaceEntryServiceImpl;
typedef struct _UnityPlaceEntryServiceImplClass UnityPlaceEntryServiceImplClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
typedef struct _UnityPlaceEntryServiceImplPrivate UnityPlaceEntryServiceImplPrivate;

#define UNITY_PLACE_TYPE_CONTROLLER (unity_place_controller_get_type ())
#define UNITY_PLACE_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_PLACE_TYPE_CONTROLLER, UnityPlaceController))
#define UNITY_PLACE_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_PLACE_TYPE_CONTROLLER, UnityPlaceControllerClass))
#define UNITY_PLACE_IS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_PLACE_TYPE_CONTROLLER))
#define UNITY_PLACE_IS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_PLACE_TYPE_CONTROLLER))
#define UNITY_PLACE_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_PLACE_TYPE_CONTROLLER, UnityPlaceControllerClass))

typedef struct _UnityPlaceController UnityPlaceController;
typedef struct _UnityPlaceControllerClass UnityPlaceControllerClass;
typedef struct _UnityPlaceControllerPrivate UnityPlaceControllerPrivate;
typedef struct _DBusObjectVTable _DBusObjectVTable;

struct _UnityPlace_RendererInfo {
	char* default_renderer;
	char* groups_model;
	char* results_model;
	GHashTable* hints;
};

struct _UnityPlaceRendererInfo {
	GObject parent_instance;
	UnityPlaceRendererInfoPrivate * priv;
};

struct _UnityPlaceRendererInfoClass {
	GObjectClass parent_class;
};

struct _UnityPlaceRendererInfoPrivate {
	UnityPlace_RendererInfo info;
	DeeModel* _groups_model;
	DeeModel* _results_model;
};

struct _UnityPlaceSearch {
	GInitiallyUnowned parent_instance;
	UnityPlaceSearchPrivate * priv;
};

struct _UnityPlaceSearchClass {
	GInitiallyUnownedClass parent_class;
};

struct _UnityPlaceSearchPrivate {
	char* search;
	GHashTable* hints;
};

typedef guint (*UnityPlaceSearchHandler) (UnityPlaceSearch* search, void* user_data);
struct _UnityPlace_EntryInfo {
	char* dbus_path;
	char* display_name;
	char* icon;
	guint position;
	char** mimetypes;
	gint mimetypes_length1;
	gint _mimetypes_size_;
	gboolean sensitive;
	char* sections_model;
	GHashTable* hints;
	UnityPlace_RendererInfo entry_renderer_info;
	UnityPlace_RendererInfo global_renderer_info;
};

struct _UnityPlaceEntryInfo {
	GObject parent_instance;
	UnityPlaceEntryInfoPrivate * priv;
};

struct _UnityPlaceEntryInfoClass {
	GObjectClass parent_class;
};

struct _UnityPlaceEntryInfoPrivate {
	UnityPlace_EntryInfo info;
	UnityPlaceRendererInfo* _entry_renderer_info;
	UnityPlaceRendererInfo* _global_renderer_info;
	DeeModel* _sections_model;
	UnityPlaceSearchHandler _search_handler;
	gpointer _search_handler_target;
	GDestroyNotify _search_handler_target_destroy_notify;
	UnityPlaceSearchHandler _global_search_handler;
	gpointer _global_search_handler_target;
	GDestroyNotify _global_search_handler_target_destroy_notify;
	gboolean _active;
	guint _active_section;
};

struct _UnityPlaceServiceIface {
	GTypeInterface parent_iface;
	UnityPlace_EntryInfo* (*get_entries) (UnityPlaceService* self, int* result_length1, GError** error);
};

struct _UnityPlaceServiceDBusProxy {
	DBusGProxy parent_instance;
	gboolean disposed;
};

struct _UnityPlaceEntryServiceIface {
	GTypeInterface parent_iface;
	guint (*set_global_search) (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
	guint (*set_search) (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
	void (*set_active) (UnityPlaceEntryService* self, gboolean is_active, GError** error);
	void (*set_active_section) (UnityPlaceEntryService* self, guint section_id, GError** error);
};

struct _UnityPlaceEntryServiceDBusProxy {
	DBusGProxy parent_instance;
	gboolean disposed;
};

struct _UnityPlaceServiceImpl {
	GObject parent_instance;
	UnityPlaceServiceImplPrivate * priv;
};

struct _UnityPlaceServiceImplClass {
	GObjectClass parent_class;
};

struct _UnityPlaceServiceImplPrivate {
	char* _dbus_path;
	GHashTable* entries;
	gboolean _exported;
};

struct _UnityPlaceEntryServiceImpl {
	GObject parent_instance;
	UnityPlaceEntryServiceImplPrivate * priv;
};

struct _UnityPlaceEntryServiceImplClass {
	GObjectClass parent_class;
};

struct _UnityPlaceEntryServiceImplPrivate {
	gboolean _exported;
	UnityPlaceEntryInfo* _entry_info;
};

struct _UnityPlaceController {
	GObject parent_instance;
	UnityPlaceControllerPrivate * priv;
};

struct _UnityPlaceControllerClass {
	GObjectClass parent_class;
};

struct _UnityPlaceControllerPrivate {
	UnityPlaceServiceImpl* service;
	char* _dbus_path;
	gboolean _exported;
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};


static gpointer unity_place_renderer_info_parent_class = NULL;
static gpointer unity_place_search_parent_class = NULL;
static gpointer unity_place_entry_info_parent_class = NULL;
static gpointer unity_place_service_impl_parent_class = NULL;
static UnityPlaceServiceIface* unity_place_service_impl_unity_place_service_parent_iface = NULL;
static gpointer unity_place_entry_service_impl_parent_class = NULL;
static UnityPlaceEntryServiceIface* unity_place_entry_service_impl_unity_place_entry_service_parent_iface = NULL;
static gpointer unity_place_controller_parent_class = NULL;

GType unity_place__rendererinfo_get_type (void);
UnityPlace_RendererInfo* unity_place__rendererinfo_dup (const UnityPlace_RendererInfo* self);
void unity_place__rendererinfo_free (UnityPlace_RendererInfo* self);
void unity_place__rendererinfo_copy (const UnityPlace_RendererInfo* self, UnityPlace_RendererInfo* dest);
void unity_place__rendererinfo_destroy (UnityPlace_RendererInfo* self);
GType unity_place_renderer_info_get_type (void);
#define UNITY_PLACE_RENDERER_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_RENDERER_INFO, UnityPlaceRendererInfoPrivate))
enum  {
	UNITY_PLACE_RENDERER_INFO_DUMMY_PROPERTY,
	UNITY_PLACE_RENDERER_INFO_DEFAULT_RENDERER,
	UNITY_PLACE_RENDERER_INFO_GROUPS_MODEL,
	UNITY_PLACE_RENDERER_INFO_RESULTS_MODEL
};
UnityPlaceRendererInfo* unity_place_renderer_info_new (UnityPlace_RendererInfo* info);
UnityPlaceRendererInfo* unity_place_renderer_info_construct (GType object_type, UnityPlace_RendererInfo* info);
void unity_place_renderer_info_set_hint (UnityPlaceRendererInfo* self, const char* hint, const char* val);
char* unity_place_renderer_info_get_hint (UnityPlaceRendererInfo* self, const char* hint);
void unity_place_renderer_info_clear_hint (UnityPlaceRendererInfo* self, const char* hint);
void unity_place_renderer_info_clear_hints (UnityPlaceRendererInfo* self);
guint unity_place_renderer_info_num_hints (UnityPlaceRendererInfo* self);
const char* unity_place_renderer_info_get_default_renderer (UnityPlaceRendererInfo* self);
void unity_place_renderer_info_set_default_renderer (UnityPlaceRendererInfo* self, const char* value);
DeeModel* unity_place_renderer_info_get_groups_model (UnityPlaceRendererInfo* self);
void unity_place_renderer_info_set_groups_model (UnityPlaceRendererInfo* self, DeeModel* value);
DeeModel* unity_place_renderer_info_get_results_model (UnityPlaceRendererInfo* self);
void unity_place_renderer_info_set_results_model (UnityPlaceRendererInfo* self, DeeModel* value);
static void unity_place_renderer_info_finalize (GObject* obj);
static void unity_place_renderer_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_renderer_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_place_search_get_type (void);
#define UNITY_PLACE_SEARCH_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_SEARCH, UnityPlaceSearchPrivate))
enum  {
	UNITY_PLACE_SEARCH_DUMMY_PROPERTY
};
UnityPlaceSearch* unity_place_search_new (const char* search, GHashTable* hints);
UnityPlaceSearch* unity_place_search_construct (GType object_type, const char* search, GHashTable* hints);
char* unity_place_search_get_search_string (UnityPlaceSearch* self);
void unity_place_search_set_hint (UnityPlaceSearch* self, const char* hint, const char* val);
char* unity_place_search_get_hint (UnityPlaceSearch* self, const char* hint);
void unity_place_search_clear_hint (UnityPlaceSearch* self, const char* hint);
void unity_place_search_clear_hints (UnityPlaceSearch* self);
guint unity_place_search_num_hints (UnityPlaceSearch* self);
static void unity_place_search_finalize (GObject* obj);
GType unity_place__entryinfo_get_type (void);
UnityPlace_EntryInfo* unity_place__entryinfo_dup (const UnityPlace_EntryInfo* self);
void unity_place__entryinfo_free (UnityPlace_EntryInfo* self);
void unity_place__entryinfo_copy (const UnityPlace_EntryInfo* self, UnityPlace_EntryInfo* dest);
void unity_place__entryinfo_destroy (UnityPlace_EntryInfo* self);
static char** _vala_array_dup1 (char** self, int length);
GType unity_place_entry_info_get_type (void);
#define UNITY_PLACE_ENTRY_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_ENTRY_INFO, UnityPlaceEntryInfoPrivate))
enum  {
	UNITY_PLACE_ENTRY_INFO_DUMMY_PROPERTY,
	UNITY_PLACE_ENTRY_INFO_ENTRY_RENDERER_INFO,
	UNITY_PLACE_ENTRY_INFO_GLOBAL_RENDERER_INFO,
	UNITY_PLACE_ENTRY_INFO_DBUS_PATH,
	UNITY_PLACE_ENTRY_INFO_DISPLAY_NAME,
	UNITY_PLACE_ENTRY_INFO_ICON,
	UNITY_PLACE_ENTRY_INFO_POSITION,
	UNITY_PLACE_ENTRY_INFO_MIMETYPES,
	UNITY_PLACE_ENTRY_INFO_SENSITIVE,
	UNITY_PLACE_ENTRY_INFO_SECTIONS_MODEL,
	UNITY_PLACE_ENTRY_INFO_ACTIVE,
	UNITY_PLACE_ENTRY_INFO_ACTIVE_SECTION
};
UnityPlaceEntryInfo* unity_place_entry_info_new (const char* dbus_path);
UnityPlaceEntryInfo* unity_place_entry_info_construct (GType object_type, const char* dbus_path);
void unity_place_entry_info_set_hint (UnityPlaceEntryInfo* self, const char* hint, const char* val);
char* unity_place_entry_info_get_hint (UnityPlaceEntryInfo* self, const char* hint);
void unity_place_entry_info_clear_hint (UnityPlaceEntryInfo* self, const char* hint);
void unity_place_entry_info_clear_hints (UnityPlaceEntryInfo* self);
guint unity_place_entry_info_num_hints (UnityPlaceEntryInfo* self);
void unity_place_entry_info_get_raw (UnityPlaceEntryInfo* self, UnityPlace_EntryInfo* result);
UnityPlaceRendererInfo* unity_place_entry_info_get_entry_renderer_info (UnityPlaceEntryInfo* self);
UnityPlaceRendererInfo* unity_place_entry_info_get_global_renderer_info (UnityPlaceEntryInfo* self);
const char* unity_place_entry_info_get_dbus_path (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_dbus_path (UnityPlaceEntryInfo* self, const char* value);
const char* unity_place_entry_info_get_display_name (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_display_name (UnityPlaceEntryInfo* self, const char* value);
const char* unity_place_entry_info_get_icon (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_icon (UnityPlaceEntryInfo* self, const char* value);
guint unity_place_entry_info_get_position (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_position (UnityPlaceEntryInfo* self, guint value);
char** unity_place_entry_info_get_mimetypes (UnityPlaceEntryInfo* self, int* result_length1);
static char** _vala_array_dup2 (char** self, int length);
void unity_place_entry_info_set_mimetypes (UnityPlaceEntryInfo* self, char** value, int value_length1);
gboolean unity_place_entry_info_get_sensitive (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_sensitive (UnityPlaceEntryInfo* self, gboolean value);
DeeModel* unity_place_entry_info_get_sections_model (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_sections_model (UnityPlaceEntryInfo* self, DeeModel* value);
gboolean unity_place_entry_info_get_active (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_active (UnityPlaceEntryInfo* self, gboolean value);
guint unity_place_entry_info_get_active_section (UnityPlaceEntryInfo* self);
void unity_place_entry_info_set_active_section (UnityPlaceEntryInfo* self, guint value);
UnityPlaceSearchHandler unity_place_entry_info_get_search_handler (UnityPlaceEntryInfo* self, gpointer* result_target);
void unity_place_entry_info_set_search_handler (UnityPlaceEntryInfo* self, UnityPlaceSearchHandler value, gpointer value_target);
UnityPlaceSearchHandler unity_place_entry_info_get_global_search_handler (UnityPlaceEntryInfo* self, gpointer* result_target);
void unity_place_entry_info_set_global_search_handler (UnityPlaceEntryInfo* self, UnityPlaceSearchHandler value, gpointer value_target);
static GObject * unity_place_entry_info_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_place_entry_info_finalize (GObject* obj);
static void unity_place_entry_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_entry_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_place_service_get_type (void);
UnityPlace_EntryInfo* unity_place_service_get_entries (UnityPlaceService* self, int* result_length1, GError** error);
void unity_place_service_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _unity_place_service_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult unity_place_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_unity_place_service_introspect (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_service_property_get_all (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message);
static void _vala_UnityPlace_EntryInfo_array_free (UnityPlace_EntryInfo* array, gint array_length);
static DBusHandlerResult _dbus_unity_place_service_get_entries (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_unity_place_service_entry_added (GObject* _sender, UnityPlace_EntryInfo* entry, DBusConnection* _connection);
static void _dbus_unity_place_service_entry_removed (GObject* _sender, const char* entry_dbus_path, DBusConnection* _connection);
GType unity_place_service_dbus_proxy_get_type (void);
UnityPlaceService* unity_place_service_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path);
static void _dbus_handle_unity_place_service_entry_added (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_handle_unity_place_service_entry_removed (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message);
DBusHandlerResult unity_place_service_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
	UNITY_PLACE_SERVICE_DBUS_PROXY_DUMMY_PROPERTY
};
static UnityPlace_EntryInfo* unity_place_service_dbus_proxy_get_entries (UnityPlaceService* self, int* result_length1, GError** error);
static void unity_place_service_dbus_proxy_unity_place_service__interface_init (UnityPlaceServiceIface* iface);
static void unity_place_service_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_service_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_place_entry_service_get_type (void);
guint unity_place_entry_service_set_global_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
guint unity_place_entry_service_set_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
void unity_place_entry_service_set_active (UnityPlaceEntryService* self, gboolean is_active, GError** error);
void unity_place_entry_service_set_active_section (UnityPlaceEntryService* self, guint section_id, GError** error);
void unity_place_entry_service_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _unity_place_entry_service_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult unity_place_entry_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_unity_place_entry_service_introspect (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_entry_service_property_get_all (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_entry_service_set_global_search (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_entry_service_set_search (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_entry_service_set_active (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_unity_place_entry_service_set_active_section (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_unity_place_entry_service_renderer_info_changed (GObject* _sender, UnityPlace_RendererInfo* renderer_info, DBusConnection* _connection);
GType unity_place_entry_service_dbus_proxy_get_type (void);
UnityPlaceEntryService* unity_place_entry_service_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path);
static void _dbus_handle_unity_place_entry_service_renderer_info_changed (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message);
DBusHandlerResult unity_place_entry_service_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
	UNITY_PLACE_ENTRY_SERVICE_DBUS_PROXY_DUMMY_PROPERTY
};
static guint unity_place_entry_service_dbus_proxy_set_global_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
static guint unity_place_entry_service_dbus_proxy_set_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error);
static void unity_place_entry_service_dbus_proxy_set_active (UnityPlaceEntryService* self, gboolean is_active, GError** error);
static void unity_place_entry_service_dbus_proxy_set_active_section (UnityPlaceEntryService* self, guint section_id, GError** error);
static void unity_place_entry_service_dbus_proxy_unity_place_entry_service__interface_init (UnityPlaceEntryServiceIface* iface);
static void unity_place_entry_service_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_entry_service_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_place_service_impl_get_type (void);
GType unity_place_entry_service_impl_get_type (void);
#define UNITY_PLACE_SERVICE_IMPL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_SERVICE_IMPL, UnityPlaceServiceImplPrivate))
enum  {
	UNITY_PLACE_SERVICE_IMPL_DUMMY_PROPERTY,
	UNITY_PLACE_SERVICE_IMPL_DBUS_PATH,
	UNITY_PLACE_SERVICE_IMPL_EXPORTED
};
UnityPlaceServiceImpl* unity_place_service_impl_new (const char* dbus_path);
UnityPlaceServiceImpl* unity_place_service_impl_construct (GType object_type, const char* dbus_path);
UnityPlaceEntryInfo* unity_place_entry_service_impl_get_entry_info (UnityPlaceEntryServiceImpl* self);
static UnityPlace_EntryInfo* unity_place_service_impl_real_get_entries (UnityPlaceService* base, int* result_length1, GError** error);
UnityPlaceEntryServiceImpl* unity_place_entry_service_impl_new (UnityPlaceEntryInfo* entry_info);
UnityPlaceEntryServiceImpl* unity_place_entry_service_impl_construct (GType object_type, UnityPlaceEntryInfo* entry_info);
void unity_place_entry_service_impl_export (UnityPlaceEntryServiceImpl* self, GError** error);
void unity_place_service_impl_add_entry (UnityPlaceServiceImpl* self, UnityPlaceEntryInfo* entry_info);
UnityPlaceEntryInfo* unity_place_service_impl_get_entry (UnityPlaceServiceImpl* self, const char* dbus_path);
guint unity_place_service_impl_num_entries (UnityPlaceServiceImpl* self);
char** unity_place_service_impl_get_entry_paths (UnityPlaceServiceImpl* self, int* result_length1);
void unity_place_entry_service_impl_unexport (UnityPlaceEntryServiceImpl* self, GError** error);
void unity_place_service_impl_remove_entry (UnityPlaceServiceImpl* self, const char* dbus_path);
void unity_place_service_impl_export (UnityPlaceServiceImpl* self, GError** error);
void unity_place_service_impl_unexport (UnityPlaceServiceImpl* self, GError** error);
const char* unity_place_service_impl_get_dbus_path (UnityPlaceServiceImpl* self);
static void unity_place_service_impl_set_dbus_path (UnityPlaceServiceImpl* self, const char* value);
gboolean unity_place_service_impl_get_exported (UnityPlaceServiceImpl* self);
static GObject * unity_place_service_impl_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void unity_place_service_impl_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _unity_place_service_impl_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult unity_place_service_impl_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_unity_place_service_impl_introspect (UnityPlaceServiceImpl* self, DBusConnection* connection, DBusMessage* message);
static void unity_place_service_impl_finalize (GObject* obj);
static void unity_place_service_impl_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_service_impl_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define UNITY_PLACE_ENTRY_SERVICE_IMPL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, UnityPlaceEntryServiceImplPrivate))
enum  {
	UNITY_PLACE_ENTRY_SERVICE_IMPL_DUMMY_PROPERTY,
	UNITY_PLACE_ENTRY_SERVICE_IMPL_ENTRY_INFO,
	UNITY_PLACE_ENTRY_SERVICE_IMPL_EXPORTED
};
static guint unity_place_entry_service_impl_real_set_global_search (UnityPlaceEntryService* base, const char* search, GHashTable* hints, GError** error);
static guint unity_place_entry_service_impl_real_set_search (UnityPlaceEntryService* base, const char* search, GHashTable* hints, GError** error);
static void unity_place_entry_service_impl_real_set_active (UnityPlaceEntryService* base, gboolean is_active, GError** error);
static void unity_place_entry_service_impl_real_set_active_section (UnityPlaceEntryService* base, guint section_id, GError** error);
static void unity_place_entry_service_impl_set_entry_info (UnityPlaceEntryServiceImpl* self, UnityPlaceEntryInfo* value);
gboolean unity_place_entry_service_impl_get_exported (UnityPlaceEntryServiceImpl* self);
void unity_place_entry_service_impl_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _unity_place_entry_service_impl_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult unity_place_entry_service_impl_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_unity_place_entry_service_impl_introspect (UnityPlaceEntryServiceImpl* self, DBusConnection* connection, DBusMessage* message);
static void unity_place_entry_service_impl_finalize (GObject* obj);
static void unity_place_entry_service_impl_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_entry_service_impl_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_place_controller_get_type (void);
#define UNITY_PLACE_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_PLACE_TYPE_CONTROLLER, UnityPlaceControllerPrivate))
enum  {
	UNITY_PLACE_CONTROLLER_DUMMY_PROPERTY,
	UNITY_PLACE_CONTROLLER_DBUS_PATH,
	UNITY_PLACE_CONTROLLER_EXPORTED
};
UnityPlaceController* unity_place_controller_new (const char* dbus_path);
UnityPlaceController* unity_place_controller_construct (GType object_type, const char* dbus_path);
void unity_place_controller_add_entry (UnityPlaceController* self, UnityPlaceEntryInfo* entry);
UnityPlaceEntryInfo* unity_place_controller_get_entry (UnityPlaceController* self, const char* dbus_path);
void unity_place_controller_remove_entry (UnityPlaceController* self, const char* dbus_path);
guint unity_place_controller_num_entries (UnityPlaceController* self);
char** unity_place_controller_get_entry_paths (UnityPlaceController* self, int* result_length1);
UnityPlaceEntryInfo** unity_place_controller_get_entries (UnityPlaceController* self, int* result_length1);
void unity_place_controller_export (UnityPlaceController* self, GError** error);
void unity_place_controller_unexport (UnityPlaceController* self, GError** error);
const char* unity_place_controller_get_dbus_path (UnityPlaceController* self);
static void unity_place_controller_set_dbus_path (UnityPlaceController* self, const char* value);
gboolean unity_place_controller_get_exported (UnityPlaceController* self);
static GObject * unity_place_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_place_controller_finalize (GObject* obj);
static void unity_place_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_place_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);

static const DBusObjectPathVTable _unity_place_service_dbus_path_vtable = {_unity_place_service_dbus_unregister, unity_place_service_dbus_message};
static const _DBusObjectVTable _unity_place_service_dbus_vtable = {unity_place_service_dbus_register_object};
static const DBusObjectPathVTable _unity_place_entry_service_dbus_path_vtable = {_unity_place_entry_service_dbus_unregister, unity_place_entry_service_dbus_message};
static const _DBusObjectVTable _unity_place_entry_service_dbus_vtable = {unity_place_entry_service_dbus_register_object};
static const DBusObjectPathVTable _unity_place_service_impl_dbus_path_vtable = {_unity_place_service_impl_dbus_unregister, unity_place_service_impl_dbus_message};
static const _DBusObjectVTable _unity_place_service_impl_dbus_vtable = {unity_place_service_impl_dbus_register_object};
static const DBusObjectPathVTable _unity_place_entry_service_impl_dbus_path_vtable = {_unity_place_entry_service_impl_dbus_unregister, unity_place_entry_service_impl_dbus_message};
static const _DBusObjectVTable _unity_place_entry_service_impl_dbus_vtable = {unity_place_entry_service_impl_dbus_register_object};

static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


void unity_place__rendererinfo_copy (const UnityPlace_RendererInfo* self, UnityPlace_RendererInfo* dest) {
	dest->default_renderer = g_strdup (self->default_renderer);
	dest->groups_model = g_strdup (self->groups_model);
	dest->results_model = g_strdup (self->results_model);
	dest->hints = _g_hash_table_ref0 (self->hints);
}


void unity_place__rendererinfo_destroy (UnityPlace_RendererInfo* self) {
	_g_free0 (self->default_renderer);
	_g_free0 (self->groups_model);
	_g_free0 (self->results_model);
	_g_hash_table_unref0 (self->hints);
}


UnityPlace_RendererInfo* unity_place__rendererinfo_dup (const UnityPlace_RendererInfo* self) {
	UnityPlace_RendererInfo* dup;
	dup = g_new0 (UnityPlace_RendererInfo, 1);
	unity_place__rendererinfo_copy (self, dup);
	return dup;
}


void unity_place__rendererinfo_free (UnityPlace_RendererInfo* self) {
	unity_place__rendererinfo_destroy (self);
	g_free (self);
}


GType unity_place__rendererinfo_get_type (void) {
	static volatile gsize unity_place__rendererinfo_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place__rendererinfo_type_id__volatile)) {
		GType unity_place__rendererinfo_type_id;
		unity_place__rendererinfo_type_id = g_boxed_type_register_static ("UnityPlace_RendererInfo", (GBoxedCopyFunc) unity_place__rendererinfo_dup, (GBoxedFreeFunc) unity_place__rendererinfo_free);
		g_once_init_leave (&unity_place__rendererinfo_type_id__volatile, unity_place__rendererinfo_type_id);
	}
	return unity_place__rendererinfo_type_id__volatile;
}


#line 109 "unity-place.vala"
UnityPlaceRendererInfo* unity_place_renderer_info_construct (GType object_type, UnityPlace_RendererInfo* info) {
#line 603 "unity-place.c"
	UnityPlaceRendererInfo * self;
	UnityPlace_RendererInfo _tmp1_;
	UnityPlace_RendererInfo _tmp0_ = {0};
	GHashTable* _tmp2_;
#line 109 "unity-place.vala"
	self = (UnityPlaceRendererInfo*) g_object_new (object_type, NULL);
#line 111 "unity-place.vala"
	self->priv->info = (_tmp1_ = (unity_place__rendererinfo_copy (info, &_tmp0_), _tmp0_), unity_place__rendererinfo_destroy (&self->priv->info), _tmp1_);
#line 112 "unity-place.vala"
	(*info).hints = (_tmp2_ = g_hash_table_new (g_str_hash, g_str_equal), _g_hash_table_unref0 ((*info).hints), _tmp2_);
#line 614 "unity-place.c"
	return self;
}


#line 109 "unity-place.vala"
UnityPlaceRendererInfo* unity_place_renderer_info_new (UnityPlace_RendererInfo* info) {
#line 109 "unity-place.vala"
	return unity_place_renderer_info_construct (UNITY_PLACE_TYPE_RENDERER_INFO, info);
#line 623 "unity-place.c"
}


#line 119 "unity-place.vala"
void unity_place_renderer_info_set_hint (UnityPlaceRendererInfo* self, const char* hint, const char* val) {
#line 119 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 119 "unity-place.vala"
	g_return_if_fail (hint != NULL);
#line 119 "unity-place.vala"
	g_return_if_fail (val != NULL);
#line 121 "unity-place.vala"
	g_hash_table_insert (self->priv->info.hints, g_strdup (hint), g_strdup (val));
#line 637 "unity-place.c"
}


#line 124 "unity-place.vala"
char* unity_place_renderer_info_get_hint (UnityPlaceRendererInfo* self, const char* hint) {
#line 643 "unity-place.c"
	char* result = NULL;
#line 124 "unity-place.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 124 "unity-place.vala"
	g_return_val_if_fail (hint != NULL, NULL);
#line 649 "unity-place.c"
	result = g_strdup ((const char*) g_hash_table_lookup (self->priv->info.hints, hint));
#line 126 "unity-place.vala"
	return result;
#line 653 "unity-place.c"
}


#line 129 "unity-place.vala"
void unity_place_renderer_info_clear_hint (UnityPlaceRendererInfo* self, const char* hint) {
#line 129 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 129 "unity-place.vala"
	g_return_if_fail (hint != NULL);
#line 131 "unity-place.vala"
	g_hash_table_remove (self->priv->info.hints, hint);
#line 665 "unity-place.c"
}


#line 134 "unity-place.vala"
void unity_place_renderer_info_clear_hints (UnityPlaceRendererInfo* self) {
#line 134 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 136 "unity-place.vala"
	g_hash_table_remove_all (self->priv->info.hints);
#line 675 "unity-place.c"
}


#line 139 "unity-place.vala"
guint unity_place_renderer_info_num_hints (UnityPlaceRendererInfo* self) {
#line 681 "unity-place.c"
	guint result = 0U;
#line 139 "unity-place.vala"
	g_return_val_if_fail (self != NULL, 0U);
#line 685 "unity-place.c"
	result = g_hash_table_size (self->priv->info.hints);
#line 141 "unity-place.vala"
	return result;
#line 689 "unity-place.c"
}


const char* unity_place_renderer_info_get_default_renderer (UnityPlaceRendererInfo* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->info.default_renderer;
#line 73 "unity-place.vala"
	return result;
#line 699 "unity-place.c"
}


void unity_place_renderer_info_set_default_renderer (UnityPlaceRendererInfo* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
#line 74 "unity-place.vala"
	self->priv->info.default_renderer = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->info.default_renderer), _tmp0_);
#line 708 "unity-place.c"
	g_object_notify ((GObject *) self, "default-renderer");
}


DeeModel* unity_place_renderer_info_get_groups_model (UnityPlaceRendererInfo* self) {
	DeeModel* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_groups_model;
#line 78 "unity-place.vala"
	return result;
#line 719 "unity-place.c"
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void unity_place_renderer_info_set_groups_model (UnityPlaceRendererInfo* self, DeeModel* value) {
	DeeModel* _tmp0_;
	g_return_if_fail (self != NULL);
#line 80 "unity-place.vala"
	self->priv->_groups_model = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_groups_model), _tmp0_);
#line 81 "unity-place.vala"
	if (DEE_IS_SHARED_MODEL (value)) {
#line 735 "unity-place.c"
		DeeModel* _tmp1_;
		DeeSharedModel* model;
		char* _tmp2_;
#line 83 "unity-place.vala"
		model = _g_object_ref0 ((_tmp1_ = value, DEE_IS_SHARED_MODEL (_tmp1_) ? ((DeeSharedModel*) _tmp1_) : NULL));
#line 84 "unity-place.vala"
		self->priv->info.groups_model = (_tmp2_ = g_strdup (dee_shared_model_get_swarm_name (model)), _g_free0 (self->priv->info.groups_model), _tmp2_);
#line 743 "unity-place.c"
		_g_object_unref0 (model);
	} else {
		char* _tmp3_;
#line 87 "unity-place.vala"
		self->priv->info.groups_model = (_tmp3_ = g_strdup ("__local__"), _g_free0 (self->priv->info.groups_model), _tmp3_);
#line 749 "unity-place.c"
	}
	g_object_notify ((GObject *) self, "groups-model");
}


DeeModel* unity_place_renderer_info_get_results_model (UnityPlaceRendererInfo* self) {
	DeeModel* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_results_model;
#line 92 "unity-place.vala"
	return result;
#line 761 "unity-place.c"
}


void unity_place_renderer_info_set_results_model (UnityPlaceRendererInfo* self, DeeModel* value) {
	DeeModel* _tmp0_;
	g_return_if_fail (self != NULL);
#line 94 "unity-place.vala"
	self->priv->_results_model = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_results_model), _tmp0_);
#line 95 "unity-place.vala"
	if (DEE_IS_SHARED_MODEL (value)) {
#line 772 "unity-place.c"
		DeeModel* _tmp1_;
		DeeSharedModel* model;
		char* _tmp2_;
#line 97 "unity-place.vala"
		model = _g_object_ref0 ((_tmp1_ = value, DEE_IS_SHARED_MODEL (_tmp1_) ? ((DeeSharedModel*) _tmp1_) : NULL));
#line 98 "unity-place.vala"
		self->priv->info.results_model = (_tmp2_ = g_strdup (dee_shared_model_get_swarm_name (model)), _g_free0 (self->priv->info.results_model), _tmp2_);
#line 780 "unity-place.c"
		_g_object_unref0 (model);
	} else {
		char* _tmp3_;
#line 101 "unity-place.vala"
		self->priv->info.results_model = (_tmp3_ = g_strdup ("__local__"), _g_free0 (self->priv->info.results_model), _tmp3_);
#line 786 "unity-place.c"
	}
	g_object_notify ((GObject *) self, "results-model");
}


static void unity_place_renderer_info_class_init (UnityPlaceRendererInfoClass * klass) {
	unity_place_renderer_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceRendererInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_renderer_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_renderer_info_set_property;
	G_OBJECT_CLASS (klass)->finalize = unity_place_renderer_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_RENDERER_INFO_DEFAULT_RENDERER, g_param_spec_string ("default-renderer", "default-renderer", "default-renderer", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_RENDERER_INFO_GROUPS_MODEL, g_param_spec_object ("groups-model", "groups-model", "groups-model", DEE_TYPE_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_RENDERER_INFO_RESULTS_MODEL, g_param_spec_object ("results-model", "results-model", "results-model", DEE_TYPE_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void unity_place_renderer_info_instance_init (UnityPlaceRendererInfo * self) {
	self->priv = UNITY_PLACE_RENDERER_INFO_GET_PRIVATE (self);
}


static void unity_place_renderer_info_finalize (GObject* obj) {
	UnityPlaceRendererInfo * self;
	self = UNITY_PLACE_RENDERER_INFO (obj);
	unity_place__rendererinfo_destroy (&self->priv->info);
	_g_object_unref0 (self->priv->_groups_model);
	_g_object_unref0 (self->priv->_results_model);
	G_OBJECT_CLASS (unity_place_renderer_info_parent_class)->finalize (obj);
}


GType unity_place_renderer_info_get_type (void) {
	static volatile gsize unity_place_renderer_info_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_renderer_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceRendererInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_renderer_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceRendererInfo), 0, (GInstanceInitFunc) unity_place_renderer_info_instance_init, NULL };
		GType unity_place_renderer_info_type_id;
		unity_place_renderer_info_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceRendererInfo", &g_define_type_info, 0);
		g_once_init_leave (&unity_place_renderer_info_type_id__volatile, unity_place_renderer_info_type_id);
	}
	return unity_place_renderer_info_type_id__volatile;
}


static void unity_place_renderer_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceRendererInfo * self;
	self = UNITY_PLACE_RENDERER_INFO (object);
	switch (property_id) {
		case UNITY_PLACE_RENDERER_INFO_DEFAULT_RENDERER:
		g_value_set_string (value, unity_place_renderer_info_get_default_renderer (self));
		break;
		case UNITY_PLACE_RENDERER_INFO_GROUPS_MODEL:
		g_value_set_object (value, unity_place_renderer_info_get_groups_model (self));
		break;
		case UNITY_PLACE_RENDERER_INFO_RESULTS_MODEL:
		g_value_set_object (value, unity_place_renderer_info_get_results_model (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_renderer_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceRendererInfo * self;
	self = UNITY_PLACE_RENDERER_INFO (object);
	switch (property_id) {
		case UNITY_PLACE_RENDERER_INFO_DEFAULT_RENDERER:
		unity_place_renderer_info_set_default_renderer (self, g_value_get_string (value));
		break;
		case UNITY_PLACE_RENDERER_INFO_GROUPS_MODEL:
		unity_place_renderer_info_set_groups_model (self, g_value_get_object (value));
		break;
		case UNITY_PLACE_RENDERER_INFO_RESULTS_MODEL:
		unity_place_renderer_info_set_results_model (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


#line 157 "unity-place.vala"
UnityPlaceSearch* unity_place_search_construct (GType object_type, const char* search, GHashTable* hints) {
#line 873 "unity-place.c"
	UnityPlaceSearch * self;
	char* _tmp0_;
	GHashTable* _tmp1_;
#line 157 "unity-place.vala"
	g_return_val_if_fail (search != NULL, NULL);
#line 157 "unity-place.vala"
	g_return_val_if_fail (hints != NULL, NULL);
#line 159 "unity-place.vala"
	self = (UnityPlaceSearch*) g_object_new (object_type, NULL);
#line 160 "unity-place.vala"
	self->priv->search = (_tmp0_ = g_strdup (search), _g_free0 (self->priv->search), _tmp0_);
#line 161 "unity-place.vala"
	self->priv->hints = (_tmp1_ = _g_hash_table_ref0 (hints), _g_hash_table_unref0 (self->priv->hints), _tmp1_);
#line 887 "unity-place.c"
	return self;
}


#line 157 "unity-place.vala"
UnityPlaceSearch* unity_place_search_new (const char* search, GHashTable* hints) {
#line 157 "unity-place.vala"
	return unity_place_search_construct (UNITY_PLACE_TYPE_SEARCH, search, hints);
#line 896 "unity-place.c"
}


#line 164 "unity-place.vala"
char* unity_place_search_get_search_string (UnityPlaceSearch* self) {
#line 902 "unity-place.c"
	char* result = NULL;
#line 164 "unity-place.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 906 "unity-place.c"
	result = g_strdup (self->priv->search);
#line 166 "unity-place.vala"
	return result;
#line 910 "unity-place.c"
}


#line 169 "unity-place.vala"
void unity_place_search_set_hint (UnityPlaceSearch* self, const char* hint, const char* val) {
#line 169 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 169 "unity-place.vala"
	g_return_if_fail (hint != NULL);
#line 169 "unity-place.vala"
	g_return_if_fail (val != NULL);
#line 171 "unity-place.vala"
	g_hash_table_insert (self->priv->hints, g_strdup (hint), g_strdup (val));
#line 924 "unity-place.c"
}


#line 174 "unity-place.vala"
char* unity_place_search_get_hint (UnityPlaceSearch* self, const char* hint) {
#line 930 "unity-place.c"
	char* result = NULL;
#line 174 "unity-place.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 174 "unity-place.vala"
	g_return_val_if_fail (hint != NULL, NULL);
#line 936 "unity-place.c"
	result = g_strdup ((const char*) g_hash_table_lookup (self->priv->hints, hint));
#line 176 "unity-place.vala"
	return result;
#line 940 "unity-place.c"
}


#line 179 "unity-place.vala"
void unity_place_search_clear_hint (UnityPlaceSearch* self, const char* hint) {
#line 179 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 179 "unity-place.vala"
	g_return_if_fail (hint != NULL);
#line 181 "unity-place.vala"
	g_hash_table_remove (self->priv->hints, hint);
#line 952 "unity-place.c"
}


#line 184 "unity-place.vala"
void unity_place_search_clear_hints (UnityPlaceSearch* self) {
#line 184 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 186 "unity-place.vala"
	g_hash_table_remove_all (self->priv->hints);
#line 962 "unity-place.c"
}


#line 189 "unity-place.vala"
guint unity_place_search_num_hints (UnityPlaceSearch* self) {
#line 968 "unity-place.c"
	guint result = 0U;
#line 189 "unity-place.vala"
	g_return_val_if_fail (self != NULL, 0U);
#line 972 "unity-place.c"
	result = g_hash_table_size (self->priv->hints);
#line 191 "unity-place.vala"
	return result;
#line 976 "unity-place.c"
}


static void unity_place_search_class_init (UnityPlaceSearchClass * klass) {
	unity_place_search_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceSearchPrivate));
	G_OBJECT_CLASS (klass)->finalize = unity_place_search_finalize;
}


static void unity_place_search_instance_init (UnityPlaceSearch * self) {
	self->priv = UNITY_PLACE_SEARCH_GET_PRIVATE (self);
}


static void unity_place_search_finalize (GObject* obj) {
	UnityPlaceSearch * self;
	self = UNITY_PLACE_SEARCH (obj);
	_g_free0 (self->priv->search);
	_g_hash_table_unref0 (self->priv->hints);
	G_OBJECT_CLASS (unity_place_search_parent_class)->finalize (obj);
}


GType unity_place_search_get_type (void) {
	static volatile gsize unity_place_search_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_search_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceSearchClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_search_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceSearch), 0, (GInstanceInitFunc) unity_place_search_instance_init, NULL };
		GType unity_place_search_type_id;
		unity_place_search_type_id = g_type_register_static (G_TYPE_INITIALLY_UNOWNED, "UnityPlaceSearch", &g_define_type_info, 0);
		g_once_init_leave (&unity_place_search_type_id__volatile, unity_place_search_type_id);
	}
	return unity_place_search_type_id__volatile;
}


static char** _vala_array_dup1 (char** self, int length) {
	char** result;
	int i;
	result = g_new0 (char*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


void unity_place__entryinfo_copy (const UnityPlace_EntryInfo* self, UnityPlace_EntryInfo* dest) {
	UnityPlace_RendererInfo _tmp2_ = {0};
	UnityPlace_RendererInfo _tmp1_ = {0};
	char** _tmp0_;
	dest->dbus_path = g_strdup (self->dbus_path);
	dest->display_name = g_strdup (self->display_name);
	dest->icon = g_strdup (self->icon);
	dest->position = self->position;
	dest->mimetypes = (_tmp0_ = self->mimetypes, (_tmp0_ == NULL) ? ((gpointer) _tmp0_) : _vala_array_dup1 (_tmp0_, (*self).mimetypes_length1));
	dest->mimetypes_length1 = self->mimetypes_length1;
	dest->sensitive = self->sensitive;
	dest->sections_model = g_strdup (self->sections_model);
	dest->hints = _g_hash_table_ref0 (self->hints);
	dest->entry_renderer_info = (unity_place__rendererinfo_copy (&self->entry_renderer_info, &_tmp1_), _tmp1_);
	dest->global_renderer_info = (unity_place__rendererinfo_copy (&self->global_renderer_info, &_tmp2_), _tmp2_);
}


void unity_place__entryinfo_destroy (UnityPlace_EntryInfo* self) {
	_g_free0 (self->dbus_path);
	_g_free0 (self->display_name);
	_g_free0 (self->icon);
	self->mimetypes = (_vala_array_free (self->mimetypes, (*self).mimetypes_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (self->sections_model);
	_g_hash_table_unref0 (self->hints);
	unity_place__rendererinfo_destroy (&self->entry_renderer_info);
	unity_place__rendererinfo_destroy (&self->global_renderer_info);
}


UnityPlace_EntryInfo* unity_place__entryinfo_dup (const UnityPlace_EntryInfo* self) {
	UnityPlace_EntryInfo* dup;
	dup = g_new0 (UnityPlace_EntryInfo, 1);
	unity_place__entryinfo_copy (self, dup);
	return dup;
}


void unity_place__entryinfo_free (UnityPlace_EntryInfo* self) {
	unity_place__entryinfo_destroy (self);
	g_free (self);
}


GType unity_place__entryinfo_get_type (void) {
	static volatile gsize unity_place__entryinfo_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place__entryinfo_type_id__volatile)) {
		GType unity_place__entryinfo_type_id;
		unity_place__entryinfo_type_id = g_boxed_type_register_static ("UnityPlace_EntryInfo", (GBoxedCopyFunc) unity_place__entryinfo_dup, (GBoxedFreeFunc) unity_place__entryinfo_free);
		g_once_init_leave (&unity_place__entryinfo_type_id__volatile, unity_place__entryinfo_type_id);
	}
	return unity_place__entryinfo_type_id__volatile;
}


#line 340 "unity-place.vala"
UnityPlaceEntryInfo* unity_place_entry_info_construct (GType object_type, const char* dbus_path) {
#line 1081 "unity-place.c"
	UnityPlaceEntryInfo * self;
	char** _tmp0_;
	gint __empty_size_;
	gint _empty_length1;
	char** _empty;
#line 340 "unity-place.vala"
	g_return_val_if_fail (dbus_path != NULL, NULL);
#line 1089 "unity-place.c"
	_empty = (_tmp0_ = g_new0 (char*, 0 + 1), _empty_length1 = 0, __empty_size_ = _empty_length1, _tmp0_);
#line 345 "unity-place.vala"
	self = (UnityPlaceEntryInfo*) g_object_new (object_type, "dbus-path", dbus_path, "mimetypes", _empty, NULL);
#line 1093 "unity-place.c"
	_empty = (_vala_array_free (_empty, _empty_length1, (GDestroyNotify) g_free), NULL);
	return self;
}


#line 340 "unity-place.vala"
UnityPlaceEntryInfo* unity_place_entry_info_new (const char* dbus_path) {
#line 340 "unity-place.vala"
	return unity_place_entry_info_construct (UNITY_PLACE_TYPE_ENTRY_INFO, dbus_path);
#line 1103 "unity-place.c"
}


#line 353 "unity-place.vala"
void unity_place_entry_info_set_hint (UnityPlaceEntryInfo* self, const char* hint, const char* val) {
#line 353 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 353 "unity-place.vala"
	g_return_if_fail (hint != NULL);
#line 353 "unity-place.vala"
	g_return_if_fail (val != NULL);
#line 355 "unity-place.vala"
	g_hash_table_insert (self->priv->info.hints, g_strdup (hint), g_strdup (val));
#line 1117 "unity-place.c"
}


#line 358 "unity-place.vala"
char* unity_place_entry_info_get_hint (UnityPlaceEntryInfo* self, const char* hint) {
#line 1123 "unity-place.c"
	char* result = NULL;
#line 358 "unity-place.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 358 "unity-place.vala"
	g_return_val_if_fail (hint != NULL, NULL);
#line 1129 "unity-place.c"
	result = g_strdup ((const char*) g_hash_table_lookup (self->priv->info.hints, hint));
#line 360 "unity-place.vala"
	return result;
#line 1133 "unity-place.c"
}


#line 363 "unity-place.vala"
void unity_place_entry_info_clear_hint (UnityPlaceEntryInfo* self, const char* hint) {
#line 363 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 363 "unity-place.vala"
	g_return_if_fail (hint != NULL);
#line 365 "unity-place.vala"
	g_hash_table_remove (self->priv->info.hints, hint);
#line 1145 "unity-place.c"
}


#line 368 "unity-place.vala"
void unity_place_entry_info_clear_hints (UnityPlaceEntryInfo* self) {
#line 368 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 370 "unity-place.vala"
	g_hash_table_remove_all (self->priv->info.hints);
#line 1155 "unity-place.c"
}


#line 373 "unity-place.vala"
guint unity_place_entry_info_num_hints (UnityPlaceEntryInfo* self) {
#line 1161 "unity-place.c"
	guint result = 0U;
#line 373 "unity-place.vala"
	g_return_val_if_fail (self != NULL, 0U);
#line 1165 "unity-place.c"
	result = g_hash_table_size (self->priv->info.hints);
#line 375 "unity-place.vala"
	return result;
#line 1169 "unity-place.c"
}


#line 381 "unity-place.vala"
void unity_place_entry_info_get_raw (UnityPlaceEntryInfo* self, UnityPlace_EntryInfo* result) {
#line 1175 "unity-place.c"
	UnityPlace_EntryInfo _tmp0_ = {0};
#line 381 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 1179 "unity-place.c"
	*result = (unity_place__entryinfo_copy (&self->priv->info, &_tmp0_), _tmp0_);
#line 383 "unity-place.vala"
	return;
#line 1183 "unity-place.c"
}


UnityPlaceRendererInfo* unity_place_entry_info_get_entry_renderer_info (UnityPlaceEntryInfo* self) {
	UnityPlaceRendererInfo* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_entry_renderer_info;
#line 232 "unity-place.vala"
	return result;
#line 1193 "unity-place.c"
}


UnityPlaceRendererInfo* unity_place_entry_info_get_global_renderer_info (UnityPlaceEntryInfo* self) {
	UnityPlaceRendererInfo* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_global_renderer_info;
#line 236 "unity-place.vala"
	return result;
#line 1203 "unity-place.c"
}


const char* unity_place_entry_info_get_dbus_path (UnityPlaceEntryInfo* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->info.dbus_path;
#line 240 "unity-place.vala"
	return result;
#line 1213 "unity-place.c"
}


void unity_place_entry_info_set_dbus_path (UnityPlaceEntryInfo* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
#line 241 "unity-place.vala"
	self->priv->info.dbus_path = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->info.dbus_path), _tmp0_);
#line 1222 "unity-place.c"
	g_object_notify ((GObject *) self, "dbus-path");
}


const char* unity_place_entry_info_get_display_name (UnityPlaceEntryInfo* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->info.display_name;
#line 245 "unity-place.vala"
	return result;
#line 1233 "unity-place.c"
}


void unity_place_entry_info_set_display_name (UnityPlaceEntryInfo* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
#line 246 "unity-place.vala"
	self->priv->info.display_name = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->info.display_name), _tmp0_);
#line 1242 "unity-place.c"
	g_object_notify ((GObject *) self, "display-name");
}


const char* unity_place_entry_info_get_icon (UnityPlaceEntryInfo* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->info.icon;
#line 250 "unity-place.vala"
	return result;
#line 1253 "unity-place.c"
}


void unity_place_entry_info_set_icon (UnityPlaceEntryInfo* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
#line 251 "unity-place.vala"
	self->priv->info.icon = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->info.icon), _tmp0_);
#line 1262 "unity-place.c"
	g_object_notify ((GObject *) self, "icon");
}


guint unity_place_entry_info_get_position (UnityPlaceEntryInfo* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->info.position;
#line 255 "unity-place.vala"
	return result;
#line 1273 "unity-place.c"
}


void unity_place_entry_info_set_position (UnityPlaceEntryInfo* self, guint value) {
	g_return_if_fail (self != NULL);
#line 256 "unity-place.vala"
	self->priv->info.position = value;
#line 1281 "unity-place.c"
	g_object_notify ((GObject *) self, "position");
}


char** unity_place_entry_info_get_mimetypes (UnityPlaceEntryInfo* self, int* result_length1) {
	char** result;
	char** _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	result = (_tmp0_ = self->priv->info.mimetypes, *result_length1 = self->priv->info.mimetypes_length1, _tmp0_);
#line 260 "unity-place.vala"
	return result;
#line 1293 "unity-place.c"
}


static char** _vala_array_dup2 (char** self, int length) {
	char** result;
	int i;
	result = g_new0 (char*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


void unity_place_entry_info_set_mimetypes (UnityPlaceEntryInfo* self, char** value, int value_length1) {
	char** _tmp2_;
	char** _tmp1_;
	g_return_if_fail (self != NULL);
#line 261 "unity-place.vala"
	self->priv->info.mimetypes = (_tmp2_ = (_tmp1_ = value, (_tmp1_ == NULL) ? ((gpointer) _tmp1_) : _vala_array_dup2 (_tmp1_, value_length1)), self->priv->info.mimetypes = (_vala_array_free (self->priv->info.mimetypes, self->priv->info.mimetypes_length1, (GDestroyNotify) g_free), NULL), self->priv->info.mimetypes_length1 = value_length1, self->priv->info._mimetypes_size_ = self->priv->info.mimetypes_length1, _tmp2_);
#line 1314 "unity-place.c"
	g_object_notify ((GObject *) self, "mimetypes");
}


gboolean unity_place_entry_info_get_sensitive (UnityPlaceEntryInfo* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->info.sensitive;
#line 265 "unity-place.vala"
	return result;
#line 1325 "unity-place.c"
}


void unity_place_entry_info_set_sensitive (UnityPlaceEntryInfo* self, gboolean value) {
	g_return_if_fail (self != NULL);
#line 266 "unity-place.vala"
	self->priv->info.sensitive = value;
#line 1333 "unity-place.c"
	g_object_notify ((GObject *) self, "sensitive");
}


DeeModel* unity_place_entry_info_get_sections_model (UnityPlaceEntryInfo* self) {
	DeeModel* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_sections_model;
#line 270 "unity-place.vala"
	return result;
#line 1344 "unity-place.c"
}


void unity_place_entry_info_set_sections_model (UnityPlaceEntryInfo* self, DeeModel* value) {
	DeeModel* _tmp0_;
	g_return_if_fail (self != NULL);
#line 272 "unity-place.vala"
	self->priv->_sections_model = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_sections_model), _tmp0_);
#line 273 "unity-place.vala"
	if (DEE_IS_SHARED_MODEL (value)) {
#line 1355 "unity-place.c"
		DeeModel* _tmp1_;
		DeeSharedModel* model;
		char* _tmp2_;
#line 275 "unity-place.vala"
		model = _g_object_ref0 ((_tmp1_ = value, DEE_IS_SHARED_MODEL (_tmp1_) ? ((DeeSharedModel*) _tmp1_) : NULL));
#line 276 "unity-place.vala"
		self->priv->info.sections_model = (_tmp2_ = g_strdup (dee_shared_model_get_swarm_name (model)), _g_free0 (self->priv->info.sections_model), _tmp2_);
#line 1363 "unity-place.c"
		_g_object_unref0 (model);
	} else {
		char* _tmp3_;
#line 279 "unity-place.vala"
		self->priv->info.sections_model = (_tmp3_ = g_strdup ("__local__"), _g_free0 (self->priv->info.sections_model), _tmp3_);
#line 1369 "unity-place.c"
	}
	g_object_notify ((GObject *) self, "sections-model");
}


gboolean unity_place_entry_info_get_active (UnityPlaceEntryInfo* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_active;
#line 284 "unity-place.vala"
	return result;
#line 1381 "unity-place.c"
}


void unity_place_entry_info_set_active (UnityPlaceEntryInfo* self, gboolean value) {
	g_return_if_fail (self != NULL);
#line 285 "unity-place.vala"
	self->priv->_active = value;
#line 1389 "unity-place.c"
	g_object_notify ((GObject *) self, "active");
}


guint unity_place_entry_info_get_active_section (UnityPlaceEntryInfo* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_active_section;
#line 289 "unity-place.vala"
	return result;
#line 1400 "unity-place.c"
}


void unity_place_entry_info_set_active_section (UnityPlaceEntryInfo* self, guint value) {
	g_return_if_fail (self != NULL);
#line 290 "unity-place.vala"
	self->priv->_active_section = value;
#line 1408 "unity-place.c"
	g_object_notify ((GObject *) self, "active-section");
}


UnityPlaceSearchHandler unity_place_entry_info_get_search_handler (UnityPlaceEntryInfo* self, gpointer* result_target) {
	UnityPlaceSearchHandler result;
	UnityPlaceSearchHandler _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	result = (_tmp0_ = self->priv->_search_handler, *result_target = self->priv->_search_handler_target, _tmp0_);
#line 294 "unity-place.vala"
	return result;
#line 1420 "unity-place.c"
}


void unity_place_entry_info_set_search_handler (UnityPlaceEntryInfo* self, UnityPlaceSearchHandler value, gpointer value_target) {
	UnityPlaceSearchHandler _tmp1_;
	g_return_if_fail (self != NULL);
#line 295 "unity-place.vala"
	self->priv->_search_handler = (_tmp1_ = value, ((self->priv->_search_handler_target_destroy_notify == NULL) ? NULL : (self->priv->_search_handler_target_destroy_notify (self->priv->_search_handler_target), NULL), self->priv->_search_handler = NULL, self->priv->_search_handler_target = NULL, self->priv->_search_handler_target_destroy_notify = NULL), self->priv->_search_handler_target = value_target, self->priv->_search_handler_target_destroy_notify = NULL, _tmp1_);
#line 1429 "unity-place.c"
}


UnityPlaceSearchHandler unity_place_entry_info_get_global_search_handler (UnityPlaceEntryInfo* self, gpointer* result_target) {
	UnityPlaceSearchHandler result;
	UnityPlaceSearchHandler _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	result = (_tmp0_ = self->priv->_global_search_handler, *result_target = self->priv->_global_search_handler_target, _tmp0_);
#line 299 "unity-place.vala"
	return result;
#line 1440 "unity-place.c"
}


void unity_place_entry_info_set_global_search_handler (UnityPlaceEntryInfo* self, UnityPlaceSearchHandler value, gpointer value_target) {
	UnityPlaceSearchHandler _tmp1_;
	g_return_if_fail (self != NULL);
#line 300 "unity-place.vala"
	self->priv->_global_search_handler = (_tmp1_ = value, ((self->priv->_global_search_handler_target_destroy_notify == NULL) ? NULL : (self->priv->_global_search_handler_target_destroy_notify (self->priv->_global_search_handler_target), NULL), self->priv->_global_search_handler = NULL, self->priv->_global_search_handler_target = NULL, self->priv->_global_search_handler_target_destroy_notify = NULL), self->priv->_global_search_handler_target = value_target, self->priv->_global_search_handler_target_destroy_notify = NULL, _tmp1_);
#line 1449 "unity-place.c"
}


static GObject * unity_place_entry_info_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityPlaceEntryInfo * self;
	parent_class = G_OBJECT_CLASS (unity_place_entry_info_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_PLACE_ENTRY_INFO (obj);
	{
		GHashTable* _tmp9_;
		char* _tmp10_;
		char* _tmp11_;
		char* _tmp12_;
		GHashTable* _tmp13_;
		char* _tmp14_;
		char* _tmp15_;
		char* _tmp16_;
		GHashTable* _tmp17_;
		UnityPlaceRendererInfo* _tmp18_;
		UnityPlaceRendererInfo* _tmp19_;
#line 308 "unity-place.vala"
		if (self->priv->info.dbus_path == NULL) {
#line 1474 "unity-place.c"
			char* _tmp4_;
#line 310 "unity-place.vala"
			g_critical ("unity-place.vala:310: No DBus path set for EntryInfo.\n" \
"'dbus-path' property in the UnityPlaceEntryInfo constructor");
#line 312 "unity-place.vala"
			self->priv->info.dbus_path = (_tmp4_ = g_strdup (""), _g_free0 (self->priv->info.dbus_path), _tmp4_);
#line 1480 "unity-place.c"
		}
#line 314 "unity-place.vala"
		if (self->priv->info.display_name == NULL) {
#line 1484 "unity-place.c"
			char* _tmp5_;
#line 315 "unity-place.vala"
			self->priv->info.display_name = (_tmp5_ = g_strdup (""), _g_free0 (self->priv->info.display_name), _tmp5_);
#line 1488 "unity-place.c"
		}
#line 316 "unity-place.vala"
		if (self->priv->info.icon == NULL) {
#line 1492 "unity-place.c"
			char* _tmp6_;
#line 317 "unity-place.vala"
			self->priv->info.icon = (_tmp6_ = g_strdup (""), _g_free0 (self->priv->info.icon), _tmp6_);
#line 1496 "unity-place.c"
		}
#line 318 "unity-place.vala"
		self->priv->info.position = (guint) 0;
#line 319 "unity-place.vala"
		if (self->priv->info.mimetypes == NULL) {
#line 1502 "unity-place.c"
			char** _tmp7_;
#line 320 "unity-place.vala"
			self->priv->info.mimetypes = (_tmp7_ = g_new0 (char*, 0 + 1), self->priv->info.mimetypes = (_vala_array_free (self->priv->info.mimetypes, self->priv->info.mimetypes_length1, (GDestroyNotify) g_free), NULL), self->priv->info.mimetypes_length1 = 0, self->priv->info._mimetypes_size_ = self->priv->info.mimetypes_length1, _tmp7_);
#line 1506 "unity-place.c"
		}
#line 321 "unity-place.vala"
		self->priv->info.sensitive = TRUE;
#line 322 "unity-place.vala"
		if (self->priv->info.sections_model == NULL) {
#line 1512 "unity-place.c"
			char* _tmp8_;
#line 323 "unity-place.vala"
			self->priv->info.sections_model = (_tmp8_ = g_strdup (""), _g_free0 (self->priv->info.sections_model), _tmp8_);
#line 1516 "unity-place.c"
		}
#line 324 "unity-place.vala"
		self->priv->info.hints = (_tmp9_ = g_hash_table_new (g_str_hash, g_str_equal), _g_hash_table_unref0 (self->priv->info.hints), _tmp9_);
#line 326 "unity-place.vala"
		self->priv->info.entry_renderer_info.default_renderer = (_tmp10_ = g_strdup (""), _g_free0 (self->priv->info.entry_renderer_info.default_renderer), _tmp10_);
#line 327 "unity-place.vala"
		self->priv->info.entry_renderer_info.groups_model = (_tmp11_ = g_strdup (""), _g_free0 (self->priv->info.entry_renderer_info.groups_model), _tmp11_);
#line 328 "unity-place.vala"
		self->priv->info.entry_renderer_info.results_model = (_tmp12_ = g_strdup (""), _g_free0 (self->priv->info.entry_renderer_info.results_model), _tmp12_);
#line 329 "unity-place.vala"
		self->priv->info.entry_renderer_info.hints = (_tmp13_ = g_hash_table_new (g_str_hash, g_str_equal), _g_hash_table_unref0 (self->priv->info.entry_renderer_info.hints), _tmp13_);
#line 331 "unity-place.vala"
		self->priv->info.global_renderer_info.default_renderer = (_tmp14_ = g_strdup (""), _g_free0 (self->priv->info.global_renderer_info.default_renderer), _tmp14_);
#line 332 "unity-place.vala"
		self->priv->info.global_renderer_info.groups_model = (_tmp15_ = g_strdup (""), _g_free0 (self->priv->info.global_renderer_info.groups_model), _tmp15_);
#line 333 "unity-place.vala"
		self->priv->info.global_renderer_info.results_model = (_tmp16_ = g_strdup (""), _g_free0 (self->priv->info.global_renderer_info.results_model), _tmp16_);
#line 334 "unity-place.vala"
		self->priv->info.global_renderer_info.hints = (_tmp17_ = g_hash_table_new (g_str_hash, g_str_equal), _g_hash_table_unref0 (self->priv->info.global_renderer_info.hints), _tmp17_);
#line 336 "unity-place.vala"
		self->priv->_entry_renderer_info = (_tmp18_ = unity_place_renderer_info_new (&self->priv->info.entry_renderer_info), _g_object_unref0 (self->priv->_entry_renderer_info), _tmp18_);
#line 337 "unity-place.vala"
		self->priv->_global_renderer_info = (_tmp19_ = unity_place_renderer_info_new (&self->priv->info.global_renderer_info), _g_object_unref0 (self->priv->_global_renderer_info), _tmp19_);
#line 1540 "unity-place.c"
	}
	return obj;
}


static void unity_place_entry_info_class_init (UnityPlaceEntryInfoClass * klass) {
	unity_place_entry_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceEntryInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_entry_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_entry_info_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_place_entry_info_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_place_entry_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_ENTRY_RENDERER_INFO, g_param_spec_object ("entry-renderer-info", "entry-renderer-info", "entry-renderer-info", UNITY_PLACE_TYPE_RENDERER_INFO, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_GLOBAL_RENDERER_INFO, g_param_spec_object ("global-renderer-info", "global-renderer-info", "global-renderer-info", UNITY_PLACE_TYPE_RENDERER_INFO, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_DBUS_PATH, g_param_spec_string ("dbus-path", "dbus-path", "dbus-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_DISPLAY_NAME, g_param_spec_string ("display-name", "display-name", "display-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_ICON, g_param_spec_string ("icon", "icon", "icon", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_POSITION, g_param_spec_uint ("position", "position", "position", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_MIMETYPES, g_param_spec_boxed ("mimetypes", "mimetypes", "mimetypes", G_TYPE_STRV, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_SENSITIVE, g_param_spec_boolean ("sensitive", "sensitive", "sensitive", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_SECTIONS_MODEL, g_param_spec_object ("sections-model", "sections-model", "sections-model", DEE_TYPE_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_ACTIVE, g_param_spec_boolean ("active", "active", "active", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_INFO_ACTIVE_SECTION, g_param_spec_uint ("active-section", "active-section", "active-section", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void unity_place_entry_info_instance_init (UnityPlaceEntryInfo * self) {
	UnityPlace_EntryInfo _tmp3_ = {0};
	self->priv = UNITY_PLACE_ENTRY_INFO_GET_PRIVATE (self);
	self->priv->info = (memset (&_tmp3_, 0, sizeof (UnityPlace_EntryInfo)), _tmp3_);
	self->priv->_search_handler = NULL;
	self->priv->_global_search_handler = NULL;
	self->priv->_active = FALSE;
	self->priv->_active_section = (guint) 0;
}


static void unity_place_entry_info_finalize (GObject* obj) {
	UnityPlaceEntryInfo * self;
	self = UNITY_PLACE_ENTRY_INFO (obj);
	unity_place__entryinfo_destroy (&self->priv->info);
	_g_object_unref0 (self->priv->_entry_renderer_info);
	_g_object_unref0 (self->priv->_global_renderer_info);
	_g_object_unref0 (self->priv->_sections_model);
	(self->priv->_search_handler_target_destroy_notify == NULL) ? NULL : (self->priv->_search_handler_target_destroy_notify (self->priv->_search_handler_target), NULL);
	self->priv->_search_handler = NULL;
	self->priv->_search_handler_target = NULL;
	self->priv->_search_handler_target_destroy_notify = NULL;
	(self->priv->_global_search_handler_target_destroy_notify == NULL) ? NULL : (self->priv->_global_search_handler_target_destroy_notify (self->priv->_global_search_handler_target), NULL);
	self->priv->_global_search_handler = NULL;
	self->priv->_global_search_handler_target = NULL;
	self->priv->_global_search_handler_target_destroy_notify = NULL;
	G_OBJECT_CLASS (unity_place_entry_info_parent_class)->finalize (obj);
}


GType unity_place_entry_info_get_type (void) {
	static volatile gsize unity_place_entry_info_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_entry_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceEntryInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_entry_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceEntryInfo), 0, (GInstanceInitFunc) unity_place_entry_info_instance_init, NULL };
		GType unity_place_entry_info_type_id;
		unity_place_entry_info_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceEntryInfo", &g_define_type_info, 0);
		g_once_init_leave (&unity_place_entry_info_type_id__volatile, unity_place_entry_info_type_id);
	}
	return unity_place_entry_info_type_id__volatile;
}


static void unity_place_entry_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceEntryInfo * self;
	int length;
	self = UNITY_PLACE_ENTRY_INFO (object);
	switch (property_id) {
		case UNITY_PLACE_ENTRY_INFO_ENTRY_RENDERER_INFO:
		g_value_set_object (value, unity_place_entry_info_get_entry_renderer_info (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_GLOBAL_RENDERER_INFO:
		g_value_set_object (value, unity_place_entry_info_get_global_renderer_info (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_DBUS_PATH:
		g_value_set_string (value, unity_place_entry_info_get_dbus_path (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_DISPLAY_NAME:
		g_value_set_string (value, unity_place_entry_info_get_display_name (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_ICON:
		g_value_set_string (value, unity_place_entry_info_get_icon (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_POSITION:
		g_value_set_uint (value, unity_place_entry_info_get_position (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_MIMETYPES:
		g_value_set_boxed (value, unity_place_entry_info_get_mimetypes (self, &length));
		break;
		case UNITY_PLACE_ENTRY_INFO_SENSITIVE:
		g_value_set_boolean (value, unity_place_entry_info_get_sensitive (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_SECTIONS_MODEL:
		g_value_set_object (value, unity_place_entry_info_get_sections_model (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE:
		g_value_set_boolean (value, unity_place_entry_info_get_active (self));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE_SECTION:
		g_value_set_uint (value, unity_place_entry_info_get_active_section (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_entry_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceEntryInfo * self;
	gpointer boxed;
	self = UNITY_PLACE_ENTRY_INFO (object);
	switch (property_id) {
		case UNITY_PLACE_ENTRY_INFO_DBUS_PATH:
		unity_place_entry_info_set_dbus_path (self, g_value_get_string (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_DISPLAY_NAME:
		unity_place_entry_info_set_display_name (self, g_value_get_string (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_ICON:
		unity_place_entry_info_set_icon (self, g_value_get_string (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_POSITION:
		unity_place_entry_info_set_position (self, g_value_get_uint (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_MIMETYPES:
		boxed = g_value_get_boxed (value);
		unity_place_entry_info_set_mimetypes (self, boxed, g_strv_length (boxed));
		break;
		case UNITY_PLACE_ENTRY_INFO_SENSITIVE:
		unity_place_entry_info_set_sensitive (self, g_value_get_boolean (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_SECTIONS_MODEL:
		unity_place_entry_info_set_sections_model (self, g_value_get_object (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE:
		unity_place_entry_info_set_active (self, g_value_get_boolean (value));
		break;
		case UNITY_PLACE_ENTRY_INFO_ACTIVE_SECTION:
		unity_place_entry_info_set_active_section (self, g_value_get_uint (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


#line 395 "unity-place.vala"
UnityPlace_EntryInfo* unity_place_service_get_entries (UnityPlaceService* self, int* result_length1, GError** error) {
#line 395 "unity-place.vala"
	return UNITY_PLACE_SERVICE_GET_INTERFACE (self)->get_entries (self, result_length1, error);
#line 1698 "unity-place.c"
}


void _unity_place_service_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_unity_place_service_introspect (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.canonical.Unity.Place\">\n  <method name=\"GetEntries\">\n    <arg name=\"result\" type=\"a(sssuasbsa{ss}(sssa{ss})(sssa{ss}))\" direction=\"out\"/>\n  </method>\n  <signal name=\"EntryAdded\">\n    <arg name=\"entry\" type=\"(sssuasbsa{ss}(sssa{ss})(sssa{ss}))\"/>\n  </signal>\n  <signal name=\"EntryRemoved\">\n    <arg name=\"entry_dbus_path\" type=\"s\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_service_property_get_all (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp20_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp20_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp20_);
	if (strcmp (interface_name, "com.canonical.Unity.Place") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _vala_UnityPlace_EntryInfo_array_free (UnityPlace_EntryInfo* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			unity_place__entryinfo_destroy (&array[i]);
		}
	}
	g_free (array);
}


static DBusHandlerResult _dbus_unity_place_service_get_entries (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	UnityPlace_EntryInfo* result;
	int result_length1;
	DBusMessage* reply;
	UnityPlace_EntryInfo* _tmp21_;
	DBusMessageIter _tmp22_;
	int _tmp23_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result_length1 = 0;
	result = unity_place_service_get_entries (self, &result_length1, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp21_ = result;
	dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "(sssuasbsa{ss}(sssa{ss})(sssa{ss}))", &_tmp22_);
	for (_tmp23_ = 0; _tmp23_ < result_length1; _tmp23_++) {
		DBusMessageIter _tmp24_;
		const char* _tmp25_;
		const char* _tmp26_;
		const char* _tmp27_;
		dbus_uint32_t _tmp28_;
		char** _tmp29_;
		DBusMessageIter _tmp30_;
		int _tmp31_;
		dbus_bool_t _tmp33_;
		const char* _tmp34_;
		DBusMessageIter _tmp35_, _tmp36_;
		GHashTableIter _tmp37_;
		gpointer _tmp38_, _tmp39_;
		DBusMessageIter _tmp42_;
		const char* _tmp43_;
		const char* _tmp44_;
		const char* _tmp45_;
		DBusMessageIter _tmp46_, _tmp47_;
		GHashTableIter _tmp48_;
		gpointer _tmp49_, _tmp50_;
		DBusMessageIter _tmp53_;
		const char* _tmp54_;
		const char* _tmp55_;
		const char* _tmp56_;
		DBusMessageIter _tmp57_, _tmp58_;
		GHashTableIter _tmp59_;
		gpointer _tmp60_, _tmp61_;
		dbus_message_iter_open_container (&_tmp22_, DBUS_TYPE_STRUCT, NULL, &_tmp24_);
		_tmp25_ = (*_tmp21_).dbus_path;
		dbus_message_iter_append_basic (&_tmp24_, DBUS_TYPE_STRING, &_tmp25_);
		_tmp26_ = (*_tmp21_).display_name;
		dbus_message_iter_append_basic (&_tmp24_, DBUS_TYPE_STRING, &_tmp26_);
		_tmp27_ = (*_tmp21_).icon;
		dbus_message_iter_append_basic (&_tmp24_, DBUS_TYPE_STRING, &_tmp27_);
		_tmp28_ = (*_tmp21_).position;
		dbus_message_iter_append_basic (&_tmp24_, DBUS_TYPE_UINT32, &_tmp28_);
		_tmp29_ = (*_tmp21_).mimetypes;
		dbus_message_iter_open_container (&_tmp24_, DBUS_TYPE_ARRAY, "s", &_tmp30_);
		for (_tmp31_ = 0; _tmp31_ < (*_tmp21_).mimetypes_length1; _tmp31_++) {
			const char* _tmp32_;
			_tmp32_ = *_tmp29_;
			dbus_message_iter_append_basic (&_tmp30_, DBUS_TYPE_STRING, &_tmp32_);
			_tmp29_++;
		}
		dbus_message_iter_close_container (&_tmp24_, &_tmp30_);
		_tmp33_ = (*_tmp21_).sensitive;
		dbus_message_iter_append_basic (&_tmp24_, DBUS_TYPE_BOOLEAN, &_tmp33_);
		_tmp34_ = (*_tmp21_).sections_model;
		dbus_message_iter_append_basic (&_tmp24_, DBUS_TYPE_STRING, &_tmp34_);
		dbus_message_iter_open_container (&_tmp24_, DBUS_TYPE_ARRAY, "{ss}", &_tmp35_);
		g_hash_table_iter_init (&_tmp37_, (*_tmp21_).hints);
		while (g_hash_table_iter_next (&_tmp37_, &_tmp38_, &_tmp39_)) {
			char* _key;
			char* _value;
			const char* _tmp40_;
			const char* _tmp41_;
			dbus_message_iter_open_container (&_tmp35_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp36_);
			_key = (char*) _tmp38_;
			_value = (char*) _tmp39_;
			_tmp40_ = _key;
			dbus_message_iter_append_basic (&_tmp36_, DBUS_TYPE_STRING, &_tmp40_);
			_tmp41_ = _value;
			dbus_message_iter_append_basic (&_tmp36_, DBUS_TYPE_STRING, &_tmp41_);
			dbus_message_iter_close_container (&_tmp35_, &_tmp36_);
		}
		dbus_message_iter_close_container (&_tmp24_, &_tmp35_);
		dbus_message_iter_open_container (&_tmp24_, DBUS_TYPE_STRUCT, NULL, &_tmp42_);
		_tmp43_ = (*_tmp21_).entry_renderer_info.default_renderer;
		dbus_message_iter_append_basic (&_tmp42_, DBUS_TYPE_STRING, &_tmp43_);
		_tmp44_ = (*_tmp21_).entry_renderer_info.groups_model;
		dbus_message_iter_append_basic (&_tmp42_, DBUS_TYPE_STRING, &_tmp44_);
		_tmp45_ = (*_tmp21_).entry_renderer_info.results_model;
		dbus_message_iter_append_basic (&_tmp42_, DBUS_TYPE_STRING, &_tmp45_);
		dbus_message_iter_open_container (&_tmp42_, DBUS_TYPE_ARRAY, "{ss}", &_tmp46_);
		g_hash_table_iter_init (&_tmp48_, (*_tmp21_).entry_renderer_info.hints);
		while (g_hash_table_iter_next (&_tmp48_, &_tmp49_, &_tmp50_)) {
			char* _key;
			char* _value;
			const char* _tmp51_;
			const char* _tmp52_;
			dbus_message_iter_open_container (&_tmp46_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp47_);
			_key = (char*) _tmp49_;
			_value = (char*) _tmp50_;
			_tmp51_ = _key;
			dbus_message_iter_append_basic (&_tmp47_, DBUS_TYPE_STRING, &_tmp51_);
			_tmp52_ = _value;
			dbus_message_iter_append_basic (&_tmp47_, DBUS_TYPE_STRING, &_tmp52_);
			dbus_message_iter_close_container (&_tmp46_, &_tmp47_);
		}
		dbus_message_iter_close_container (&_tmp42_, &_tmp46_);
		dbus_message_iter_close_container (&_tmp24_, &_tmp42_);
		dbus_message_iter_open_container (&_tmp24_, DBUS_TYPE_STRUCT, NULL, &_tmp53_);
		_tmp54_ = (*_tmp21_).global_renderer_info.default_renderer;
		dbus_message_iter_append_basic (&_tmp53_, DBUS_TYPE_STRING, &_tmp54_);
		_tmp55_ = (*_tmp21_).global_renderer_info.groups_model;
		dbus_message_iter_append_basic (&_tmp53_, DBUS_TYPE_STRING, &_tmp55_);
		_tmp56_ = (*_tmp21_).global_renderer_info.results_model;
		dbus_message_iter_append_basic (&_tmp53_, DBUS_TYPE_STRING, &_tmp56_);
		dbus_message_iter_open_container (&_tmp53_, DBUS_TYPE_ARRAY, "{ss}", &_tmp57_);
		g_hash_table_iter_init (&_tmp59_, (*_tmp21_).global_renderer_info.hints);
		while (g_hash_table_iter_next (&_tmp59_, &_tmp60_, &_tmp61_)) {
			char* _key;
			char* _value;
			const char* _tmp62_;
			const char* _tmp63_;
			dbus_message_iter_open_container (&_tmp57_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp58_);
			_key = (char*) _tmp60_;
			_value = (char*) _tmp61_;
			_tmp62_ = _key;
			dbus_message_iter_append_basic (&_tmp58_, DBUS_TYPE_STRING, &_tmp62_);
			_tmp63_ = _value;
			dbus_message_iter_append_basic (&_tmp58_, DBUS_TYPE_STRING, &_tmp63_);
			dbus_message_iter_close_container (&_tmp57_, &_tmp58_);
		}
		dbus_message_iter_close_container (&_tmp53_, &_tmp57_);
		dbus_message_iter_close_container (&_tmp24_, &_tmp53_);
		dbus_message_iter_close_container (&_tmp22_, &_tmp24_);
		_tmp21_++;
	}
	dbus_message_iter_close_container (&iter, &_tmp22_);
	result = (_vala_UnityPlace_EntryInfo_array_free (result,  result_length1), NULL);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult unity_place_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_unity_place_service_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_unity_place_service_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.Place", "GetEntries")) {
		result = _dbus_unity_place_service_get_entries (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _dbus_unity_place_service_entry_added (GObject* _sender, UnityPlace_EntryInfo* entry, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	DBusMessageIter _tmp64_;
	const char* _tmp65_;
	const char* _tmp66_;
	const char* _tmp67_;
	dbus_uint32_t _tmp68_;
	char** _tmp69_;
	DBusMessageIter _tmp70_;
	int _tmp71_;
	dbus_bool_t _tmp73_;
	const char* _tmp74_;
	DBusMessageIter _tmp75_, _tmp76_;
	GHashTableIter _tmp77_;
	gpointer _tmp78_, _tmp79_;
	DBusMessageIter _tmp82_;
	const char* _tmp83_;
	const char* _tmp84_;
	const char* _tmp85_;
	DBusMessageIter _tmp86_, _tmp87_;
	GHashTableIter _tmp88_;
	gpointer _tmp89_, _tmp90_;
	DBusMessageIter _tmp93_;
	const char* _tmp94_;
	const char* _tmp95_;
	const char* _tmp96_;
	DBusMessageIter _tmp97_, _tmp98_;
	GHashTableIter _tmp99_;
	gpointer _tmp100_, _tmp101_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.canonical.Unity.Place", "EntryAdded");
	dbus_message_iter_init_append (_message, &_iter);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_STRUCT, NULL, &_tmp64_);
	_tmp65_ = (*entry).dbus_path;
	dbus_message_iter_append_basic (&_tmp64_, DBUS_TYPE_STRING, &_tmp65_);
	_tmp66_ = (*entry).display_name;
	dbus_message_iter_append_basic (&_tmp64_, DBUS_TYPE_STRING, &_tmp66_);
	_tmp67_ = (*entry).icon;
	dbus_message_iter_append_basic (&_tmp64_, DBUS_TYPE_STRING, &_tmp67_);
	_tmp68_ = (*entry).position;
	dbus_message_iter_append_basic (&_tmp64_, DBUS_TYPE_UINT32, &_tmp68_);
	_tmp69_ = (*entry).mimetypes;
	dbus_message_iter_open_container (&_tmp64_, DBUS_TYPE_ARRAY, "s", &_tmp70_);
	for (_tmp71_ = 0; _tmp71_ < (*entry).mimetypes_length1; _tmp71_++) {
		const char* _tmp72_;
		_tmp72_ = *_tmp69_;
		dbus_message_iter_append_basic (&_tmp70_, DBUS_TYPE_STRING, &_tmp72_);
		_tmp69_++;
	}
	dbus_message_iter_close_container (&_tmp64_, &_tmp70_);
	_tmp73_ = (*entry).sensitive;
	dbus_message_iter_append_basic (&_tmp64_, DBUS_TYPE_BOOLEAN, &_tmp73_);
	_tmp74_ = (*entry).sections_model;
	dbus_message_iter_append_basic (&_tmp64_, DBUS_TYPE_STRING, &_tmp74_);
	dbus_message_iter_open_container (&_tmp64_, DBUS_TYPE_ARRAY, "{ss}", &_tmp75_);
	g_hash_table_iter_init (&_tmp77_, (*entry).hints);
	while (g_hash_table_iter_next (&_tmp77_, &_tmp78_, &_tmp79_)) {
		char* _key;
		char* _value;
		const char* _tmp80_;
		const char* _tmp81_;
		dbus_message_iter_open_container (&_tmp75_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp76_);
		_key = (char*) _tmp78_;
		_value = (char*) _tmp79_;
		_tmp80_ = _key;
		dbus_message_iter_append_basic (&_tmp76_, DBUS_TYPE_STRING, &_tmp80_);
		_tmp81_ = _value;
		dbus_message_iter_append_basic (&_tmp76_, DBUS_TYPE_STRING, &_tmp81_);
		dbus_message_iter_close_container (&_tmp75_, &_tmp76_);
	}
	dbus_message_iter_close_container (&_tmp64_, &_tmp75_);
	dbus_message_iter_open_container (&_tmp64_, DBUS_TYPE_STRUCT, NULL, &_tmp82_);
	_tmp83_ = (*entry).entry_renderer_info.default_renderer;
	dbus_message_iter_append_basic (&_tmp82_, DBUS_TYPE_STRING, &_tmp83_);
	_tmp84_ = (*entry).entry_renderer_info.groups_model;
	dbus_message_iter_append_basic (&_tmp82_, DBUS_TYPE_STRING, &_tmp84_);
	_tmp85_ = (*entry).entry_renderer_info.results_model;
	dbus_message_iter_append_basic (&_tmp82_, DBUS_TYPE_STRING, &_tmp85_);
	dbus_message_iter_open_container (&_tmp82_, DBUS_TYPE_ARRAY, "{ss}", &_tmp86_);
	g_hash_table_iter_init (&_tmp88_, (*entry).entry_renderer_info.hints);
	while (g_hash_table_iter_next (&_tmp88_, &_tmp89_, &_tmp90_)) {
		char* _key;
		char* _value;
		const char* _tmp91_;
		const char* _tmp92_;
		dbus_message_iter_open_container (&_tmp86_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp87_);
		_key = (char*) _tmp89_;
		_value = (char*) _tmp90_;
		_tmp91_ = _key;
		dbus_message_iter_append_basic (&_tmp87_, DBUS_TYPE_STRING, &_tmp91_);
		_tmp92_ = _value;
		dbus_message_iter_append_basic (&_tmp87_, DBUS_TYPE_STRING, &_tmp92_);
		dbus_message_iter_close_container (&_tmp86_, &_tmp87_);
	}
	dbus_message_iter_close_container (&_tmp82_, &_tmp86_);
	dbus_message_iter_close_container (&_tmp64_, &_tmp82_);
	dbus_message_iter_open_container (&_tmp64_, DBUS_TYPE_STRUCT, NULL, &_tmp93_);
	_tmp94_ = (*entry).global_renderer_info.default_renderer;
	dbus_message_iter_append_basic (&_tmp93_, DBUS_TYPE_STRING, &_tmp94_);
	_tmp95_ = (*entry).global_renderer_info.groups_model;
	dbus_message_iter_append_basic (&_tmp93_, DBUS_TYPE_STRING, &_tmp95_);
	_tmp96_ = (*entry).global_renderer_info.results_model;
	dbus_message_iter_append_basic (&_tmp93_, DBUS_TYPE_STRING, &_tmp96_);
	dbus_message_iter_open_container (&_tmp93_, DBUS_TYPE_ARRAY, "{ss}", &_tmp97_);
	g_hash_table_iter_init (&_tmp99_, (*entry).global_renderer_info.hints);
	while (g_hash_table_iter_next (&_tmp99_, &_tmp100_, &_tmp101_)) {
		char* _key;
		char* _value;
		const char* _tmp102_;
		const char* _tmp103_;
		dbus_message_iter_open_container (&_tmp97_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp98_);
		_key = (char*) _tmp100_;
		_value = (char*) _tmp101_;
		_tmp102_ = _key;
		dbus_message_iter_append_basic (&_tmp98_, DBUS_TYPE_STRING, &_tmp102_);
		_tmp103_ = _value;
		dbus_message_iter_append_basic (&_tmp98_, DBUS_TYPE_STRING, &_tmp103_);
		dbus_message_iter_close_container (&_tmp97_, &_tmp98_);
	}
	dbus_message_iter_close_container (&_tmp93_, &_tmp97_);
	dbus_message_iter_close_container (&_tmp64_, &_tmp93_);
	dbus_message_iter_close_container (&_iter, &_tmp64_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_unity_place_service_entry_removed (GObject* _sender, const char* entry_dbus_path, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	const char* _tmp104_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.canonical.Unity.Place", "EntryRemoved");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp104_ = entry_dbus_path;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp104_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


void unity_place_service_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_unity_place_service_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	g_signal_connect (object, "entry-added", (GCallback) _dbus_unity_place_service_entry_added, connection);
	g_signal_connect (object, "entry-removed", (GCallback) _dbus_unity_place_service_entry_removed, connection);
}


static void unity_place_service_base_init (UnityPlaceServiceIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("entry_added", UNITY_PLACE_TYPE_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, UNITY_PLACE_TYPE__ENTRYINFO);
		g_signal_new ("entry_removed", UNITY_PLACE_TYPE_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
		g_type_set_qdata (UNITY_PLACE_TYPE_SERVICE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_unity_place_service_dbus_vtable));
	}
}


GType unity_place_service_get_type (void) {
	static volatile gsize unity_place_service_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_service_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceServiceIface), (GBaseInitFunc) unity_place_service_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType unity_place_service_type_id;
		unity_place_service_type_id = g_type_register_static (G_TYPE_INTERFACE, "UnityPlaceService", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (unity_place_service_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (unity_place_service_type_id, g_quark_from_string ("ValaDBusInterfaceProxyType"), &unity_place_service_dbus_proxy_get_type);
		g_once_init_leave (&unity_place_service_type_id__volatile, unity_place_service_type_id);
	}
	return unity_place_service_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (UnityPlaceServiceDBusProxy, unity_place_service_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE (UNITY_PLACE_TYPE_SERVICE, unity_place_service_dbus_proxy_unity_place_service__interface_init) );
UnityPlaceService* unity_place_service_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path) {
	UnityPlaceService* self;
	self = g_object_new (unity_place_service_dbus_proxy_get_type (), "connection", connection, "name", name, "path", path, "interface", "com.canonical.Unity.Place", NULL);
	return self;
}


static GObject* unity_place_service_dbus_proxy_construct (GType gtype, guint n_properties, GObjectConstructParam* properties) {
	GObject* self;
	DBusGConnection *connection;
	char* path;
	char* filter;
	self = G_OBJECT_CLASS (unity_place_service_dbus_proxy_parent_class)->constructor (gtype, n_properties, properties);
	g_object_get (self, "connection", &connection, NULL);
	g_object_get (self, "path", &path, NULL);
	dbus_connection_add_filter (dbus_g_connection_get_connection (connection), unity_place_service_dbus_proxy_filter, self, NULL);
	filter = g_strdup_printf ("type='signal',path='%s'", path);
	dbus_bus_add_match (dbus_g_connection_get_connection (connection), filter, NULL);
	dbus_g_connection_unref (connection);
	g_free (path);
	g_free (filter);
	return self;
}


static void _dbus_handle_unity_place_service_entry_added (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	UnityPlace_EntryInfo entry = {0};
	UnityPlace_EntryInfo _tmp105_;
	DBusMessageIter _tmp106_;
	const char* _tmp107_;
	const char* _tmp108_;
	const char* _tmp109_;
	dbus_uint32_t _tmp110_;
	char** _tmp111_;
	int _tmp111__length;
	int _tmp111__size;
	int _tmp111__length1;
	DBusMessageIter _tmp112_;
	dbus_bool_t _tmp114_;
	const char* _tmp115_;
	GHashTable* _tmp116_;
	DBusMessageIter _tmp117_;
	DBusMessageIter _tmp118_;
	UnityPlace_RendererInfo _tmp121_;
	DBusMessageIter _tmp122_;
	const char* _tmp123_;
	const char* _tmp124_;
	const char* _tmp125_;
	GHashTable* _tmp126_;
	DBusMessageIter _tmp127_;
	DBusMessageIter _tmp128_;
	UnityPlace_RendererInfo _tmp131_;
	DBusMessageIter _tmp132_;
	const char* _tmp133_;
	const char* _tmp134_;
	const char* _tmp135_;
	GHashTable* _tmp136_;
	DBusMessageIter _tmp137_;
	DBusMessageIter _tmp138_;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "(sssuasbsa{ss}(sssa{ss})(sssa{ss}))")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_recurse (&iter, &_tmp106_);
	dbus_message_iter_get_basic (&_tmp106_, &_tmp107_);
	dbus_message_iter_next (&_tmp106_);
	_tmp105_.dbus_path = g_strdup (_tmp107_);
	dbus_message_iter_get_basic (&_tmp106_, &_tmp108_);
	dbus_message_iter_next (&_tmp106_);
	_tmp105_.display_name = g_strdup (_tmp108_);
	dbus_message_iter_get_basic (&_tmp106_, &_tmp109_);
	dbus_message_iter_next (&_tmp106_);
	_tmp105_.icon = g_strdup (_tmp109_);
	dbus_message_iter_get_basic (&_tmp106_, &_tmp110_);
	dbus_message_iter_next (&_tmp106_);
	_tmp105_.position = _tmp110_;
	_tmp111_ = g_new (char*, 5);
	_tmp111__length = 0;
	_tmp111__size = 4;
	_tmp111__length1 = 0;
	dbus_message_iter_recurse (&_tmp106_, &_tmp112_);
	for (; dbus_message_iter_get_arg_type (&_tmp112_); _tmp111__length1++) {
		const char* _tmp113_;
		if (_tmp111__size == _tmp111__length) {
			_tmp111__size = 2 * _tmp111__size;
			_tmp111_ = g_renew (char*, _tmp111_, _tmp111__size + 1);
		}
		dbus_message_iter_get_basic (&_tmp112_, &_tmp113_);
		dbus_message_iter_next (&_tmp112_);
		_tmp111_[_tmp111__length++] = g_strdup (_tmp113_);
	}
	_tmp105_.mimetypes_length1 = _tmp111__length1;
	_tmp111_[_tmp111__length] = NULL;
	dbus_message_iter_next (&_tmp106_);
	_tmp105_.mimetypes = _tmp111_;
	dbus_message_iter_get_basic (&_tmp106_, &_tmp114_);
	dbus_message_iter_next (&_tmp106_);
	_tmp105_.sensitive = _tmp114_;
	dbus_message_iter_get_basic (&_tmp106_, &_tmp115_);
	dbus_message_iter_next (&_tmp106_);
	_tmp105_.sections_model = g_strdup (_tmp115_);
	_tmp116_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&_tmp106_, &_tmp117_);
	while (dbus_message_iter_get_arg_type (&_tmp117_)) {
		char* _key;
		char* _value;
		const char* _tmp119_;
		const char* _tmp120_;
		dbus_message_iter_recurse (&_tmp117_, &_tmp118_);
		dbus_message_iter_get_basic (&_tmp118_, &_tmp119_);
		dbus_message_iter_next (&_tmp118_);
		_key = g_strdup (_tmp119_);
		dbus_message_iter_get_basic (&_tmp118_, &_tmp120_);
		dbus_message_iter_next (&_tmp118_);
		_value = g_strdup (_tmp120_);
		g_hash_table_insert (_tmp116_, _key, _value);
		dbus_message_iter_next (&_tmp117_);
	}
	dbus_message_iter_next (&_tmp106_);
	_tmp105_.hints = _tmp116_;
	dbus_message_iter_recurse (&_tmp106_, &_tmp122_);
	dbus_message_iter_get_basic (&_tmp122_, &_tmp123_);
	dbus_message_iter_next (&_tmp122_);
	_tmp121_.default_renderer = g_strdup (_tmp123_);
	dbus_message_iter_get_basic (&_tmp122_, &_tmp124_);
	dbus_message_iter_next (&_tmp122_);
	_tmp121_.groups_model = g_strdup (_tmp124_);
	dbus_message_iter_get_basic (&_tmp122_, &_tmp125_);
	dbus_message_iter_next (&_tmp122_);
	_tmp121_.results_model = g_strdup (_tmp125_);
	_tmp126_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&_tmp122_, &_tmp127_);
	while (dbus_message_iter_get_arg_type (&_tmp127_)) {
		char* _key;
		char* _value;
		const char* _tmp129_;
		const char* _tmp130_;
		dbus_message_iter_recurse (&_tmp127_, &_tmp128_);
		dbus_message_iter_get_basic (&_tmp128_, &_tmp129_);
		dbus_message_iter_next (&_tmp128_);
		_key = g_strdup (_tmp129_);
		dbus_message_iter_get_basic (&_tmp128_, &_tmp130_);
		dbus_message_iter_next (&_tmp128_);
		_value = g_strdup (_tmp130_);
		g_hash_table_insert (_tmp126_, _key, _value);
		dbus_message_iter_next (&_tmp127_);
	}
	dbus_message_iter_next (&_tmp122_);
	_tmp121_.hints = _tmp126_;
	dbus_message_iter_next (&_tmp106_);
	_tmp105_.entry_renderer_info = _tmp121_;
	dbus_message_iter_recurse (&_tmp106_, &_tmp132_);
	dbus_message_iter_get_basic (&_tmp132_, &_tmp133_);
	dbus_message_iter_next (&_tmp132_);
	_tmp131_.default_renderer = g_strdup (_tmp133_);
	dbus_message_iter_get_basic (&_tmp132_, &_tmp134_);
	dbus_message_iter_next (&_tmp132_);
	_tmp131_.groups_model = g_strdup (_tmp134_);
	dbus_message_iter_get_basic (&_tmp132_, &_tmp135_);
	dbus_message_iter_next (&_tmp132_);
	_tmp131_.results_model = g_strdup (_tmp135_);
	_tmp136_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&_tmp132_, &_tmp137_);
	while (dbus_message_iter_get_arg_type (&_tmp137_)) {
		char* _key;
		char* _value;
		const char* _tmp139_;
		const char* _tmp140_;
		dbus_message_iter_recurse (&_tmp137_, &_tmp138_);
		dbus_message_iter_get_basic (&_tmp138_, &_tmp139_);
		dbus_message_iter_next (&_tmp138_);
		_key = g_strdup (_tmp139_);
		dbus_message_iter_get_basic (&_tmp138_, &_tmp140_);
		dbus_message_iter_next (&_tmp138_);
		_value = g_strdup (_tmp140_);
		g_hash_table_insert (_tmp136_, _key, _value);
		dbus_message_iter_next (&_tmp137_);
	}
	dbus_message_iter_next (&_tmp132_);
	_tmp131_.hints = _tmp136_;
	dbus_message_iter_next (&_tmp106_);
	_tmp105_.global_renderer_info = _tmp131_;
	dbus_message_iter_next (&iter);
	entry = _tmp105_;
	g_signal_emit_by_name (self, "entry-added", &entry);
	unity_place__entryinfo_destroy (&entry);
}


static void _dbus_handle_unity_place_service_entry_removed (UnityPlaceService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	char* entry_dbus_path = NULL;
	const char* _tmp141_;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp141_);
	dbus_message_iter_next (&iter);
	entry_dbus_path = g_strdup (_tmp141_);
	g_signal_emit_by_name (self, "entry-removed", entry_dbus_path);
	_g_free0 (entry_dbus_path);
}


DBusHandlerResult unity_place_service_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data) {
	if (dbus_message_has_path (message, dbus_g_proxy_get_path (user_data))) {
		if (dbus_message_is_signal (message, "com.canonical.Unity.Place", "EntryAdded")) {
			_dbus_handle_unity_place_service_entry_added (user_data, connection, message);
		} else if (dbus_message_is_signal (message, "com.canonical.Unity.Place", "EntryRemoved")) {
			_dbus_handle_unity_place_service_entry_removed (user_data, connection, message);
		}
	}
	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void unity_place_service_dbus_proxy_dispose (GObject* self) {
	DBusGConnection *connection;
	if (((UnityPlaceServiceDBusProxy*) self)->disposed) {
		return;
	}
	((UnityPlaceServiceDBusProxy*) self)->disposed = TRUE;
	g_object_get (self, "connection", &connection, NULL);
	dbus_connection_remove_filter (dbus_g_connection_get_connection (connection), unity_place_service_dbus_proxy_filter, self);
	G_OBJECT_CLASS (unity_place_service_dbus_proxy_parent_class)->dispose (self);
}


static void unity_place_service_dbus_proxy_class_init (UnityPlaceServiceDBusProxyClass* klass) {
	G_OBJECT_CLASS (klass)->constructor = unity_place_service_dbus_proxy_construct;
	G_OBJECT_CLASS (klass)->dispose = unity_place_service_dbus_proxy_dispose;
	G_OBJECT_CLASS (klass)->get_property = unity_place_service_dbus_proxy_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_service_dbus_proxy_set_property;
}


static void unity_place_service_dbus_proxy_init (UnityPlaceServiceDBusProxy* self) {
}


static UnityPlace_EntryInfo* unity_place_service_dbus_proxy_get_entries (UnityPlaceService* self, int* result_length1, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	UnityPlace_EntryInfo* _result;
	int _result_length1;
	UnityPlace_EntryInfo* _tmp142_;
	int _tmp142__length;
	int _tmp142__size;
	int _tmp142__length1;
	DBusMessageIter _tmp143_;
	if (((UnityPlaceServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.Place", "GetEntries");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp180_;
			_edomain = DBUS_GERROR;
			_tmp180_ = _dbus_error.name + 27;
			if (strcmp (_tmp180_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp180_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp180_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp180_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp180_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp180_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp180_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp180_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp180_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp180_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp180_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp180_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp180_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp180_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp180_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp180_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp180_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp180_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp180_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp180_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp180_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp180_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp180_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp180_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp180_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp180_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp180_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp180_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp180_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp180_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp180_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp180_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp180_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return NULL;
	}
	if (strcmp (dbus_message_get_signature (_reply), "a(sssuasbsa{ss}(sssa{ss})(sssa{ss}))")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "a(sssuasbsa{ss}(sssa{ss})(sssa{ss}))", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_init (_reply, &_iter);
	_result_length1 = 0;
	_tmp142_ = g_new (UnityPlace_EntryInfo, 5);
	_tmp142__length = 0;
	_tmp142__size = 4;
	_tmp142__length1 = 0;
	dbus_message_iter_recurse (&_iter, &_tmp143_);
	for (; dbus_message_iter_get_arg_type (&_tmp143_); _tmp142__length1++) {
		UnityPlace_EntryInfo _tmp144_;
		DBusMessageIter _tmp145_;
		const char* _tmp146_;
		const char* _tmp147_;
		const char* _tmp148_;
		dbus_uint32_t _tmp149_;
		char** _tmp150_;
		int _tmp150__length;
		int _tmp150__size;
		int _tmp150__length1;
		DBusMessageIter _tmp151_;
		dbus_bool_t _tmp153_;
		const char* _tmp154_;
		GHashTable* _tmp155_;
		DBusMessageIter _tmp156_;
		DBusMessageIter _tmp157_;
		UnityPlace_RendererInfo _tmp160_;
		DBusMessageIter _tmp161_;
		const char* _tmp162_;
		const char* _tmp163_;
		const char* _tmp164_;
		GHashTable* _tmp165_;
		DBusMessageIter _tmp166_;
		DBusMessageIter _tmp167_;
		UnityPlace_RendererInfo _tmp170_;
		DBusMessageIter _tmp171_;
		const char* _tmp172_;
		const char* _tmp173_;
		const char* _tmp174_;
		GHashTable* _tmp175_;
		DBusMessageIter _tmp176_;
		DBusMessageIter _tmp177_;
		if (_tmp142__size == _tmp142__length) {
			_tmp142__size = 2 * _tmp142__size;
			_tmp142_ = g_renew (UnityPlace_EntryInfo, _tmp142_, _tmp142__size + 1);
		}
		dbus_message_iter_recurse (&_tmp143_, &_tmp145_);
		dbus_message_iter_get_basic (&_tmp145_, &_tmp146_);
		dbus_message_iter_next (&_tmp145_);
		_tmp144_.dbus_path = g_strdup (_tmp146_);
		dbus_message_iter_get_basic (&_tmp145_, &_tmp147_);
		dbus_message_iter_next (&_tmp145_);
		_tmp144_.display_name = g_strdup (_tmp147_);
		dbus_message_iter_get_basic (&_tmp145_, &_tmp148_);
		dbus_message_iter_next (&_tmp145_);
		_tmp144_.icon = g_strdup (_tmp148_);
		dbus_message_iter_get_basic (&_tmp145_, &_tmp149_);
		dbus_message_iter_next (&_tmp145_);
		_tmp144_.position = _tmp149_;
		_tmp150_ = g_new (char*, 5);
		_tmp150__length = 0;
		_tmp150__size = 4;
		_tmp150__length1 = 0;
		dbus_message_iter_recurse (&_tmp145_, &_tmp151_);
		for (; dbus_message_iter_get_arg_type (&_tmp151_); _tmp150__length1++) {
			const char* _tmp152_;
			if (_tmp150__size == _tmp150__length) {
				_tmp150__size = 2 * _tmp150__size;
				_tmp150_ = g_renew (char*, _tmp150_, _tmp150__size + 1);
			}
			dbus_message_iter_get_basic (&_tmp151_, &_tmp152_);
			dbus_message_iter_next (&_tmp151_);
			_tmp150_[_tmp150__length++] = g_strdup (_tmp152_);
		}
		_tmp144_.mimetypes_length1 = _tmp150__length1;
		_tmp150_[_tmp150__length] = NULL;
		dbus_message_iter_next (&_tmp145_);
		_tmp144_.mimetypes = _tmp150_;
		dbus_message_iter_get_basic (&_tmp145_, &_tmp153_);
		dbus_message_iter_next (&_tmp145_);
		_tmp144_.sensitive = _tmp153_;
		dbus_message_iter_get_basic (&_tmp145_, &_tmp154_);
		dbus_message_iter_next (&_tmp145_);
		_tmp144_.sections_model = g_strdup (_tmp154_);
		_tmp155_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
		dbus_message_iter_recurse (&_tmp145_, &_tmp156_);
		while (dbus_message_iter_get_arg_type (&_tmp156_)) {
			char* _key;
			char* _value;
			const char* _tmp158_;
			const char* _tmp159_;
			dbus_message_iter_recurse (&_tmp156_, &_tmp157_);
			dbus_message_iter_get_basic (&_tmp157_, &_tmp158_);
			dbus_message_iter_next (&_tmp157_);
			_key = g_strdup (_tmp158_);
			dbus_message_iter_get_basic (&_tmp157_, &_tmp159_);
			dbus_message_iter_next (&_tmp157_);
			_value = g_strdup (_tmp159_);
			g_hash_table_insert (_tmp155_, _key, _value);
			dbus_message_iter_next (&_tmp156_);
		}
		dbus_message_iter_next (&_tmp145_);
		_tmp144_.hints = _tmp155_;
		dbus_message_iter_recurse (&_tmp145_, &_tmp161_);
		dbus_message_iter_get_basic (&_tmp161_, &_tmp162_);
		dbus_message_iter_next (&_tmp161_);
		_tmp160_.default_renderer = g_strdup (_tmp162_);
		dbus_message_iter_get_basic (&_tmp161_, &_tmp163_);
		dbus_message_iter_next (&_tmp161_);
		_tmp160_.groups_model = g_strdup (_tmp163_);
		dbus_message_iter_get_basic (&_tmp161_, &_tmp164_);
		dbus_message_iter_next (&_tmp161_);
		_tmp160_.results_model = g_strdup (_tmp164_);
		_tmp165_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
		dbus_message_iter_recurse (&_tmp161_, &_tmp166_);
		while (dbus_message_iter_get_arg_type (&_tmp166_)) {
			char* _key;
			char* _value;
			const char* _tmp168_;
			const char* _tmp169_;
			dbus_message_iter_recurse (&_tmp166_, &_tmp167_);
			dbus_message_iter_get_basic (&_tmp167_, &_tmp168_);
			dbus_message_iter_next (&_tmp167_);
			_key = g_strdup (_tmp168_);
			dbus_message_iter_get_basic (&_tmp167_, &_tmp169_);
			dbus_message_iter_next (&_tmp167_);
			_value = g_strdup (_tmp169_);
			g_hash_table_insert (_tmp165_, _key, _value);
			dbus_message_iter_next (&_tmp166_);
		}
		dbus_message_iter_next (&_tmp161_);
		_tmp160_.hints = _tmp165_;
		dbus_message_iter_next (&_tmp145_);
		_tmp144_.entry_renderer_info = _tmp160_;
		dbus_message_iter_recurse (&_tmp145_, &_tmp171_);
		dbus_message_iter_get_basic (&_tmp171_, &_tmp172_);
		dbus_message_iter_next (&_tmp171_);
		_tmp170_.default_renderer = g_strdup (_tmp172_);
		dbus_message_iter_get_basic (&_tmp171_, &_tmp173_);
		dbus_message_iter_next (&_tmp171_);
		_tmp170_.groups_model = g_strdup (_tmp173_);
		dbus_message_iter_get_basic (&_tmp171_, &_tmp174_);
		dbus_message_iter_next (&_tmp171_);
		_tmp170_.results_model = g_strdup (_tmp174_);
		_tmp175_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
		dbus_message_iter_recurse (&_tmp171_, &_tmp176_);
		while (dbus_message_iter_get_arg_type (&_tmp176_)) {
			char* _key;
			char* _value;
			const char* _tmp178_;
			const char* _tmp179_;
			dbus_message_iter_recurse (&_tmp176_, &_tmp177_);
			dbus_message_iter_get_basic (&_tmp177_, &_tmp178_);
			dbus_message_iter_next (&_tmp177_);
			_key = g_strdup (_tmp178_);
			dbus_message_iter_get_basic (&_tmp177_, &_tmp179_);
			dbus_message_iter_next (&_tmp177_);
			_value = g_strdup (_tmp179_);
			g_hash_table_insert (_tmp175_, _key, _value);
			dbus_message_iter_next (&_tmp176_);
		}
		dbus_message_iter_next (&_tmp171_);
		_tmp170_.hints = _tmp175_;
		dbus_message_iter_next (&_tmp145_);
		_tmp144_.global_renderer_info = _tmp170_;
		dbus_message_iter_next (&_tmp143_);
		_tmp142_[_tmp142__length++] = _tmp144_;
	}
	_result_length1 = _tmp142__length1;
	dbus_message_iter_next (&_iter);
	_result = _tmp142_;
	*result_length1 = _result_length1;
	dbus_message_unref (_reply);
	return _result;
}


static void unity_place_service_dbus_proxy_unity_place_service__interface_init (UnityPlaceServiceIface* iface) {
	iface->get_entries = unity_place_service_dbus_proxy_get_entries;
}


static void unity_place_service_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
}


static void unity_place_service_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
}


#line 410 "unity-place.vala"
guint unity_place_entry_service_set_global_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error) {
#line 410 "unity-place.vala"
	return UNITY_PLACE_ENTRY_SERVICE_GET_INTERFACE (self)->set_global_search (self, search, hints, error);
#line 2779 "unity-place.c"
}


#line 413 "unity-place.vala"
guint unity_place_entry_service_set_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error) {
#line 413 "unity-place.vala"
	return UNITY_PLACE_ENTRY_SERVICE_GET_INTERFACE (self)->set_search (self, search, hints, error);
#line 2787 "unity-place.c"
}


#line 416 "unity-place.vala"
void unity_place_entry_service_set_active (UnityPlaceEntryService* self, gboolean is_active, GError** error) {
#line 416 "unity-place.vala"
	UNITY_PLACE_ENTRY_SERVICE_GET_INTERFACE (self)->set_active (self, is_active, error);
#line 2795 "unity-place.c"
}


#line 418 "unity-place.vala"
void unity_place_entry_service_set_active_section (UnityPlaceEntryService* self, guint section_id, GError** error) {
#line 418 "unity-place.vala"
	UNITY_PLACE_ENTRY_SERVICE_GET_INTERFACE (self)->set_active_section (self, section_id, error);
#line 2803 "unity-place.c"
}


void _unity_place_entry_service_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_unity_place_entry_service_introspect (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.canonical.Unity.PlaceEntry\">\n  <method name=\"SetGlobalSearch\">\n    <arg name=\"search\" type=\"s\" direction=\"in\"/>\n    <arg name=\"hints\" type=\"a{ss}\" direction=\"in\"/>\n    <arg name=\"result\" type=\"u\" direction=\"out\"/>\n  </method>\n  <method name=\"SetSearch\">\n    <arg name=\"search\" type=\"s\" direction=\"in\"/>\n    <arg name=\"hints\" type=\"a{ss}\" direction=\"in\"/>\n    <arg name=\"result\" type=\"u\" direction=\"out\"/>\n  </method>\n  <method name=\"SetActive\">\n    <arg name=\"is_active\" type=\"b\" direction=\"in\"/>\n  </method>\n  <method name=\"SetActiveSection\">\n    <arg name=\"section_id\" type=\"u\" direction=\"in\"/>\n  </method>\n  <signal name=\"RendererInfoChanged\">\n    <arg name=\"renderer_info\" type=\"(sssa{ss})\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_entry_service_property_get_all (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp181_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp181_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp181_);
	if (strcmp (interface_name, "com.canonical.Unity.PlaceEntry") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_entry_service_set_global_search (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* search = NULL;
	const char* _tmp182_;
	GHashTable* hints = NULL;
	GHashTable* _tmp183_;
	DBusMessageIter _tmp184_;
	DBusMessageIter _tmp185_;
	guint result;
	DBusMessage* reply;
	dbus_uint32_t _tmp188_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "sa{ss}")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp182_);
	dbus_message_iter_next (&iter);
	search = g_strdup (_tmp182_);
	_tmp183_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&iter, &_tmp184_);
	while (dbus_message_iter_get_arg_type (&_tmp184_)) {
		char* _key;
		char* _value;
		const char* _tmp186_;
		const char* _tmp187_;
		dbus_message_iter_recurse (&_tmp184_, &_tmp185_);
		dbus_message_iter_get_basic (&_tmp185_, &_tmp186_);
		dbus_message_iter_next (&_tmp185_);
		_key = g_strdup (_tmp186_);
		dbus_message_iter_get_basic (&_tmp185_, &_tmp187_);
		dbus_message_iter_next (&_tmp185_);
		_value = g_strdup (_tmp187_);
		g_hash_table_insert (_tmp183_, _key, _value);
		dbus_message_iter_next (&_tmp184_);
	}
	dbus_message_iter_next (&iter);
	hints = _tmp183_;
	result = unity_place_entry_service_set_global_search (self, search, hints, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (search);
	_g_hash_table_unref0 (hints);
	_tmp188_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &_tmp188_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_entry_service_set_search (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* search = NULL;
	const char* _tmp189_;
	GHashTable* hints = NULL;
	GHashTable* _tmp190_;
	DBusMessageIter _tmp191_;
	DBusMessageIter _tmp192_;
	guint result;
	DBusMessage* reply;
	dbus_uint32_t _tmp195_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "sa{ss}")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp189_);
	dbus_message_iter_next (&iter);
	search = g_strdup (_tmp189_);
	_tmp190_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&iter, &_tmp191_);
	while (dbus_message_iter_get_arg_type (&_tmp191_)) {
		char* _key;
		char* _value;
		const char* _tmp193_;
		const char* _tmp194_;
		dbus_message_iter_recurse (&_tmp191_, &_tmp192_);
		dbus_message_iter_get_basic (&_tmp192_, &_tmp193_);
		dbus_message_iter_next (&_tmp192_);
		_key = g_strdup (_tmp193_);
		dbus_message_iter_get_basic (&_tmp192_, &_tmp194_);
		dbus_message_iter_next (&_tmp192_);
		_value = g_strdup (_tmp194_);
		g_hash_table_insert (_tmp190_, _key, _value);
		dbus_message_iter_next (&_tmp191_);
	}
	dbus_message_iter_next (&iter);
	hints = _tmp190_;
	result = unity_place_entry_service_set_search (self, search, hints, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (search);
	_g_hash_table_unref0 (hints);
	_tmp195_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &_tmp195_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_entry_service_set_active (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gboolean is_active = FALSE;
	dbus_bool_t _tmp196_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "b")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp196_);
	dbus_message_iter_next (&iter);
	is_active = _tmp196_;
	unity_place_entry_service_set_active (self, is_active, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_unity_place_entry_service_set_active_section (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	guint section_id = 0U;
	dbus_uint32_t _tmp197_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "u")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp197_);
	dbus_message_iter_next (&iter);
	section_id = _tmp197_;
	unity_place_entry_service_set_active_section (self, section_id, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult unity_place_entry_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_unity_place_entry_service_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_unity_place_entry_service_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceEntry", "SetGlobalSearch")) {
		result = _dbus_unity_place_entry_service_set_global_search (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceEntry", "SetSearch")) {
		result = _dbus_unity_place_entry_service_set_search (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceEntry", "SetActive")) {
		result = _dbus_unity_place_entry_service_set_active (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.canonical.Unity.PlaceEntry", "SetActiveSection")) {
		result = _dbus_unity_place_entry_service_set_active_section (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _dbus_unity_place_entry_service_renderer_info_changed (GObject* _sender, UnityPlace_RendererInfo* renderer_info, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	DBusMessageIter _tmp198_;
	const char* _tmp199_;
	const char* _tmp200_;
	const char* _tmp201_;
	DBusMessageIter _tmp202_, _tmp203_;
	GHashTableIter _tmp204_;
	gpointer _tmp205_, _tmp206_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.canonical.Unity.PlaceEntry", "RendererInfoChanged");
	dbus_message_iter_init_append (_message, &_iter);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_STRUCT, NULL, &_tmp198_);
	_tmp199_ = (*renderer_info).default_renderer;
	dbus_message_iter_append_basic (&_tmp198_, DBUS_TYPE_STRING, &_tmp199_);
	_tmp200_ = (*renderer_info).groups_model;
	dbus_message_iter_append_basic (&_tmp198_, DBUS_TYPE_STRING, &_tmp200_);
	_tmp201_ = (*renderer_info).results_model;
	dbus_message_iter_append_basic (&_tmp198_, DBUS_TYPE_STRING, &_tmp201_);
	dbus_message_iter_open_container (&_tmp198_, DBUS_TYPE_ARRAY, "{ss}", &_tmp202_);
	g_hash_table_iter_init (&_tmp204_, (*renderer_info).hints);
	while (g_hash_table_iter_next (&_tmp204_, &_tmp205_, &_tmp206_)) {
		char* _key;
		char* _value;
		const char* _tmp207_;
		const char* _tmp208_;
		dbus_message_iter_open_container (&_tmp202_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp203_);
		_key = (char*) _tmp205_;
		_value = (char*) _tmp206_;
		_tmp207_ = _key;
		dbus_message_iter_append_basic (&_tmp203_, DBUS_TYPE_STRING, &_tmp207_);
		_tmp208_ = _value;
		dbus_message_iter_append_basic (&_tmp203_, DBUS_TYPE_STRING, &_tmp208_);
		dbus_message_iter_close_container (&_tmp202_, &_tmp203_);
	}
	dbus_message_iter_close_container (&_tmp198_, &_tmp202_);
	dbus_message_iter_close_container (&_iter, &_tmp198_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


void unity_place_entry_service_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_unity_place_entry_service_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	g_signal_connect (object, "renderer-info-changed", (GCallback) _dbus_unity_place_entry_service_renderer_info_changed, connection);
}


static void unity_place_entry_service_base_init (UnityPlaceEntryServiceIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("renderer_info_changed", UNITY_PLACE_TYPE_ENTRY_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, UNITY_PLACE_TYPE__RENDERERINFO);
		g_type_set_qdata (UNITY_PLACE_TYPE_ENTRY_SERVICE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_unity_place_entry_service_dbus_vtable));
	}
}


GType unity_place_entry_service_get_type (void) {
	static volatile gsize unity_place_entry_service_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_entry_service_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceEntryServiceIface), (GBaseInitFunc) unity_place_entry_service_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType unity_place_entry_service_type_id;
		unity_place_entry_service_type_id = g_type_register_static (G_TYPE_INTERFACE, "UnityPlaceEntryService", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (unity_place_entry_service_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (unity_place_entry_service_type_id, g_quark_from_string ("ValaDBusInterfaceProxyType"), &unity_place_entry_service_dbus_proxy_get_type);
		g_once_init_leave (&unity_place_entry_service_type_id__volatile, unity_place_entry_service_type_id);
	}
	return unity_place_entry_service_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (UnityPlaceEntryServiceDBusProxy, unity_place_entry_service_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE (UNITY_PLACE_TYPE_ENTRY_SERVICE, unity_place_entry_service_dbus_proxy_unity_place_entry_service__interface_init) );
UnityPlaceEntryService* unity_place_entry_service_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path) {
	UnityPlaceEntryService* self;
	self = g_object_new (unity_place_entry_service_dbus_proxy_get_type (), "connection", connection, "name", name, "path", path, "interface", "com.canonical.Unity.PlaceEntry", NULL);
	return self;
}


static GObject* unity_place_entry_service_dbus_proxy_construct (GType gtype, guint n_properties, GObjectConstructParam* properties) {
	GObject* self;
	DBusGConnection *connection;
	char* path;
	char* filter;
	self = G_OBJECT_CLASS (unity_place_entry_service_dbus_proxy_parent_class)->constructor (gtype, n_properties, properties);
	g_object_get (self, "connection", &connection, NULL);
	g_object_get (self, "path", &path, NULL);
	dbus_connection_add_filter (dbus_g_connection_get_connection (connection), unity_place_entry_service_dbus_proxy_filter, self, NULL);
	filter = g_strdup_printf ("type='signal',path='%s'", path);
	dbus_bus_add_match (dbus_g_connection_get_connection (connection), filter, NULL);
	dbus_g_connection_unref (connection);
	g_free (path);
	g_free (filter);
	return self;
}


static void _dbus_handle_unity_place_entry_service_renderer_info_changed (UnityPlaceEntryService* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	UnityPlace_RendererInfo renderer_info = {0};
	UnityPlace_RendererInfo _tmp209_;
	DBusMessageIter _tmp210_;
	const char* _tmp211_;
	const char* _tmp212_;
	const char* _tmp213_;
	GHashTable* _tmp214_;
	DBusMessageIter _tmp215_;
	DBusMessageIter _tmp216_;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "(sssa{ss})")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_recurse (&iter, &_tmp210_);
	dbus_message_iter_get_basic (&_tmp210_, &_tmp211_);
	dbus_message_iter_next (&_tmp210_);
	_tmp209_.default_renderer = g_strdup (_tmp211_);
	dbus_message_iter_get_basic (&_tmp210_, &_tmp212_);
	dbus_message_iter_next (&_tmp210_);
	_tmp209_.groups_model = g_strdup (_tmp212_);
	dbus_message_iter_get_basic (&_tmp210_, &_tmp213_);
	dbus_message_iter_next (&_tmp210_);
	_tmp209_.results_model = g_strdup (_tmp213_);
	_tmp214_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	dbus_message_iter_recurse (&_tmp210_, &_tmp215_);
	while (dbus_message_iter_get_arg_type (&_tmp215_)) {
		char* _key;
		char* _value;
		const char* _tmp217_;
		const char* _tmp218_;
		dbus_message_iter_recurse (&_tmp215_, &_tmp216_);
		dbus_message_iter_get_basic (&_tmp216_, &_tmp217_);
		dbus_message_iter_next (&_tmp216_);
		_key = g_strdup (_tmp217_);
		dbus_message_iter_get_basic (&_tmp216_, &_tmp218_);
		dbus_message_iter_next (&_tmp216_);
		_value = g_strdup (_tmp218_);
		g_hash_table_insert (_tmp214_, _key, _value);
		dbus_message_iter_next (&_tmp215_);
	}
	dbus_message_iter_next (&_tmp210_);
	_tmp209_.hints = _tmp214_;
	dbus_message_iter_next (&iter);
	renderer_info = _tmp209_;
	g_signal_emit_by_name (self, "renderer-info-changed", &renderer_info);
	unity_place__rendererinfo_destroy (&renderer_info);
}


DBusHandlerResult unity_place_entry_service_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data) {
	if (dbus_message_has_path (message, dbus_g_proxy_get_path (user_data))) {
		if (dbus_message_is_signal (message, "com.canonical.Unity.PlaceEntry", "RendererInfoChanged")) {
			_dbus_handle_unity_place_entry_service_renderer_info_changed (user_data, connection, message);
		}
	}
	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void unity_place_entry_service_dbus_proxy_dispose (GObject* self) {
	DBusGConnection *connection;
	if (((UnityPlaceEntryServiceDBusProxy*) self)->disposed) {
		return;
	}
	((UnityPlaceEntryServiceDBusProxy*) self)->disposed = TRUE;
	g_object_get (self, "connection", &connection, NULL);
	dbus_connection_remove_filter (dbus_g_connection_get_connection (connection), unity_place_entry_service_dbus_proxy_filter, self);
	G_OBJECT_CLASS (unity_place_entry_service_dbus_proxy_parent_class)->dispose (self);
}


static void unity_place_entry_service_dbus_proxy_class_init (UnityPlaceEntryServiceDBusProxyClass* klass) {
	G_OBJECT_CLASS (klass)->constructor = unity_place_entry_service_dbus_proxy_construct;
	G_OBJECT_CLASS (klass)->dispose = unity_place_entry_service_dbus_proxy_dispose;
	G_OBJECT_CLASS (klass)->get_property = unity_place_entry_service_dbus_proxy_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_entry_service_dbus_proxy_set_property;
}


static void unity_place_entry_service_dbus_proxy_init (UnityPlaceEntryServiceDBusProxy* self) {
}


static guint unity_place_entry_service_dbus_proxy_set_global_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	const char* _tmp219_;
	DBusMessageIter _tmp220_, _tmp221_;
	GHashTableIter _tmp222_;
	gpointer _tmp223_, _tmp224_;
	guint _result;
	dbus_uint32_t _tmp227_;
	if (((UnityPlaceEntryServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return 0U;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceEntry", "SetGlobalSearch");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp219_ = search;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp219_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_ARRAY, "{ss}", &_tmp220_);
	g_hash_table_iter_init (&_tmp222_, hints);
	while (g_hash_table_iter_next (&_tmp222_, &_tmp223_, &_tmp224_)) {
		char* _key;
		char* _value;
		const char* _tmp225_;
		const char* _tmp226_;
		dbus_message_iter_open_container (&_tmp220_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp221_);
		_key = (char*) _tmp223_;
		_value = (char*) _tmp224_;
		_tmp225_ = _key;
		dbus_message_iter_append_basic (&_tmp221_, DBUS_TYPE_STRING, &_tmp225_);
		_tmp226_ = _value;
		dbus_message_iter_append_basic (&_tmp221_, DBUS_TYPE_STRING, &_tmp226_);
		dbus_message_iter_close_container (&_tmp220_, &_tmp221_);
	}
	dbus_message_iter_close_container (&_iter, &_tmp220_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp228_;
			_edomain = DBUS_GERROR;
			_tmp228_ = _dbus_error.name + 27;
			if (strcmp (_tmp228_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp228_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp228_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp228_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp228_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp228_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp228_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp228_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp228_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp228_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp228_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp228_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp228_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp228_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp228_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp228_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp228_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp228_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp228_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp228_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp228_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp228_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp228_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp228_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp228_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp228_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp228_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp228_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp228_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp228_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp228_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp228_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp228_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return 0U;
	}
	if (strcmp (dbus_message_get_signature (_reply), "u")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "u", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return 0U;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_get_basic (&_iter, &_tmp227_);
	dbus_message_iter_next (&_iter);
	_result = _tmp227_;
	dbus_message_unref (_reply);
	return _result;
}


static guint unity_place_entry_service_dbus_proxy_set_search (UnityPlaceEntryService* self, const char* search, GHashTable* hints, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	const char* _tmp229_;
	DBusMessageIter _tmp230_, _tmp231_;
	GHashTableIter _tmp232_;
	gpointer _tmp233_, _tmp234_;
	guint _result;
	dbus_uint32_t _tmp237_;
	if (((UnityPlaceEntryServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return 0U;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceEntry", "SetSearch");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp229_ = search;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp229_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_ARRAY, "{ss}", &_tmp230_);
	g_hash_table_iter_init (&_tmp232_, hints);
	while (g_hash_table_iter_next (&_tmp232_, &_tmp233_, &_tmp234_)) {
		char* _key;
		char* _value;
		const char* _tmp235_;
		const char* _tmp236_;
		dbus_message_iter_open_container (&_tmp230_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp231_);
		_key = (char*) _tmp233_;
		_value = (char*) _tmp234_;
		_tmp235_ = _key;
		dbus_message_iter_append_basic (&_tmp231_, DBUS_TYPE_STRING, &_tmp235_);
		_tmp236_ = _value;
		dbus_message_iter_append_basic (&_tmp231_, DBUS_TYPE_STRING, &_tmp236_);
		dbus_message_iter_close_container (&_tmp230_, &_tmp231_);
	}
	dbus_message_iter_close_container (&_iter, &_tmp230_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp238_;
			_edomain = DBUS_GERROR;
			_tmp238_ = _dbus_error.name + 27;
			if (strcmp (_tmp238_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp238_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp238_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp238_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp238_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp238_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp238_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp238_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp238_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp238_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp238_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp238_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp238_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp238_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp238_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp238_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp238_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp238_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp238_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp238_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp238_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp238_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp238_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp238_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp238_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp238_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp238_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp238_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp238_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp238_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp238_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp238_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp238_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return 0U;
	}
	if (strcmp (dbus_message_get_signature (_reply), "u")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "u", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return 0U;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_get_basic (&_iter, &_tmp237_);
	dbus_message_iter_next (&_iter);
	_result = _tmp237_;
	dbus_message_unref (_reply);
	return _result;
}


static void unity_place_entry_service_dbus_proxy_set_active (UnityPlaceEntryService* self, gboolean is_active, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	dbus_bool_t _tmp239_;
	if (((UnityPlaceEntryServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceEntry", "SetActive");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp239_ = is_active;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_BOOLEAN, &_tmp239_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp240_;
			_edomain = DBUS_GERROR;
			_tmp240_ = _dbus_error.name + 27;
			if (strcmp (_tmp240_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp240_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp240_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp240_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp240_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp240_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp240_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp240_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp240_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp240_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp240_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp240_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp240_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp240_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp240_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp240_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp240_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp240_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp240_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp240_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp240_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp240_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp240_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp240_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp240_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp240_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp240_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp240_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp240_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp240_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp240_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp240_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp240_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void unity_place_entry_service_dbus_proxy_set_active_section (UnityPlaceEntryService* self, guint section_id, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	dbus_uint32_t _tmp241_;
	if (((UnityPlaceEntryServiceDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.canonical.Unity.PlaceEntry", "SetActiveSection");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp241_ = section_id;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT32, &_tmp241_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp242_;
			_edomain = DBUS_GERROR;
			_tmp242_ = _dbus_error.name + 27;
			if (strcmp (_tmp242_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp242_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp242_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp242_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp242_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp242_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp242_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp242_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp242_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp242_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp242_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp242_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp242_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp242_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp242_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp242_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp242_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp242_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp242_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp242_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp242_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp242_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp242_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp242_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp242_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp242_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp242_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp242_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp242_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp242_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp242_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp242_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp242_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void unity_place_entry_service_dbus_proxy_unity_place_entry_service__interface_init (UnityPlaceEntryServiceIface* iface) {
	iface->set_global_search = unity_place_entry_service_dbus_proxy_set_global_search;
	iface->set_search = unity_place_entry_service_dbus_proxy_set_search;
	iface->set_active = unity_place_entry_service_dbus_proxy_set_active;
	iface->set_active_section = unity_place_entry_service_dbus_proxy_set_active_section;
}


static void unity_place_entry_service_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
}


static void unity_place_entry_service_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
}


#line 457 "unity-place.vala"
UnityPlaceServiceImpl* unity_place_service_impl_construct (GType object_type, const char* dbus_path) {
#line 4185 "unity-place.c"
	UnityPlaceServiceImpl * self;
#line 457 "unity-place.vala"
	g_return_val_if_fail (dbus_path != NULL, NULL);
#line 459 "unity-place.vala"
	self = (UnityPlaceServiceImpl*) g_object_new (object_type, "dbus-path", dbus_path, NULL);
#line 4191 "unity-place.c"
	return self;
}


#line 457 "unity-place.vala"
UnityPlaceServiceImpl* unity_place_service_impl_new (const char* dbus_path) {
#line 457 "unity-place.vala"
	return unity_place_service_impl_construct (UNITY_PLACE_TYPE_SERVICE_IMPL, dbus_path);
#line 4200 "unity-place.c"
}


#line 466 "unity-place.vala"
static UnityPlace_EntryInfo* unity_place_service_impl_real_get_entries (UnityPlaceService* base, int* result_length1, GError** error) {
#line 4206 "unity-place.c"
	UnityPlaceServiceImpl * self;
	UnityPlace_EntryInfo* result = NULL;
	UnityPlace_EntryInfo* _tmp1_;
	gint __result__size_;
	gint _result__length1;
	gint _tmp0_;
	UnityPlace_EntryInfo* _result_;
	gint i;
	UnityPlace_EntryInfo* _tmp4_;
	self = (UnityPlaceServiceImpl*) base;
	_result_ = (_tmp1_ = g_new0 (UnityPlace_EntryInfo, _tmp0_ = g_hash_table_size (self->priv->entries)), _result__length1 = _tmp0_, __result__size_ = _result__length1, _tmp1_);
#line 470 "unity-place.vala"
	i = 0;
#line 4220 "unity-place.c"
	{
		GList* entry_collection;
		GList* entry_it;
#line 471 "unity-place.vala"
		entry_collection = g_hash_table_get_values (self->priv->entries);
#line 4226 "unity-place.c"
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			UnityPlaceEntryServiceImpl* entry;
#line 471 "unity-place.vala"
			entry = (UnityPlaceEntryServiceImpl*) entry_it->data;
#line 4231 "unity-place.c"
			{
				UnityPlace_EntryInfo _tmp3_;
				UnityPlace_EntryInfo _tmp2_ = {0};
#line 473 "unity-place.vala"
				_result_[i] = (_tmp3_ = (unity_place_entry_info_get_raw (unity_place_entry_service_impl_get_entry_info (entry), &_tmp2_), _tmp2_), unity_place__entryinfo_destroy (&_result_[i]), _tmp3_);
#line 474 "unity-place.vala"
				i++;
#line 4239 "unity-place.c"
			}
		}
#line 471 "unity-place.vala"
		_g_list_free0 (entry_collection);
#line 4244 "unity-place.c"
	}
	result = (_tmp4_ = _result_, *result_length1 = _result__length1, _tmp4_);
#line 477 "unity-place.vala"
	return result;
#line 4249 "unity-place.c"
	_result_ = (_vala_UnityPlace_EntryInfo_array_free (_result_, _result__length1), NULL);
}


#line 484 "unity-place.vala"
void unity_place_service_impl_add_entry (UnityPlaceServiceImpl* self, UnityPlaceEntryInfo* entry_info) {
#line 4256 "unity-place.c"
	GError * _inner_error_;
	UnityPlaceEntryServiceImpl* entry;
	UnityPlace_EntryInfo _tmp2_;
	UnityPlace_EntryInfo _tmp1_;
	UnityPlace_EntryInfo _tmp0_ = {0};
#line 484 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 484 "unity-place.vala"
	g_return_if_fail (entry_info != NULL);
#line 4266 "unity-place.c"
	_inner_error_ = NULL;
#line 486 "unity-place.vala"
	if (((UnityPlaceEntryServiceImpl*) g_hash_table_lookup (self->priv->entries, unity_place_entry_info_get_dbus_path (entry_info))) != NULL) {
#line 487 "unity-place.vala"
		return;
#line 4272 "unity-place.c"
	}
#line 489 "unity-place.vala"
	entry = unity_place_entry_service_impl_new (entry_info);
#line 490 "unity-place.vala"
	g_hash_table_insert (self->priv->entries, g_strdup (unity_place_entry_info_get_dbus_path (entry_info)), _g_object_ref0 (entry));
#line 491 "unity-place.vala"
	if (self->priv->_exported) {
#line 4280 "unity-place.c"
		{
#line 494 "unity-place.vala"
			unity_place_entry_service_impl_export (entry, &_inner_error_);
#line 4284 "unity-place.c"
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == DBUS_GERROR) {
					goto __catch23_dbus_gerror;
				}
				_g_object_unref0 (entry);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		goto __finally23;
		__catch23_dbus_gerror:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
#line 496 "unity-place.vala"
				g_critical ("unity-place.vala:496: Failed to export place entry '%s': %s", unity_place_entry_info_get_dbus_path (entry_info), e->message);
#line 4304 "unity-place.c"
				_g_error_free0 (e);
			}
		}
		__finally23:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (entry);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
#line 500 "unity-place.vala"
	g_signal_emit_by_name ((UnityPlaceService*) self, "entry-added", (_tmp2_ = _tmp1_ = (unity_place_entry_info_get_raw (entry_info, &_tmp0_), _tmp0_), &_tmp2_));
#line 4318 "unity-place.c"
	unity_place__entryinfo_destroy (&_tmp1_);
	_g_object_unref0 (entry);
}


#line 503 "unity-place.vala"
UnityPlaceEntryInfo* unity_place_service_impl_get_entry (UnityPlaceServiceImpl* self, const char* dbus_path) {
#line 4326 "unity-place.c"
	UnityPlaceEntryInfo* result = NULL;
	UnityPlaceEntryServiceImpl* entry;
#line 503 "unity-place.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 503 "unity-place.vala"
	g_return_val_if_fail (dbus_path != NULL, NULL);
#line 505 "unity-place.vala"
	entry = _g_object_ref0 ((UnityPlaceEntryServiceImpl*) g_hash_table_lookup (self->priv->entries, dbus_path));
#line 506 "unity-place.vala"
	if (entry != NULL) {
#line 4337 "unity-place.c"
		result = _g_object_ref0 (unity_place_entry_service_impl_get_entry_info (entry));
		_g_object_unref0 (entry);
#line 507 "unity-place.vala"
		return result;
#line 4342 "unity-place.c"
	} else {
		result = NULL;
		_g_object_unref0 (entry);
#line 509 "unity-place.vala"
		return result;
#line 4348 "unity-place.c"
	}
	_g_object_unref0 (entry);
}


#line 512 "unity-place.vala"
guint unity_place_service_impl_num_entries (UnityPlaceServiceImpl* self) {
#line 4356 "unity-place.c"
	guint result = 0U;
#line 512 "unity-place.vala"
	g_return_val_if_fail (self != NULL, 0U);
#line 4360 "unity-place.c"
	result = g_hash_table_size (self->priv->entries);
#line 514 "unity-place.vala"
	return result;
#line 4364 "unity-place.c"
}


#line 517 "unity-place.vala"
char** unity_place_service_impl_get_entry_paths (UnityPlaceServiceImpl* self, int* result_length1) {
#line 4370 "unity-place.c"
	char** result = NULL;
	char** _tmp1_;
	gint __result__size_;
	gint _result__length1;
	gint _tmp0_;
	char** _result_;
	gint i;
	char** _tmp3_;
#line 517 "unity-place.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 4381 "unity-place.c"
	_result_ = (_tmp1_ = g_new0 (char*, (_tmp0_ = g_hash_table_size (self->priv->entries)) + 1), _result__length1 = _tmp0_, __result__size_ = _result__length1, _tmp1_);
#line 521 "unity-place.vala"
	i = 0;
#line 4385 "unity-place.c"
	{
		GList* entry_collection;
		GList* entry_it;
#line 522 "unity-place.vala"
		entry_collection = g_hash_table_get_values (self->priv->entries);
#line 4391 "unity-place.c"
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			UnityPlaceEntryServiceImpl* entry;
#line 522 "unity-place.vala"
			entry = (UnityPlaceEntryServiceImpl*) entry_it->data;
#line 4396 "unity-place.c"
			{
				char* _tmp2_;
#line 524 "unity-place.vala"
				_result_[i] = (_tmp2_ = g_strdup (unity_place_entry_info_get_dbus_path (unity_place_entry_service_impl_get_entry_info (entry))), _g_free0 (_result_[i]), _tmp2_);
#line 525 "unity-place.vala"
				i++;
#line 4403 "unity-place.c"
			}
		}
#line 522 "unity-place.vala"
		_g_list_free0 (entry_collection);
#line 4408 "unity-place.c"
	}
	result = (_tmp3_ = _result_, *result_length1 = _result__length1, _tmp3_);
#line 528 "unity-place.vala"
	return result;
#line 4413 "unity-place.c"
	_result_ = (_vala_array_free (_result_, _result__length1, (GDestroyNotify) g_free), NULL);
}


#line 531 "unity-place.vala"
void unity_place_service_impl_remove_entry (UnityPlaceServiceImpl* self, const char* dbus_path) {
#line 4420 "unity-place.c"
	GError * _inner_error_;
	UnityPlaceEntryServiceImpl* entry;
#line 531 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 531 "unity-place.vala"
	g_return_if_fail (dbus_path != NULL);
#line 4427 "unity-place.c"
	_inner_error_ = NULL;
#line 533 "unity-place.vala"
	entry = _g_object_ref0 ((UnityPlaceEntryServiceImpl*) g_hash_table_lookup (self->priv->entries, dbus_path));
#line 535 "unity-place.vala"
	if (entry == NULL) {
#line 4433 "unity-place.c"
		_g_object_unref0 (entry);
#line 536 "unity-place.vala"
		return;
#line 4437 "unity-place.c"
	}
#line 538 "unity-place.vala"
	g_signal_emit_by_name ((UnityPlaceService*) self, "entry-removed", dbus_path);
#line 539 "unity-place.vala"
	if (self->priv->_exported) {
#line 4443 "unity-place.c"
		{
#line 542 "unity-place.vala"
			unity_place_entry_service_impl_unexport (entry, &_inner_error_);
#line 4447 "unity-place.c"
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == DBUS_GERROR) {
					goto __catch24_dbus_gerror;
				}
				_g_object_unref0 (entry);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		goto __finally24;
		__catch24_dbus_gerror:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
#line 544 "unity-place.vala"
				g_critical ("unity-place.vala:544: Failed to unexport place entry '%s': %s", unity_place_entry_info_get_dbus_path (unity_place_entry_service_impl_get_entry_info (entry)), e->message);
#line 4467 "unity-place.c"
				_g_error_free0 (e);
			}
		}
		__finally24:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (entry);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
#line 549 "unity-place.vala"
	g_hash_table_remove (self->priv->entries, dbus_path);
#line 4481 "unity-place.c"
	_g_object_unref0 (entry);
}


#line 552 "unity-place.vala"
void unity_place_service_impl_export (UnityPlaceServiceImpl* self, GError** error) {
#line 4488 "unity-place.c"
	GError * _inner_error_;
	DBusGConnection* conn;
#line 552 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 4493 "unity-place.c"
	_inner_error_ = NULL;
#line 554 "unity-place.vala"
	conn = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
#line 4497 "unity-place.c"
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DBUS_GERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
#line 555 "unity-place.vala"
	_vala_dbus_register_object (dbus_g_connection_get_connection (conn), self->priv->_dbus_path, (GObject*) self);
#line 4510 "unity-place.c"
	{
		GList* entry_collection;
		GList* entry_it;
#line 557 "unity-place.vala"
		entry_collection = g_hash_table_get_values (self->priv->entries);
#line 4516 "unity-place.c"
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			UnityPlaceEntryServiceImpl* entry;
#line 557 "unity-place.vala"
			entry = (UnityPlaceEntryServiceImpl*) entry_it->data;
#line 4521 "unity-place.c"
			{
#line 559 "unity-place.vala"
				unity_place_entry_service_impl_export (entry, &_inner_error_);
#line 4525 "unity-place.c"
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == DBUS_GERROR) {
						g_propagate_error (error, _inner_error_);
						_g_list_free0 (entry_collection);
						_dbus_g_connection_unref0 (conn);
						return;
					} else {
						_g_list_free0 (entry_collection);
						_dbus_g_connection_unref0 (conn);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
		}
#line 557 "unity-place.vala"
		_g_list_free0 (entry_collection);
#line 4544 "unity-place.c"
	}
#line 562 "unity-place.vala"
	self->priv->_exported = TRUE;
#line 563 "unity-place.vala"
	g_object_notify ((GObject*) self, "exported");
#line 4550 "unity-place.c"
	_dbus_g_connection_unref0 (conn);
}


#line 566 "unity-place.vala"
void unity_place_service_impl_unexport (UnityPlaceServiceImpl* self, GError** error) {
#line 4557 "unity-place.c"
	GError * _inner_error_;
#line 566 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 4561 "unity-place.c"
	_inner_error_ = NULL;
	{
		GList* entry_collection;
		GList* entry_it;
#line 568 "unity-place.vala"
		entry_collection = g_hash_table_get_values (self->priv->entries);
#line 4568 "unity-place.c"
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			UnityPlaceEntryServiceImpl* entry;
#line 568 "unity-place.vala"
			entry = (UnityPlaceEntryServiceImpl*) entry_it->data;
#line 4573 "unity-place.c"
			{
#line 570 "unity-place.vala"
				unity_place_entry_service_impl_unexport (entry, &_inner_error_);
#line 4577 "unity-place.c"
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == DBUS_GERROR) {
						g_propagate_error (error, _inner_error_);
						_g_list_free0 (entry_collection);
						return;
					} else {
						_g_list_free0 (entry_collection);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
		}
#line 568 "unity-place.vala"
		_g_list_free0 (entry_collection);
#line 4594 "unity-place.c"
	}
#line 576 "unity-place.vala"
	self->priv->_exported = FALSE;
#line 577 "unity-place.vala"
	g_object_notify ((GObject*) self, "exported");
#line 4600 "unity-place.c"
}


const char* unity_place_service_impl_get_dbus_path (UnityPlaceServiceImpl* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_dbus_path;
#line 441 "unity-place.vala"
	return result;
#line 4610 "unity-place.c"
}


static void unity_place_service_impl_set_dbus_path (UnityPlaceServiceImpl* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
#line 442 "unity-place.vala"
	self->priv->_dbus_path = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_dbus_path), _tmp0_);
#line 4619 "unity-place.c"
	g_object_notify ((GObject *) self, "dbus-path");
}


gboolean unity_place_service_impl_get_exported (UnityPlaceServiceImpl* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_exported;
#line 446 "unity-place.vala"
	return result;
#line 4630 "unity-place.c"
}


static GObject * unity_place_service_impl_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityPlaceServiceImpl * self;
	parent_class = G_OBJECT_CLASS (unity_place_service_impl_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_PLACE_SERVICE_IMPL (obj);
	{
		GHashTable* _tmp243_;
#line 454 "unity-place.vala"
		self->priv->entries = (_tmp243_ = g_hash_table_new (g_str_hash, g_str_equal), _g_hash_table_unref0 (self->priv->entries), _tmp243_);
#line 4645 "unity-place.c"
	}
	return obj;
}


void _unity_place_service_impl_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_unity_place_service_impl_introspect (UnityPlaceServiceImpl* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.canonical.Unity.Place\">\n  <method name=\"GetEntries\">\n    <arg name=\"result\" type=\"a(sssuasbsa{ss}(sssa{ss})(sssa{ss}))\" direction=\"out\"/>\n  </method>\n  <signal name=\"EntryAdded\">\n    <arg name=\"entry\" type=\"(sssuasbsa{ss}(sssa{ss})(sssa{ss}))\"/>\n  </signal>\n  <signal name=\"EntryRemoved\">\n    <arg name=\"entry_dbus_path\" type=\"s\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult unity_place_service_impl_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_unity_place_service_impl_introspect (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else if (unity_place_service_dbus_message (connection, message, object) == DBUS_HANDLER_RESULT_HANDLED) {
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


void unity_place_service_impl_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_unity_place_service_impl_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	unity_place_service_dbus_register_object (connection, path, object);
}


static void unity_place_service_impl_class_init (UnityPlaceServiceImplClass * klass) {
	unity_place_service_impl_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceServiceImplPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_service_impl_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_service_impl_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_place_service_impl_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_place_service_impl_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_SERVICE_IMPL_DBUS_PATH, g_param_spec_string ("dbus-path", "dbus-path", "dbus-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_SERVICE_IMPL_EXPORTED, g_param_spec_boolean ("exported", "exported", "exported", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_type_set_qdata (UNITY_PLACE_TYPE_SERVICE_IMPL, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_unity_place_service_impl_dbus_vtable));
}


static void unity_place_service_impl_unity_place_service_interface_init (UnityPlaceServiceIface * iface) {
	unity_place_service_impl_unity_place_service_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_entries = unity_place_service_impl_real_get_entries;
}


static void unity_place_service_impl_instance_init (UnityPlaceServiceImpl * self) {
	self->priv = UNITY_PLACE_SERVICE_IMPL_GET_PRIVATE (self);
}


static void unity_place_service_impl_finalize (GObject* obj) {
	UnityPlaceServiceImpl * self;
	self = UNITY_PLACE_SERVICE_IMPL (obj);
	_g_free0 (self->priv->_dbus_path);
	_g_hash_table_unref0 (self->priv->entries);
	G_OBJECT_CLASS (unity_place_service_impl_parent_class)->finalize (obj);
}


GType unity_place_service_impl_get_type (void) {
	static volatile gsize unity_place_service_impl_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_service_impl_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceServiceImplClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_service_impl_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceServiceImpl), 0, (GInstanceInitFunc) unity_place_service_impl_instance_init, NULL };
		static const GInterfaceInfo unity_place_service_info = { (GInterfaceInitFunc) unity_place_service_impl_unity_place_service_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType unity_place_service_impl_type_id;
		unity_place_service_impl_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceServiceImpl", &g_define_type_info, 0);
		g_type_add_interface_static (unity_place_service_impl_type_id, UNITY_PLACE_TYPE_SERVICE, &unity_place_service_info);
		g_once_init_leave (&unity_place_service_impl_type_id__volatile, unity_place_service_impl_type_id);
	}
	return unity_place_service_impl_type_id__volatile;
}


static void unity_place_service_impl_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceServiceImpl * self;
	self = UNITY_PLACE_SERVICE_IMPL (object);
	switch (property_id) {
		case UNITY_PLACE_SERVICE_IMPL_DBUS_PATH:
		g_value_set_string (value, unity_place_service_impl_get_dbus_path (self));
		break;
		case UNITY_PLACE_SERVICE_IMPL_EXPORTED:
		g_value_set_boolean (value, unity_place_service_impl_get_exported (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_service_impl_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceServiceImpl * self;
	self = UNITY_PLACE_SERVICE_IMPL (object);
	switch (property_id) {
		case UNITY_PLACE_SERVICE_IMPL_DBUS_PATH:
		unity_place_service_impl_set_dbus_path (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


#line 609 "unity-place.vala"
UnityPlaceEntryServiceImpl* unity_place_entry_service_impl_construct (GType object_type, UnityPlaceEntryInfo* entry_info) {
#line 4789 "unity-place.c"
	UnityPlaceEntryServiceImpl * self;
#line 609 "unity-place.vala"
	g_return_val_if_fail (entry_info != NULL, NULL);
#line 611 "unity-place.vala"
	self = (UnityPlaceEntryServiceImpl*) g_object_new (object_type, "entry-info", entry_info, NULL);
#line 4795 "unity-place.c"
	return self;
}


#line 609 "unity-place.vala"
UnityPlaceEntryServiceImpl* unity_place_entry_service_impl_new (UnityPlaceEntryInfo* entry_info) {
#line 609 "unity-place.vala"
	return unity_place_entry_service_impl_construct (UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, entry_info);
#line 4804 "unity-place.c"
}


#line 618 "unity-place.vala"
static guint unity_place_entry_service_impl_real_set_global_search (UnityPlaceEntryService* base, const char* search, GHashTable* hints, GError** error) {
#line 4810 "unity-place.c"
	UnityPlaceEntryServiceImpl * self;
	guint result = 0U;
	void* _tmp0_ = NULL;
	self = (UnityPlaceEntryServiceImpl*) base;
#line 618 "unity-place.vala"
	g_return_val_if_fail (search != NULL, 0U);
#line 618 "unity-place.vala"
	g_return_val_if_fail (hints != NULL, 0U);
#line 621 "unity-place.vala"
	if (unity_place_entry_info_get_global_search_handler (self->priv->_entry_info, &_tmp0_) != NULL) {
#line 4821 "unity-place.c"
		UnityPlaceSearch* _tmp2_;
		void* _tmp1_ = NULL;
		guint _tmp3_;
		result = (_tmp3_ = unity_place_entry_info_get_global_search_handler (self->priv->_entry_info, &_tmp1_) (_tmp2_ = g_object_ref_sink (unity_place_search_new (search, hints)), _tmp1_), _g_object_unref0 (_tmp2_), _tmp3_);
#line 622 "unity-place.vala"
		return result;
#line 4828 "unity-place.c"
	} else {
#line 625 "unity-place.vala"
		g_warning ("unity-place.vala:625: No global search handler installed for %s", unity_place_entry_info_get_dbus_path (self->priv->_entry_info));
#line 4832 "unity-place.c"
		result = (guint) 0;
#line 627 "unity-place.vala"
		return result;
#line 4836 "unity-place.c"
	}
}


#line 631 "unity-place.vala"
static guint unity_place_entry_service_impl_real_set_search (UnityPlaceEntryService* base, const char* search, GHashTable* hints, GError** error) {
#line 4843 "unity-place.c"
	UnityPlaceEntryServiceImpl * self;
	guint result = 0U;
	void* _tmp0_ = NULL;
	self = (UnityPlaceEntryServiceImpl*) base;
#line 631 "unity-place.vala"
	g_return_val_if_fail (search != NULL, 0U);
#line 631 "unity-place.vala"
	g_return_val_if_fail (hints != NULL, 0U);
#line 634 "unity-place.vala"
	if (unity_place_entry_info_get_search_handler (self->priv->_entry_info, &_tmp0_) != NULL) {
#line 4854 "unity-place.c"
		UnityPlaceSearch* _tmp2_;
		void* _tmp1_ = NULL;
		guint _tmp3_;
		result = (_tmp3_ = unity_place_entry_info_get_search_handler (self->priv->_entry_info, &_tmp1_) (_tmp2_ = g_object_ref_sink (unity_place_search_new (search, hints)), _tmp1_), _g_object_unref0 (_tmp2_), _tmp3_);
#line 635 "unity-place.vala"
		return result;
#line 4861 "unity-place.c"
	} else {
#line 638 "unity-place.vala"
		g_warning ("unity-place.vala:638: No search handler installed for %s", unity_place_entry_info_get_dbus_path (self->priv->_entry_info));
#line 4865 "unity-place.c"
		result = (guint) 0;
#line 640 "unity-place.vala"
		return result;
#line 4869 "unity-place.c"
	}
}


#line 644 "unity-place.vala"
static void unity_place_entry_service_impl_real_set_active (UnityPlaceEntryService* base, gboolean is_active, GError** error) {
#line 4876 "unity-place.c"
	UnityPlaceEntryServiceImpl * self;
	self = (UnityPlaceEntryServiceImpl*) base;
#line 646 "unity-place.vala"
	unity_place_entry_info_set_active (self->priv->_entry_info, is_active);
#line 4881 "unity-place.c"
}


#line 649 "unity-place.vala"
static void unity_place_entry_service_impl_real_set_active_section (UnityPlaceEntryService* base, guint section_id, GError** error) {
#line 4887 "unity-place.c"
	UnityPlaceEntryServiceImpl * self;
	self = (UnityPlaceEntryServiceImpl*) base;
#line 651 "unity-place.vala"
	unity_place_entry_info_set_active_section (self->priv->_entry_info, section_id);
#line 4892 "unity-place.c"
}


#line 658 "unity-place.vala"
void unity_place_entry_service_impl_export (UnityPlaceEntryServiceImpl* self, GError** error) {
#line 4898 "unity-place.c"
	GError * _inner_error_;
	DBusGConnection* conn;
#line 658 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 4903 "unity-place.c"
	_inner_error_ = NULL;
#line 660 "unity-place.vala"
	conn = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
#line 4907 "unity-place.c"
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DBUS_GERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
#line 661 "unity-place.vala"
	_vala_dbus_register_object (dbus_g_connection_get_connection (conn), unity_place_entry_info_get_dbus_path (self->priv->_entry_info), (GObject*) self);
#line 663 "unity-place.vala"
	self->priv->_exported = TRUE;
#line 664 "unity-place.vala"
	g_object_notify ((GObject*) self, "exported");
#line 4924 "unity-place.c"
	_dbus_g_connection_unref0 (conn);
}


#line 667 "unity-place.vala"
void unity_place_entry_service_impl_unexport (UnityPlaceEntryServiceImpl* self, GError** error) {
#line 667 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 673 "unity-place.vala"
	self->priv->_exported = FALSE;
#line 674 "unity-place.vala"
	g_object_notify ((GObject*) self, "exported");
#line 4937 "unity-place.c"
}


UnityPlaceEntryInfo* unity_place_entry_service_impl_get_entry_info (UnityPlaceEntryServiceImpl* self) {
	UnityPlaceEntryInfo* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_entry_info;
#line 597 "unity-place.vala"
	return result;
#line 4947 "unity-place.c"
}


static void unity_place_entry_service_impl_set_entry_info (UnityPlaceEntryServiceImpl* self, UnityPlaceEntryInfo* value) {
	UnityPlaceEntryInfo* _tmp0_;
	g_return_if_fail (self != NULL);
#line 598 "unity-place.vala"
	self->priv->_entry_info = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_entry_info), _tmp0_);
#line 4956 "unity-place.c"
	g_object_notify ((GObject *) self, "entry-info");
}


gboolean unity_place_entry_service_impl_get_exported (UnityPlaceEntryServiceImpl* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_exported;
#line 602 "unity-place.vala"
	return result;
#line 4967 "unity-place.c"
}


void _unity_place_entry_service_impl_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_unity_place_entry_service_impl_introspect (UnityPlaceEntryServiceImpl* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.canonical.Unity.PlaceEntry\">\n  <method name=\"SetGlobalSearch\">\n    <arg name=\"search\" type=\"s\" direction=\"in\"/>\n    <arg name=\"hints\" type=\"a{ss}\" direction=\"in\"/>\n    <arg name=\"result\" type=\"u\" direction=\"out\"/>\n  </method>\n  <method name=\"SetSearch\">\n    <arg name=\"search\" type=\"s\" direction=\"in\"/>\n    <arg name=\"hints\" type=\"a{ss}\" direction=\"in\"/>\n    <arg name=\"result\" type=\"u\" direction=\"out\"/>\n  </method>\n  <method name=\"SetActive\">\n    <arg name=\"is_active\" type=\"b\" direction=\"in\"/>\n  </method>\n  <method name=\"SetActiveSection\">\n    <arg name=\"section_id\" type=\"u\" direction=\"in\"/>\n  </method>\n  <signal name=\"RendererInfoChanged\">\n    <arg name=\"renderer_info\" type=\"(sssa{ss})\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult unity_place_entry_service_impl_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_unity_place_entry_service_impl_introspect (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else if (unity_place_entry_service_dbus_message (connection, message, object) == DBUS_HANDLER_RESULT_HANDLED) {
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


void unity_place_entry_service_impl_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_unity_place_entry_service_impl_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	unity_place_entry_service_dbus_register_object (connection, path, object);
}


static void unity_place_entry_service_impl_class_init (UnityPlaceEntryServiceImplClass * klass) {
	unity_place_entry_service_impl_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceEntryServiceImplPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_entry_service_impl_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_entry_service_impl_set_property;
	G_OBJECT_CLASS (klass)->finalize = unity_place_entry_service_impl_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_SERVICE_IMPL_ENTRY_INFO, g_param_spec_object ("entry-info", "entry-info", "entry-info", UNITY_PLACE_TYPE_ENTRY_INFO, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_ENTRY_SERVICE_IMPL_EXPORTED, g_param_spec_boolean ("exported", "exported", "exported", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_type_set_qdata (UNITY_PLACE_TYPE_ENTRY_SERVICE_IMPL, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_unity_place_entry_service_impl_dbus_vtable));
}


static void unity_place_entry_service_impl_unity_place_entry_service_interface_init (UnityPlaceEntryServiceIface * iface) {
	unity_place_entry_service_impl_unity_place_entry_service_parent_iface = g_type_interface_peek_parent (iface);
	iface->set_global_search = unity_place_entry_service_impl_real_set_global_search;
	iface->set_search = unity_place_entry_service_impl_real_set_search;
	iface->set_active = unity_place_entry_service_impl_real_set_active;
	iface->set_active_section = unity_place_entry_service_impl_real_set_active_section;
}


static void unity_place_entry_service_impl_instance_init (UnityPlaceEntryServiceImpl * self) {
	self->priv = UNITY_PLACE_ENTRY_SERVICE_IMPL_GET_PRIVATE (self);
	self->priv->_exported = FALSE;
}


static void unity_place_entry_service_impl_finalize (GObject* obj) {
	UnityPlaceEntryServiceImpl * self;
	self = UNITY_PLACE_ENTRY_SERVICE_IMPL (obj);
	_g_object_unref0 (self->priv->_entry_info);
	G_OBJECT_CLASS (unity_place_entry_service_impl_parent_class)->finalize (obj);
}


GType unity_place_entry_service_impl_get_type (void) {
	static volatile gsize unity_place_entry_service_impl_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_entry_service_impl_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceEntryServiceImplClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_entry_service_impl_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceEntryServiceImpl), 0, (GInstanceInitFunc) unity_place_entry_service_impl_instance_init, NULL };
		static const GInterfaceInfo unity_place_entry_service_info = { (GInterfaceInitFunc) unity_place_entry_service_impl_unity_place_entry_service_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType unity_place_entry_service_impl_type_id;
		unity_place_entry_service_impl_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceEntryServiceImpl", &g_define_type_info, 0);
		g_type_add_interface_static (unity_place_entry_service_impl_type_id, UNITY_PLACE_TYPE_ENTRY_SERVICE, &unity_place_entry_service_info);
		g_once_init_leave (&unity_place_entry_service_impl_type_id__volatile, unity_place_entry_service_impl_type_id);
	}
	return unity_place_entry_service_impl_type_id__volatile;
}


static void unity_place_entry_service_impl_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceEntryServiceImpl * self;
	self = UNITY_PLACE_ENTRY_SERVICE_IMPL (object);
	switch (property_id) {
		case UNITY_PLACE_ENTRY_SERVICE_IMPL_ENTRY_INFO:
		g_value_set_object (value, unity_place_entry_service_impl_get_entry_info (self));
		break;
		case UNITY_PLACE_ENTRY_SERVICE_IMPL_EXPORTED:
		g_value_set_boolean (value, unity_place_entry_service_impl_get_exported (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_entry_service_impl_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceEntryServiceImpl * self;
	self = UNITY_PLACE_ENTRY_SERVICE_IMPL (object);
	switch (property_id) {
		case UNITY_PLACE_ENTRY_SERVICE_IMPL_ENTRY_INFO:
		unity_place_entry_service_impl_set_entry_info (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


#line 711 "unity-place.vala"
UnityPlaceController* unity_place_controller_construct (GType object_type, const char* dbus_path) {
#line 5111 "unity-place.c"
	UnityPlaceController * self;
#line 711 "unity-place.vala"
	g_return_val_if_fail (dbus_path != NULL, NULL);
#line 713 "unity-place.vala"
	self = (UnityPlaceController*) g_object_new (object_type, "dbus-path", dbus_path, NULL);
#line 5117 "unity-place.c"
	return self;
}


#line 711 "unity-place.vala"
UnityPlaceController* unity_place_controller_new (const char* dbus_path) {
#line 711 "unity-place.vala"
	return unity_place_controller_construct (UNITY_PLACE_TYPE_CONTROLLER, dbus_path);
#line 5126 "unity-place.c"
}


#line 720 "unity-place.vala"
void unity_place_controller_add_entry (UnityPlaceController* self, UnityPlaceEntryInfo* entry) {
#line 720 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 720 "unity-place.vala"
	g_return_if_fail (entry != NULL);
#line 722 "unity-place.vala"
	unity_place_service_impl_add_entry (self->priv->service, entry);
#line 5138 "unity-place.c"
}


#line 725 "unity-place.vala"
UnityPlaceEntryInfo* unity_place_controller_get_entry (UnityPlaceController* self, const char* dbus_path) {
#line 5144 "unity-place.c"
	UnityPlaceEntryInfo* result = NULL;
#line 725 "unity-place.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 725 "unity-place.vala"
	g_return_val_if_fail (dbus_path != NULL, NULL);
#line 5150 "unity-place.c"
	result = unity_place_service_impl_get_entry (self->priv->service, dbus_path);
#line 727 "unity-place.vala"
	return result;
#line 5154 "unity-place.c"
}


#line 730 "unity-place.vala"
void unity_place_controller_remove_entry (UnityPlaceController* self, const char* dbus_path) {
#line 730 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 730 "unity-place.vala"
	g_return_if_fail (dbus_path != NULL);
#line 732 "unity-place.vala"
	unity_place_service_impl_remove_entry (self->priv->service, dbus_path);
#line 5166 "unity-place.c"
}


#line 735 "unity-place.vala"
guint unity_place_controller_num_entries (UnityPlaceController* self) {
#line 5172 "unity-place.c"
	guint result = 0U;
#line 735 "unity-place.vala"
	g_return_val_if_fail (self != NULL, 0U);
#line 5176 "unity-place.c"
	result = unity_place_service_impl_num_entries (self->priv->service);
#line 737 "unity-place.vala"
	return result;
#line 5180 "unity-place.c"
}


#line 740 "unity-place.vala"
char** unity_place_controller_get_entry_paths (UnityPlaceController* self, int* result_length1) {
#line 5186 "unity-place.c"
	char** result = NULL;
	gint _tmp0_;
	char** _tmp1_;
#line 740 "unity-place.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 5192 "unity-place.c"
	result = (_tmp1_ = unity_place_service_impl_get_entry_paths (self->priv->service, &_tmp0_), *result_length1 = _tmp0_, _tmp1_);
#line 742 "unity-place.vala"
	return result;
#line 5196 "unity-place.c"
}


#line 745 "unity-place.vala"
UnityPlaceEntryInfo** unity_place_controller_get_entries (UnityPlaceController* self, int* result_length1) {
#line 5202 "unity-place.c"
	UnityPlaceEntryInfo** result = NULL;
	guint len;
	UnityPlaceEntryInfo** _tmp0_;
	gint __result__size_;
	gint _result__length1;
	UnityPlaceEntryInfo** _result_;
	char** _tmp2_;
	gint _entry_paths_size_;
	gint entry_paths_length1;
	gint _tmp1_;
	char** entry_paths;
	gint i;
	UnityPlaceEntryInfo** _tmp5_;
#line 745 "unity-place.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 747 "unity-place.vala"
	len = unity_place_controller_num_entries (self);
#line 5220 "unity-place.c"
	_result_ = (_tmp0_ = g_new0 (UnityPlaceEntryInfo*, len + 1), _result__length1 = len, __result__size_ = _result__length1, _tmp0_);
	entry_paths = (_tmp2_ = unity_place_controller_get_entry_paths (self, &_tmp1_), entry_paths_length1 = _tmp1_, _entry_paths_size_ = entry_paths_length1, _tmp2_);
#line 751 "unity-place.vala"
	i = 0;
#line 5225 "unity-place.c"
	{
		gboolean _tmp3_;
#line 752 "unity-place.vala"
		i = 0;
#line 752 "unity-place.vala"
		_tmp3_ = TRUE;
#line 752 "unity-place.vala"
		while (TRUE) {
#line 5234 "unity-place.c"
			UnityPlaceEntryInfo* _tmp4_;
#line 752 "unity-place.vala"
			if (!_tmp3_) {
#line 752 "unity-place.vala"
				i++;
#line 5240 "unity-place.c"
			}
#line 752 "unity-place.vala"
			_tmp3_ = FALSE;
#line 752 "unity-place.vala"
			if (!(i < len)) {
#line 752 "unity-place.vala"
				break;
#line 5248 "unity-place.c"
			}
#line 754 "unity-place.vala"
			_result_[i] = (_tmp4_ = unity_place_controller_get_entry (self, entry_paths[i]), _g_object_unref0 (_result_[i]), _tmp4_);
#line 5252 "unity-place.c"
		}
	}
	result = (_tmp5_ = _result_, *result_length1 = _result__length1, _tmp5_);
	entry_paths = (_vala_array_free (entry_paths, entry_paths_length1, (GDestroyNotify) g_free), NULL);
#line 757 "unity-place.vala"
	return result;
#line 5259 "unity-place.c"
	_result_ = (_vala_array_free (_result_, _result__length1, (GDestroyNotify) g_object_unref), NULL);
	entry_paths = (_vala_array_free (entry_paths, entry_paths_length1, (GDestroyNotify) g_free), NULL);
}


#line 760 "unity-place.vala"
void unity_place_controller_export (UnityPlaceController* self, GError** error) {
#line 5267 "unity-place.c"
	GError * _inner_error_;
#line 760 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 5271 "unity-place.c"
	_inner_error_ = NULL;
#line 762 "unity-place.vala"
	unity_place_service_impl_export (self->priv->service, &_inner_error_);
#line 5275 "unity-place.c"
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DBUS_GERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
#line 763 "unity-place.vala"
	self->priv->_exported = TRUE;
#line 764 "unity-place.vala"
	g_object_notify ((GObject*) self, "exported");
#line 5290 "unity-place.c"
}


#line 767 "unity-place.vala"
void unity_place_controller_unexport (UnityPlaceController* self, GError** error) {
#line 5296 "unity-place.c"
	GError * _inner_error_;
#line 767 "unity-place.vala"
	g_return_if_fail (self != NULL);
#line 5300 "unity-place.c"
	_inner_error_ = NULL;
#line 769 "unity-place.vala"
	unity_place_service_impl_unexport (self->priv->service, &_inner_error_);
#line 5304 "unity-place.c"
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DBUS_GERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
#line 770 "unity-place.vala"
	self->priv->_exported = FALSE;
#line 771 "unity-place.vala"
	g_object_notify ((GObject*) self, "exported");
#line 5319 "unity-place.c"
}


const char* unity_place_controller_get_dbus_path (UnityPlaceController* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_dbus_path;
#line 695 "unity-place.vala"
	return result;
#line 5329 "unity-place.c"
}


static void unity_place_controller_set_dbus_path (UnityPlaceController* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
#line 696 "unity-place.vala"
	self->priv->_dbus_path = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_dbus_path), _tmp0_);
#line 5338 "unity-place.c"
	g_object_notify ((GObject *) self, "dbus-path");
}


gboolean unity_place_controller_get_exported (UnityPlaceController* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_exported;
#line 700 "unity-place.vala"
	return result;
#line 5349 "unity-place.c"
}


static GObject * unity_place_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityPlaceController * self;
	parent_class = G_OBJECT_CLASS (unity_place_controller_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_PLACE_CONTROLLER (obj);
	{
		UnityPlaceServiceImpl* _tmp244_;
#line 708 "unity-place.vala"
		self->priv->service = (_tmp244_ = unity_place_service_impl_new (self->priv->_dbus_path), _g_object_unref0 (self->priv->service), _tmp244_);
#line 5364 "unity-place.c"
	}
	return obj;
}


static void unity_place_controller_class_init (UnityPlaceControllerClass * klass) {
	unity_place_controller_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityPlaceControllerPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_place_controller_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_place_controller_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_place_controller_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_place_controller_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_CONTROLLER_DBUS_PATH, g_param_spec_string ("dbus-path", "dbus-path", "dbus-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_PLACE_CONTROLLER_EXPORTED, g_param_spec_boolean ("exported", "exported", "exported", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void unity_place_controller_instance_init (UnityPlaceController * self) {
	self->priv = UNITY_PLACE_CONTROLLER_GET_PRIVATE (self);
	self->priv->_exported = FALSE;
}


static void unity_place_controller_finalize (GObject* obj) {
	UnityPlaceController * self;
	self = UNITY_PLACE_CONTROLLER (obj);
	_g_object_unref0 (self->priv->service);
	_g_free0 (self->priv->_dbus_path);
	G_OBJECT_CLASS (unity_place_controller_parent_class)->finalize (obj);
}


GType unity_place_controller_get_type (void) {
	static volatile gsize unity_place_controller_type_id__volatile = 0;
	if (g_once_init_enter (&unity_place_controller_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityPlaceControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_place_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityPlaceController), 0, (GInstanceInitFunc) unity_place_controller_instance_init, NULL };
		GType unity_place_controller_type_id;
		unity_place_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityPlaceController", &g_define_type_info, 0);
		g_once_init_leave (&unity_place_controller_type_id__volatile, unity_place_controller_type_id);
	}
	return unity_place_controller_type_id__volatile;
}


static void unity_place_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityPlaceController * self;
	self = UNITY_PLACE_CONTROLLER (object);
	switch (property_id) {
		case UNITY_PLACE_CONTROLLER_DBUS_PATH:
		g_value_set_string (value, unity_place_controller_get_dbus_path (self));
		break;
		case UNITY_PLACE_CONTROLLER_EXPORTED:
		g_value_set_boolean (value, unity_place_controller_get_exported (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_place_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityPlaceController * self;
	self = UNITY_PLACE_CONTROLLER (object);
	switch (property_id) {
		case UNITY_PLACE_CONTROLLER_DBUS_PATH:
		unity_place_controller_set_dbus_path (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}



static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__BOXED callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), data2);
}



