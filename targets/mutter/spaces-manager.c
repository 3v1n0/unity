/* spaces-manager.c generated by valac, the Vala compiler
 * generated from spaces-manager.vala, do not modify */

/*
 * Copyright (C) 2009 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Jason Smith <jason.smith@canonical.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <unity-private.h>
#include <clutter/clutter.h>
#include <mutter-plugins.h>
#include <unity.h>
#include <float.h>
#include <math.h>


#define UNITY_TYPE_SPACES_BUTTON_CONTROLLER (unity_spaces_button_controller_get_type ())
#define UNITY_SPACES_BUTTON_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_SPACES_BUTTON_CONTROLLER, UnitySpacesButtonController))
#define UNITY_SPACES_BUTTON_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_SPACES_BUTTON_CONTROLLER, UnitySpacesButtonControllerClass))
#define UNITY_IS_SPACES_BUTTON_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_SPACES_BUTTON_CONTROLLER))
#define UNITY_IS_SPACES_BUTTON_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_SPACES_BUTTON_CONTROLLER))
#define UNITY_SPACES_BUTTON_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_SPACES_BUTTON_CONTROLLER, UnitySpacesButtonControllerClass))

typedef struct _UnitySpacesButtonController UnitySpacesButtonController;
typedef struct _UnitySpacesButtonControllerClass UnitySpacesButtonControllerClass;
typedef struct _UnitySpacesButtonControllerPrivate UnitySpacesButtonControllerPrivate;

#define UNITY_TYPE_SPACES_MANAGER (unity_spaces_manager_get_type ())
#define UNITY_SPACES_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_SPACES_MANAGER, UnitySpacesManager))
#define UNITY_SPACES_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_SPACES_MANAGER, UnitySpacesManagerClass))
#define UNITY_IS_SPACES_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_SPACES_MANAGER))
#define UNITY_IS_SPACES_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_SPACES_MANAGER))
#define UNITY_SPACES_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_SPACES_MANAGER, UnitySpacesManagerClass))

typedef struct _UnitySpacesManager UnitySpacesManager;
typedef struct _UnitySpacesManagerClass UnitySpacesManagerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _UnitySpacesManagerPrivate UnitySpacesManagerPrivate;

#define UNITY_TYPE_PLUGIN (unity_plugin_get_type ())
#define UNITY_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_PLUGIN, UnityPlugin))
#define UNITY_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_PLUGIN, UnityPluginClass))
#define UNITY_IS_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_PLUGIN))
#define UNITY_IS_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_PLUGIN))
#define UNITY_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_PLUGIN, UnityPluginClass))

typedef struct _UnityPlugin UnityPlugin;
typedef struct _UnityPluginClass UnityPluginClass;
#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))
typedef struct _Block2Data Block2Data;

#define UNITY_TYPE_EXPOSE_CLONE (unity_expose_clone_get_type ())
#define UNITY_EXPOSE_CLONE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_EXPOSE_CLONE, UnityExposeClone))
#define UNITY_EXPOSE_CLONE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_EXPOSE_CLONE, UnityExposeCloneClass))
#define UNITY_IS_EXPOSE_CLONE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_EXPOSE_CLONE))
#define UNITY_IS_EXPOSE_CLONE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_EXPOSE_CLONE))
#define UNITY_EXPOSE_CLONE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_EXPOSE_CLONE, UnityExposeCloneClass))

typedef struct _UnityExposeClone UnityExposeClone;
typedef struct _UnityExposeCloneClass UnityExposeCloneClass;

#define UNITY_TYPE_EXPOSE_MANAGER (unity_expose_manager_get_type ())
#define UNITY_EXPOSE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_EXPOSE_MANAGER, UnityExposeManager))
#define UNITY_EXPOSE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_EXPOSE_MANAGER, UnityExposeManagerClass))
#define UNITY_IS_EXPOSE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_EXPOSE_MANAGER))
#define UNITY_IS_EXPOSE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_EXPOSE_MANAGER))
#define UNITY_EXPOSE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_EXPOSE_MANAGER, UnityExposeManagerClass))

typedef struct _UnityExposeManager UnityExposeManager;
typedef struct _UnityExposeManagerClass UnityExposeManagerClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _Block3Data Block3Data;

struct _UnitySpacesButtonController {
	UnityLauncherScrollerChildController parent_instance;
	UnitySpacesButtonControllerPrivate * priv;
};

struct _UnitySpacesButtonControllerClass {
	UnityLauncherScrollerChildControllerClass parent_class;
};

struct _UnitySpacesButtonControllerPrivate {
	UnitySpacesManager* _parent;
};

struct _UnitySpacesManager {
	GObject parent_instance;
	UnitySpacesManagerPrivate * priv;
};

struct _UnitySpacesManagerClass {
	GObjectClass parent_class;
};

struct _UnitySpacesManagerPrivate {
	ClutterActor* background;
	GList* clones;
	UnityPlugin* plugin;
	MetaScreen* screen;
	UnityLauncherScrollerChild* _button;
	UnitySpacesButtonController* controller;
	guint _top_padding;
	guint _right_padding;
	guint _bottom_padding;
	guint _left_padding;
	guint _spacing;
	gboolean _showing;
};

struct _Block2Data {
	int _ref_count_;
	UnitySpacesManager * self;
	MetaWorkspace* cpy;
};

struct _Block3Data {
	int _ref_count_;
	UnitySpacesManager * self;
	ClutterActor* clone;
};


static gpointer unity_spaces_button_controller_parent_class = NULL;
static gpointer unity_spaces_manager_parent_class = NULL;

GType unity_spaces_button_controller_get_type (void) G_GNUC_CONST;
GType unity_spaces_manager_get_type (void) G_GNUC_CONST;
#define UNITY_SPACES_BUTTON_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_SPACES_BUTTON_CONTROLLER, UnitySpacesButtonControllerPrivate))
enum  {
	UNITY_SPACES_BUTTON_CONTROLLER_DUMMY_PROPERTY
};
static void unity_spaces_button_controller_set_parent (UnitySpacesButtonController* self, UnitySpacesManager* value);
UnitySpacesButtonController* unity_spaces_button_controller_new (UnitySpacesManager* _parent, UnityLauncherScrollerChild* _child);
UnitySpacesButtonController* unity_spaces_button_controller_construct (GType object_type, UnitySpacesManager* _parent, UnityLauncherScrollerChild* _child);
static UnitySpacesManager* unity_spaces_button_controller_get_parent (UnitySpacesButtonController* self);
void unity_spaces_manager_show_spaces_picker (UnitySpacesManager* self);
static void unity_spaces_button_controller_real_activate (UnityLauncherScrollerChildController* base);
static GObject * unity_spaces_button_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_spaces_button_controller_finalize (GObject* obj);
static void unity_spaces_button_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_spaces_button_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType unity_plugin_get_type (void) G_GNUC_CONST;
#define UNITY_SPACES_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_SPACES_MANAGER, UnitySpacesManagerPrivate))
enum  {
	UNITY_SPACES_MANAGER_DUMMY_PROPERTY,
	UNITY_SPACES_MANAGER_BUTTON,
	UNITY_SPACES_MANAGER_TOP_PADDING,
	UNITY_SPACES_MANAGER_RIGHT_PADDING,
	UNITY_SPACES_MANAGER_BOTTOM_PADDING,
	UNITY_SPACES_MANAGER_LEFT_PADDING,
	UNITY_SPACES_MANAGER_SPACING,
	UNITY_SPACES_MANAGER_SHOWING
};
static void _g_list_free_g_object_unref (GList* self);
static void unity_spaces_manager_workspace_switched (UnitySpacesManager* self, UnityPlugin* plugin, GList* windows, gint from, gint to, gint direction);
static void _unity_spaces_manager_workspace_switched_unity_plugin_workspace_switch_event (UnityPlugin* _sender, UnityPlugin* plugin, GList* windows, gint from, gint to, gint direction, gpointer self);
UnitySpacesManager* unity_spaces_manager_new (UnityPlugin* plugin);
UnitySpacesManager* unity_spaces_manager_construct (GType object_type, UnityPlugin* plugin);
MutterPlugin* unity_plugin_get_plugin (UnityPlugin* self);
void unity_spaces_manager_set_top_padding (UnitySpacesManager* self, guint value);
void unity_spaces_manager_set_right_padding (UnitySpacesManager* self, guint value);
void unity_spaces_manager_set_left_padding (UnitySpacesManager* self, guint value);
void unity_spaces_manager_set_bottom_padding (UnitySpacesManager* self, guint value);
void unity_spaces_manager_set_padding (UnitySpacesManager* self, guint top, guint right, guint left, guint bottom);
gboolean unity_spaces_manager_get_showing (UnitySpacesManager* self);
static void unity_spaces_manager_set_showing (UnitySpacesManager* self, gboolean value);
static ClutterActor* unity_spaces_manager_workspace_clone (UnitySpacesManager* self, MetaWorkspace* workspace);
static void unity_spaces_manager_select_workspace (UnitySpacesManager* self, MetaWorkspace* workspace);
static gboolean _lambda3_ (Block2Data* _data2_);
static gboolean __lambda3__clutter_actor_button_release_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (Block2Data* _data2_);
static void unity_spaces_manager_layout_workspaces (UnitySpacesManager* self, GList* clones, MetaScreen* screen);
static void unity_spaces_manager_unlayout_workspaces (UnitySpacesManager* self, GList* clones, MetaScreen* screen, gint focus);
UnityExposeClone* unity_expose_clone_new (ClutterActor* source);
UnityExposeClone* unity_expose_clone_construct (GType object_type, ClutterActor* source);
GType unity_expose_clone_get_type (void) G_GNUC_CONST;
void unity_expose_clone_set_fade_on_close (UnityExposeClone* self, gboolean value);
GType unity_expose_manager_get_type (void) G_GNUC_CONST;
UnityExposeManager* unity_plugin_get_expose_manager (UnityPlugin* self);
void unity_expose_manager_position_windows_on_grid (UnityExposeManager* self, GList* _windows, gint top_buffer, gint left_buffer, gint right_buffer, gint bottom_buffer);
void unity_expose_clone_restore_window_position (UnityExposeClone* self, gint active_workspace);
static void _lambda4_ (Block3Data* _data3_);
static void __lambda4__clutter_animation_completed (ClutterAnimation* _sender, gpointer self);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (Block3Data* _data3_);
guint unity_spaces_manager_get_left_padding (UnitySpacesManager* self);
guint unity_spaces_manager_get_right_padding (UnitySpacesManager* self);
guint unity_spaces_manager_get_spacing (UnitySpacesManager* self);
guint unity_spaces_manager_get_top_padding (UnitySpacesManager* self);
UnityLauncherScrollerChild* unity_spaces_manager_get_button (UnitySpacesManager* self);
guint unity_spaces_manager_get_bottom_padding (UnitySpacesManager* self);
void unity_spaces_manager_set_spacing (UnitySpacesManager* self, guint value);
static GObject * unity_spaces_manager_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_spaces_manager_finalize (GObject* obj);
static void unity_spaces_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_spaces_manager_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);



UnitySpacesButtonController* unity_spaces_button_controller_construct (GType object_type, UnitySpacesManager* _parent, UnityLauncherScrollerChild* _child) {
	UnitySpacesButtonController * self;
	g_return_val_if_fail (_parent != NULL, NULL);
	g_return_val_if_fail (_child != NULL, NULL);
	self = (UnitySpacesButtonController*) g_object_new (object_type, "child", _child, NULL);
	unity_spaces_button_controller_set_parent (self, _parent);
	unity_launcher_scroller_child_controller_set_name ((UnityLauncherScrollerChildController*) self, "Workspace Overview");
	unity_launcher_scroller_child_controller_load_icon_from_icon_name ((UnityLauncherScrollerChildController*) self, "workspace-switcher");
	return self;
}


UnitySpacesButtonController* unity_spaces_button_controller_new (UnitySpacesManager* _parent, UnityLauncherScrollerChild* _child) {
	return unity_spaces_button_controller_construct (UNITY_TYPE_SPACES_BUTTON_CONTROLLER, _parent, _child);
}


static void unity_spaces_button_controller_real_activate (UnityLauncherScrollerChildController* base) {
	UnitySpacesButtonController * self;
	self = (UnitySpacesButtonController*) base;
	unity_spaces_manager_show_spaces_picker (self->priv->_parent);
}


static UnitySpacesManager* unity_spaces_button_controller_get_parent (UnitySpacesButtonController* self) {
	UnitySpacesManager* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_parent;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void unity_spaces_button_controller_set_parent (UnitySpacesButtonController* self, UnitySpacesManager* value) {
	UnitySpacesManager* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_parent = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_parent), _tmp0_);
}


static GObject * unity_spaces_button_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnitySpacesButtonController * self;
	parent_class = G_OBJECT_CLASS (unity_spaces_button_controller_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_SPACES_BUTTON_CONTROLLER (obj);
	{
	}
	return obj;
}


static void unity_spaces_button_controller_class_init (UnitySpacesButtonControllerClass * klass) {
	unity_spaces_button_controller_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnitySpacesButtonControllerPrivate));
	UNITY_LAUNCHER_SCROLLER_CHILD_CONTROLLER_CLASS (klass)->activate = unity_spaces_button_controller_real_activate;
	G_OBJECT_CLASS (klass)->get_property = unity_spaces_button_controller_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_spaces_button_controller_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_spaces_button_controller_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_spaces_button_controller_finalize;
}


static void unity_spaces_button_controller_instance_init (UnitySpacesButtonController * self) {
	self->priv = UNITY_SPACES_BUTTON_CONTROLLER_GET_PRIVATE (self);
}


static void unity_spaces_button_controller_finalize (GObject* obj) {
	UnitySpacesButtonController * self;
	self = UNITY_SPACES_BUTTON_CONTROLLER (obj);
	_g_object_unref0 (self->priv->_parent);
	G_OBJECT_CLASS (unity_spaces_button_controller_parent_class)->finalize (obj);
}


GType unity_spaces_button_controller_get_type (void) {
	static volatile gsize unity_spaces_button_controller_type_id__volatile = 0;
	if (g_once_init_enter (&unity_spaces_button_controller_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnitySpacesButtonControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_spaces_button_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnitySpacesButtonController), 0, (GInstanceInitFunc) unity_spaces_button_controller_instance_init, NULL };
		GType unity_spaces_button_controller_type_id;
		unity_spaces_button_controller_type_id = g_type_register_static (UNITY_LAUNCHER_TYPE_SCROLLER_CHILD_CONTROLLER, "UnitySpacesButtonController", &g_define_type_info, 0);
		g_once_init_leave (&unity_spaces_button_controller_type_id__volatile, unity_spaces_button_controller_type_id);
	}
	return unity_spaces_button_controller_type_id__volatile;
}


static void unity_spaces_button_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnitySpacesButtonController * self;
	self = UNITY_SPACES_BUTTON_CONTROLLER (object);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_spaces_button_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnitySpacesButtonController * self;
	self = UNITY_SPACES_BUTTON_CONTROLLER (object);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _g_list_free_g_object_unref (GList* self) {
	g_list_foreach (self, (GFunc) g_object_unref, NULL);
	g_list_free (self);
}


static void _unity_spaces_manager_workspace_switched_unity_plugin_workspace_switch_event (UnityPlugin* _sender, UnityPlugin* plugin, GList* windows, gint from, gint to, gint direction, gpointer self) {
	unity_spaces_manager_workspace_switched (self, plugin, windows, from, to, direction);
}


UnitySpacesManager* unity_spaces_manager_construct (GType object_type, UnityPlugin* plugin) {
	UnitySpacesManager * self;
	UnityPlugin* _tmp0_;
	g_return_val_if_fail (plugin != NULL, NULL);
	self = g_object_newv (object_type, 0, NULL);
	self->priv->plugin = (_tmp0_ = _g_object_ref0 (plugin), _g_object_unref0 (self->priv->plugin), _tmp0_);
	g_signal_connect_object (self->priv->plugin, "workspace-switch-event", (GCallback) _unity_spaces_manager_workspace_switched_unity_plugin_workspace_switch_event, self, 0);
	return self;
}


UnitySpacesManager* unity_spaces_manager_new (UnityPlugin* plugin) {
	return unity_spaces_manager_construct (UNITY_TYPE_SPACES_MANAGER, plugin);
}


static void unity_spaces_manager_workspace_switched (UnitySpacesManager* self, UnityPlugin* plugin, GList* windows, gint from, gint to, gint direction) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (plugin != NULL);
	mutter_plugin_effect_completed (unity_plugin_get_plugin (self->priv->plugin), (MutterWindow*) g_list_nth_data (windows, (guint) 0), (guint) MUTTER_PLUGIN_SWITCH_WORKSPACE);
}


void unity_spaces_manager_set_padding (UnitySpacesManager* self, guint top, guint right, guint left, guint bottom) {
	g_return_if_fail (self != NULL);
	unity_spaces_manager_set_top_padding (self, top);
	unity_spaces_manager_set_right_padding (self, right);
	unity_spaces_manager_set_left_padding (self, left);
	unity_spaces_manager_set_bottom_padding (self, bottom);
}


static gboolean _lambda3_ (Block2Data* _data2_) {
	UnitySpacesManager * self;
	gboolean result = FALSE;
	self = _data2_->self;
	unity_spaces_manager_select_workspace (self, _data2_->cpy);
	result = TRUE;
	return result;
}


static gboolean __lambda3__clutter_actor_button_release_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = _lambda3_ (self);
	return result;
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (Block2Data* _data2_) {
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_object_unref0 (_data2_->self);
		g_slice_free (Block2Data, _data2_);
	}
}


void unity_spaces_manager_show_spaces_picker (UnitySpacesManager* self) {
	ClutterActor* _tmp2_;
	ClutterColor _tmp1_;
	ClutterColor _tmp0_ = {0};
	MetaScreen* screen;
	GList* workspaces;
	ClutterActor* _tmp3_;
	ClutterContainer* window_group;
	MetaRectangle _tmp4_ = {0};
	MetaRectangle rect;
	GList* windows;
	g_return_if_fail (self != NULL);
	if (self->priv->_showing) {
		return;
	}
	unity_spaces_manager_set_showing (self, TRUE);
	unity_shell_add_fullscreen_request ((UnityShell*) self->priv->plugin, (GObject*) self);
	self->priv->background = (_tmp2_ = (ClutterActor*) g_object_ref_sink ((ClutterRectangle*) clutter_rectangle_new_with_color ((_tmp1_ = (_tmp0_.red = (guint8) 0, _tmp0_.green = (guint8) 0, _tmp0_.blue = (guint8) 0, _tmp0_.alpha = (guint8) 255, _tmp0_), &_tmp1_))), _g_object_unref0 (self->priv->background), _tmp2_);
	screen = mutter_plugin_get_screen (unity_plugin_get_plugin (self->priv->plugin));
	workspaces = meta_screen_get_workspaces (screen);
	window_group = (_tmp3_ = mutter_plugin_get_normal_window_group (unity_plugin_get_plugin (self->priv->plugin)), CLUTTER_IS_CONTAINER (_tmp3_) ? ((ClutterContainer*) _tmp3_) : NULL);
	rect = (_tmp4_.height = 0, _tmp4_.width = 0, _tmp4_.x = 0, _tmp4_.y = 0, _tmp4_);
	meta_screen_get_monitor_geometry (screen, 0, &rect);
	clutter_actor_set_size (self->priv->background, (float) rect.width, (float) rect.height);
	clutter_container_add_actor (window_group, self->priv->background);
	clutter_actor_raise_top (self->priv->background);
	{
		GList* workspace_collection;
		GList* workspace_it;
		workspace_collection = workspaces;
		for (workspace_it = workspace_collection; workspace_it != NULL; workspace_it = workspace_it->next) {
			MetaWorkspace* workspace;
			workspace = (MetaWorkspace*) workspace_it->data;
			{
				Block2Data* _data2_;
				ClutterActor* clone;
				_data2_ = g_slice_new0 (Block2Data);
				_data2_->_ref_count_ = 1;
				_data2_->self = g_object_ref (self);
				clone = unity_spaces_manager_workspace_clone (self, workspace);
				self->priv->clones = g_list_append (self->priv->clones, _g_object_ref0 (clone));
				clutter_container_add_actor (window_group, clone);
				clutter_actor_set_reactive (clone, TRUE);
				clutter_actor_raise_top (clone);
				clutter_actor_show (clone);
				_data2_->cpy = workspace;
				g_signal_connect_data (clone, "button-release-event", (GCallback) __lambda3__clutter_actor_button_release_event, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
				_g_object_unref0 (clone);
				block2_data_unref (_data2_);
			}
		}
	}
	unity_spaces_manager_layout_workspaces (self, self->priv->clones, screen);
	windows = mutter_plugin_get_windows (unity_plugin_get_plugin (self->priv->plugin));
	{
		GList* w_collection;
		GList* w_it;
		w_collection = windows;
		for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
			MutterWindow* w;
			w = _g_object_ref0 ((MutterWindow*) w_it->data);
			{
				MutterWindow* _tmp5_;
				clutter_actor_set_opacity ((_tmp5_ = w, CLUTTER_IS_ACTOR (_tmp5_) ? ((ClutterActor*) _tmp5_) : NULL), (guint8) 0);
				_g_object_unref0 (w);
			}
		}
	}
}


static void unity_spaces_manager_select_workspace (UnitySpacesManager* self, MetaWorkspace* workspace) {
	GList* _tmp0_;
	guint time_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (workspace != NULL);
	unity_spaces_manager_unlayout_workspaces (self, self->priv->clones, mutter_plugin_get_screen (unity_plugin_get_plugin (self->priv->plugin)), meta_workspace_index (workspace));
	self->priv->clones = (_tmp0_ = NULL, __g_list_free_g_object_unref0 (self->priv->clones), _tmp0_);
	time_ = (guint) meta_display_get_current_time (meta_screen_get_display (meta_workspace_get_screen (workspace)));
	meta_workspace_activate (workspace, (guint32) time_);
	unity_shell_remove_fullscreen_request ((UnityShell*) self->priv->plugin, (GObject*) self);
	unity_spaces_manager_set_showing (self, FALSE);
}


static ClutterActor* unity_spaces_manager_workspace_clone (UnitySpacesManager* self, MetaWorkspace* workspace) {
	ClutterActor* result = NULL;
	ClutterGroup* wsp;
	GList* windows;
	ClutterGroup* _tmp0_;
	GList* toplevel_windows;
	gint active_workspace;
	ClutterActor* last;
	ClutterActor* wspclone;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (workspace != NULL, NULL);
	wsp = NULL;
	windows = (GList*) g_list_copy (mutter_plugin_get_windows (unity_plugin_get_plugin (self->priv->plugin)));
	wsp = (_tmp0_ = g_object_ref_sink ((ClutterGroup*) clutter_group_new ()), _g_object_unref0 (wsp), _tmp0_);
	toplevel_windows = NULL;
	active_workspace = meta_screen_get_active_workspace_index (mutter_plugin_get_screen (unity_plugin_get_plugin (self->priv->plugin)));
	last = NULL;
	wspclone = NULL;
	{
		GList* window_collection;
		GList* window_it;
		window_collection = windows;
		for (window_it = window_collection; window_it != NULL; window_it = window_it->next) {
			MutterWindow* window;
			window = _g_object_ref0 ((MutterWindow*) window_it->data);
			{
				gboolean _tmp1_ = FALSE;
				gboolean _tmp2_ = FALSE;
				if (meta_window_is_on_all_workspaces (mutter_window_get_meta_window (window))) {
					_tmp2_ = TRUE;
				} else {
					_tmp2_ = mutter_window_get_window_type (window) == META_COMP_WINDOW_DESKTOP;
				}
				if (_tmp2_) {
					_tmp1_ = TRUE;
				} else {
					_tmp1_ = mutter_window_get_workspace (window) == meta_workspace_index (workspace);
				}
				if (_tmp1_) {
					UnityExposeClone* clone;
					if (mutter_window_get_window_type (window) == META_COMP_WINDOW_DOCK) {
						_g_object_unref0 (window);
						continue;
					}
					clone = g_object_ref_sink (unity_expose_clone_new ((ClutterActor*) window));
					unity_expose_clone_set_fade_on_close (clone, FALSE);
					clutter_container_add_actor ((ClutterContainer*) wsp, (ClutterActor*) clone);
					clutter_actor_set_size ((ClutterActor*) clone, clutter_actor_get_width ((ClutterActor*) window), clutter_actor_get_height ((ClutterActor*) window));
					clutter_actor_set_position ((ClutterActor*) clone, clutter_actor_get_x ((ClutterActor*) window), clutter_actor_get_y ((ClutterActor*) window));
					clutter_actor_show ((ClutterActor*) clone);
					if (mutter_window_get_window_type (window) == META_COMP_WINDOW_DESKTOP) {
						ClutterActor* _tmp3_;
						wspclone = (_tmp3_ = _g_object_ref0 ((ClutterActor*) clone), _g_object_unref0 (wspclone), _tmp3_);
						clutter_actor_lower_bottom ((ClutterActor*) clone);
					} else {
						ClutterActor* _tmp4_;
						last = (_tmp4_ = _g_object_ref0 ((ClutterActor*) clone), _g_object_unref0 (last), _tmp4_);
						toplevel_windows = g_list_prepend (toplevel_windows, _g_object_ref0 ((ClutterActor*) clone));
					}
					_g_object_unref0 (clone);
				}
				_g_object_unref0 (window);
			}
		}
	}
	if (last != NULL) {
		_tmp6_ = wspclone != NULL;
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		_tmp5_ = active_workspace != meta_workspace_index (workspace);
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		clutter_actor_raise (last, wspclone);
	}
	unity_expose_manager_position_windows_on_grid (unity_plugin_get_expose_manager (self->priv->plugin), toplevel_windows, 50, 50, 50, 50);
	result = (ClutterActor*) wsp;
	_g_object_unref0 (wspclone);
	_g_object_unref0 (last);
	__g_list_free_g_object_unref0 (toplevel_windows);
	_g_list_free0 (windows);
	return result;
}


static void _lambda4_ (Block3Data* _data3_) {
	UnitySpacesManager * self;
	GList* windows;
	self = _data3_->self;
	clutter_actor_destroy (_data3_->clone);
	if (self->priv->background != NULL) {
		ClutterActor* _tmp0_;
		clutter_actor_destroy (self->priv->background);
		self->priv->background = (_tmp0_ = NULL, _g_object_unref0 (self->priv->background), _tmp0_);
	}
	windows = mutter_plugin_get_windows (unity_plugin_get_plugin (self->priv->plugin));
	{
		GList* w_collection;
		GList* w_it;
		w_collection = windows;
		for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
			MutterWindow* w;
			w = _g_object_ref0 ((MutterWindow*) w_it->data);
			{
				MutterWindow* _tmp1_;
				clutter_actor_set_opacity ((_tmp1_ = w, CLUTTER_IS_ACTOR (_tmp1_) ? ((ClutterActor*) _tmp1_) : NULL), (guint8) 255);
				_g_object_unref0 (w);
			}
		}
	}
}


static void __lambda4__clutter_animation_completed (ClutterAnimation* _sender, gpointer self) {
	_lambda4_ (self);
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (Block3Data* _data3_) {
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		_g_object_unref0 (_data3_->self);
		_g_object_unref0 (_data3_->clone);
		g_slice_free (Block3Data, _data3_);
	}
}


static void unity_spaces_manager_unlayout_workspaces (UnitySpacesManager* self, GList* clones, MetaScreen* screen, gint focus) {
	guint length;
	gint width;
	gint height;
	MetaRectangle _tmp0_ = {0};
	MetaRectangle rect;
	g_return_if_fail (self != NULL);
	g_return_if_fail (screen != NULL);
	length = g_list_length (clones);
	width = (gint) ceil (sqrt ((double) length));
	height = (gint) floor (sqrt ((double) length));
	rect = (_tmp0_.height = 0, _tmp0_.width = 0, _tmp0_.x = 0, _tmp0_.y = 0, _tmp0_);
	meta_screen_get_monitor_geometry (screen, 0, &rect);
	{
		gint y;
		y = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					y++;
				}
				_tmp1_ = FALSE;
				if (!(y < height)) {
					break;
				}
				{
					gint x;
					x = 0;
					{
						gboolean _tmp2_;
						_tmp2_ = TRUE;
						while (TRUE) {
							Block3Data* _data3_;
							gint index;
							gint xoffset;
							gint yoffset;
							ClutterAnimation* anim;
							gint active_workspace;
							_data3_ = g_slice_new0 (Block3Data);
							_data3_->_ref_count_ = 1;
							_data3_->self = g_object_ref (self);
							if (!_tmp2_) {
								x++;
							}
							_tmp2_ = FALSE;
							if (!(x < width)) {
								block3_data_unref (_data3_);
								break;
							}
							index = (y * width) + x;
							xoffset = (x - (focus % width)) * rect.width;
							yoffset = (y - (focus / width)) * rect.height;
							g_warning ("spaces-manager.vala:224: %i %i", xoffset, yoffset);
							_data3_->clone = _g_object_ref0 (CLUTTER_ACTOR ((ClutterActor*) g_list_nth_data (clones, (guint) index)));
							anim = _g_object_ref0 (clutter_actor_animate (_data3_->clone, (gulong) CLUTTER_EASE_IN_OUT_SINE, (guint) 250, "x", (float) xoffset, "y", (float) yoffset, "scale-x", 1.0f, "scale-y", 1.0f, NULL));
							active_workspace = meta_screen_get_active_workspace_index (mutter_plugin_get_screen (unity_plugin_get_plugin (self->priv->plugin)));
							{
								ClutterActor* _tmp3_;
								GList* actor_collection;
								GList* actor_it;
								actor_collection = clutter_container_get_children ((ClutterContainer*) (_tmp3_ = _data3_->clone, CLUTTER_IS_GROUP (_tmp3_) ? ((ClutterGroup*) _tmp3_) : NULL));
								for (actor_it = actor_collection; actor_it != NULL; actor_it = actor_it->next) {
									ClutterActor* actor;
									actor = _g_object_ref0 ((ClutterActor*) actor_it->data);
									{
										if (UNITY_IS_EXPOSE_CLONE (actor)) {
											ClutterActor* _tmp4_;
											unity_expose_clone_restore_window_position ((_tmp4_ = actor, UNITY_IS_EXPOSE_CLONE (_tmp4_) ? ((UnityExposeClone*) _tmp4_) : NULL), active_workspace);
										}
										_g_object_unref0 (actor);
									}
								}
								_g_list_free0 (actor_collection);
							}
							g_signal_connect_data (anim, "completed", (GCallback) __lambda4__clutter_animation_completed, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
							_g_object_unref0 (anim);
							block3_data_unref (_data3_);
						}
					}
				}
			}
		}
	}
}


static void unity_spaces_manager_layout_workspaces (UnitySpacesManager* self, GList* clones, MetaScreen* screen) {
	guint length;
	gint width;
	gint height;
	MetaRectangle _tmp0_ = {0};
	MetaRectangle rect;
	gint active;
	gint xoffset;
	gint yoffset;
	guint item_width;
	float item_scale;
	guint item_height;
	g_return_if_fail (self != NULL);
	g_return_if_fail (screen != NULL);
	length = g_list_length (clones);
	width = (gint) ceil (sqrt ((double) length));
	height = (gint) floor (sqrt ((double) length));
	rect = (_tmp0_.height = 0, _tmp0_.width = 0, _tmp0_.x = 0, _tmp0_.y = 0, _tmp0_);
	meta_screen_get_monitor_geometry (screen, 0, &rect);
	active = meta_screen_get_active_workspace_index (screen);
	xoffset = (-(active % width)) * rect.width;
	yoffset = (-(active / width)) * rect.height;
	item_width = (((rect.width - self->priv->_left_padding) - self->priv->_right_padding) - ((width - 1) * self->priv->_spacing)) / width;
	item_scale = ((float) item_width) / ((float) rect.width);
	item_height = (guint) (rect.height * item_scale);
	{
		gint y;
		y = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					y++;
				}
				_tmp1_ = FALSE;
				if (!(y < height)) {
					break;
				}
				{
					gint x;
					x = 0;
					{
						gboolean _tmp2_;
						_tmp2_ = TRUE;
						while (TRUE) {
							gint index;
							ClutterActor* clone;
							if (!_tmp2_) {
								x++;
							}
							_tmp2_ = FALSE;
							if (!(x < width)) {
								break;
							}
							index = (y * width) + x;
							clone = _g_object_ref0 (CLUTTER_ACTOR ((ClutterActor*) g_list_nth_data (clones, (guint) index)));
							clutter_actor_set_scale (clone, (double) 1.0f, (double) 1.0f);
							clutter_actor_set_x (clone, (((float) rect.width) * x) + xoffset);
							clutter_actor_set_y (clone, (((float) rect.height) * y) + yoffset);
							clutter_actor_animate (clone, (gulong) CLUTTER_EASE_IN_OUT_SINE, (guint) 250, "x", ((float) self->priv->_left_padding) + ((item_width + self->priv->_spacing) * x), "y", ((float) self->priv->_top_padding) + ((item_height + self->priv->_spacing) * y), "scale-x", item_scale, "scale-y", item_scale, NULL);
							_g_object_unref0 (clone);
						}
					}
				}
			}
		}
	}
}


UnityLauncherScrollerChild* unity_spaces_manager_get_button (UnitySpacesManager* self) {
	UnityLauncherScrollerChild* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (!UNITY_LAUNCHER_IS_SCROLLER_CHILD (self->priv->_button)) {
		UnityLauncherScrollerChild* _tmp0_;
		UnitySpacesButtonController* _tmp1_;
		self->priv->_button = (_tmp0_ = g_object_ref_sink (unity_launcher_scroller_child_new ()), _g_object_unref0 (self->priv->_button), _tmp0_);
		self->priv->controller = (_tmp1_ = unity_spaces_button_controller_new (self, self->priv->_button), _g_object_unref0 (self->priv->controller), _tmp1_);
	}
	result = self->priv->_button;
	return result;
}


guint unity_spaces_manager_get_top_padding (UnitySpacesManager* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_top_padding;
	return result;
}


void unity_spaces_manager_set_top_padding (UnitySpacesManager* self, guint value) {
	g_return_if_fail (self != NULL);
	self->priv->_top_padding = value;
	g_object_notify ((GObject *) self, "top-padding");
}


guint unity_spaces_manager_get_right_padding (UnitySpacesManager* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_right_padding;
	return result;
}


void unity_spaces_manager_set_right_padding (UnitySpacesManager* self, guint value) {
	g_return_if_fail (self != NULL);
	self->priv->_right_padding = value;
	g_object_notify ((GObject *) self, "right-padding");
}


guint unity_spaces_manager_get_bottom_padding (UnitySpacesManager* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_bottom_padding;
	return result;
}


void unity_spaces_manager_set_bottom_padding (UnitySpacesManager* self, guint value) {
	g_return_if_fail (self != NULL);
	self->priv->_bottom_padding = value;
	g_object_notify ((GObject *) self, "bottom-padding");
}


guint unity_spaces_manager_get_left_padding (UnitySpacesManager* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_left_padding;
	return result;
}


void unity_spaces_manager_set_left_padding (UnitySpacesManager* self, guint value) {
	g_return_if_fail (self != NULL);
	self->priv->_left_padding = value;
	g_object_notify ((GObject *) self, "left-padding");
}


guint unity_spaces_manager_get_spacing (UnitySpacesManager* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_spacing;
	return result;
}


void unity_spaces_manager_set_spacing (UnitySpacesManager* self, guint value) {
	g_return_if_fail (self != NULL);
	self->priv->_spacing = value;
	g_object_notify ((GObject *) self, "spacing");
}


gboolean unity_spaces_manager_get_showing (UnitySpacesManager* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_showing;
	return result;
}


static void unity_spaces_manager_set_showing (UnitySpacesManager* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_showing = value;
	g_object_notify ((GObject *) self, "showing");
}


static GObject * unity_spaces_manager_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnitySpacesManager * self;
	parent_class = G_OBJECT_CLASS (unity_spaces_manager_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_SPACES_MANAGER (obj);
	{
		unity_spaces_manager_set_padding (self, (guint) 50, (guint) 50, (guint) 50, (guint) 50);
		unity_spaces_manager_set_spacing (self, (guint) 15);
	}
	return obj;
}


static void unity_spaces_manager_class_init (UnitySpacesManagerClass * klass) {
	unity_spaces_manager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnitySpacesManagerPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_spaces_manager_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_spaces_manager_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_spaces_manager_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_spaces_manager_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_SPACES_MANAGER_BUTTON, g_param_spec_object ("button", "button", "button", UNITY_LAUNCHER_TYPE_SCROLLER_CHILD, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_SPACES_MANAGER_TOP_PADDING, g_param_spec_uint ("top-padding", "top-padding", "top-padding", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_SPACES_MANAGER_RIGHT_PADDING, g_param_spec_uint ("right-padding", "right-padding", "right-padding", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_SPACES_MANAGER_BOTTOM_PADDING, g_param_spec_uint ("bottom-padding", "bottom-padding", "bottom-padding", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_SPACES_MANAGER_LEFT_PADDING, g_param_spec_uint ("left-padding", "left-padding", "left-padding", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_SPACES_MANAGER_SPACING, g_param_spec_uint ("spacing", "spacing", "spacing", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_SPACES_MANAGER_SHOWING, g_param_spec_boolean ("showing", "showing", "showing", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void unity_spaces_manager_instance_init (UnitySpacesManager * self) {
	self->priv = UNITY_SPACES_MANAGER_GET_PRIVATE (self);
}


static void unity_spaces_manager_finalize (GObject* obj) {
	UnitySpacesManager * self;
	self = UNITY_SPACES_MANAGER (obj);
	_g_object_unref0 (self->priv->background);
	__g_list_free_g_object_unref0 (self->priv->clones);
	_g_object_unref0 (self->priv->plugin);
	_g_object_unref0 (self->priv->_button);
	_g_object_unref0 (self->priv->controller);
	G_OBJECT_CLASS (unity_spaces_manager_parent_class)->finalize (obj);
}


GType unity_spaces_manager_get_type (void) {
	static volatile gsize unity_spaces_manager_type_id__volatile = 0;
	if (g_once_init_enter (&unity_spaces_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnitySpacesManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_spaces_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnitySpacesManager), 0, (GInstanceInitFunc) unity_spaces_manager_instance_init, NULL };
		GType unity_spaces_manager_type_id;
		unity_spaces_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "UnitySpacesManager", &g_define_type_info, 0);
		g_once_init_leave (&unity_spaces_manager_type_id__volatile, unity_spaces_manager_type_id);
	}
	return unity_spaces_manager_type_id__volatile;
}


static void unity_spaces_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnitySpacesManager * self;
	self = UNITY_SPACES_MANAGER (object);
	switch (property_id) {
		case UNITY_SPACES_MANAGER_BUTTON:
		g_value_set_object (value, unity_spaces_manager_get_button (self));
		break;
		case UNITY_SPACES_MANAGER_TOP_PADDING:
		g_value_set_uint (value, unity_spaces_manager_get_top_padding (self));
		break;
		case UNITY_SPACES_MANAGER_RIGHT_PADDING:
		g_value_set_uint (value, unity_spaces_manager_get_right_padding (self));
		break;
		case UNITY_SPACES_MANAGER_BOTTOM_PADDING:
		g_value_set_uint (value, unity_spaces_manager_get_bottom_padding (self));
		break;
		case UNITY_SPACES_MANAGER_LEFT_PADDING:
		g_value_set_uint (value, unity_spaces_manager_get_left_padding (self));
		break;
		case UNITY_SPACES_MANAGER_SPACING:
		g_value_set_uint (value, unity_spaces_manager_get_spacing (self));
		break;
		case UNITY_SPACES_MANAGER_SHOWING:
		g_value_set_boolean (value, unity_spaces_manager_get_showing (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_spaces_manager_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnitySpacesManager * self;
	self = UNITY_SPACES_MANAGER (object);
	switch (property_id) {
		case UNITY_SPACES_MANAGER_TOP_PADDING:
		unity_spaces_manager_set_top_padding (self, g_value_get_uint (value));
		break;
		case UNITY_SPACES_MANAGER_RIGHT_PADDING:
		unity_spaces_manager_set_right_padding (self, g_value_get_uint (value));
		break;
		case UNITY_SPACES_MANAGER_BOTTOM_PADDING:
		unity_spaces_manager_set_bottom_padding (self, g_value_get_uint (value));
		break;
		case UNITY_SPACES_MANAGER_LEFT_PADDING:
		unity_spaces_manager_set_left_padding (self, g_value_get_uint (value));
		break;
		case UNITY_SPACES_MANAGER_SPACING:
		unity_spaces_manager_set_spacing (self, g_value_get_uint (value));
		break;
		case UNITY_SPACES_MANAGER_SHOWING:
		unity_spaces_manager_set_showing (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}




