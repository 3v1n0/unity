/* entry.c generated by valac, the Vala compiler
 * generated from entry.vala, do not modify */

/*
 * Copyright (C) 2009 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Neil Jagdish Patel <neil.patel@canonical.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <clutk/clutk.h>
#include <stdlib.h>
#include <string.h>
#include <clutter/clutter.h>


#define UNITY_TYPE_ENTRY (unity_entry_get_type ())
#define UNITY_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_ENTRY, UnityEntry))
#define UNITY_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_ENTRY, UnityEntryClass))
#define UNITY_IS_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_ENTRY))
#define UNITY_IS_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_ENTRY))
#define UNITY_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_ENTRY, UnityEntryClass))

typedef struct _UnityEntry UnityEntry;
typedef struct _UnityEntryClass UnityEntryClass;
typedef struct _UnityEntryPrivate UnityEntryPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define UNITY_TYPE_SHELL (unity_shell_get_type ())
#define UNITY_SHELL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_SHELL, UnityShell))
#define UNITY_IS_SHELL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_SHELL))
#define UNITY_SHELL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), UNITY_TYPE_SHELL, UnityShellIface))

typedef struct _UnityShell UnityShell;
typedef struct _UnityShellIface UnityShellIface;

#define UNITY_TYPE_SHELL_MODE (unity_shell_mode_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _UnityEntry {
	CtkText parent_instance;
	UnityEntryPrivate * priv;
};

struct _UnityEntryClass {
	CtkTextClass parent_class;
};

struct _UnityEntryPrivate {
	char* _static_text;
};

typedef enum  {
	UNITY_SHELL_MODE_UNDERLAY,
	UNITY_SHELL_MODE_OVERLAY
} UnityShellMode;

struct _UnityShellIface {
	GTypeInterface parent_iface;
	UnityShellMode (*get_mode) (UnityShell* self);
	ClutterStage* (*get_stage) (UnityShell* self);
	void (*show_unity) (UnityShell* self);
	gint (*get_indicators_width) (UnityShell* self);
	void (*ensure_input_region) (UnityShell* self);
	void (*grab_keyboard) (UnityShell* self, gboolean grab, guint32 timestamp);
	gboolean (*get_menus_swallow_events) (UnityShell* self);
};


extern UnityShell* unity_global_shell;
static gpointer unity_entry_parent_class = NULL;

GType unity_entry_get_type (void);
#define UNITY_ENTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_ENTRY, UnityEntryPrivate))
enum  {
	UNITY_ENTRY_DUMMY_PROPERTY,
	UNITY_ENTRY_STATIC_TEXT
};
UnityEntry* unity_entry_new (const char* static_text);
UnityEntry* unity_entry_construct (GType object_type, const char* static_text);
static void unity_entry_on_key_focus_in (UnityEntry* self);
GType unity_shell_mode_get_type (void);
GType unity_shell_get_type (void);
void unity_shell_grab_keyboard (UnityShell* self, gboolean grab, guint32 timestamp);
static void unity_entry_on_key_focus_out (UnityEntry* self);
static void unity_entry_on_activate (UnityEntry* self);
static gboolean unity_entry_on_stage_captured_event (UnityEntry* self, ClutterEvent* event);
static gboolean _unity_entry_on_stage_captured_event_clutter_actor_captured_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static gboolean unity_entry_on_button_press_event (UnityEntry* self, ClutterEvent* event);
const char* unity_entry_get_static_text (UnityEntry* self);
void unity_entry_set_static_text (UnityEntry* self, const char* value);
static void _unity_entry_on_key_focus_in_clutter_actor_key_focus_in (ClutterActor* _sender, gpointer self);
static void _unity_entry_on_key_focus_out_clutter_actor_key_focus_out (ClutterActor* _sender, gpointer self);
static gboolean _unity_entry_on_button_press_event_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static void _unity_entry_on_activate_clutter_text_activate (ClutterText* _sender, gpointer self);
static GObject * unity_entry_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_entry_finalize (GObject* obj);
static void unity_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static int _vala_strcmp0 (const char * str1, const char * str2);



#line 39 "entry.vala"
UnityEntry* unity_entry_construct (GType object_type, const char* static_text) {
#line 121 "entry.c"
	UnityEntry * self;
#line 39 "entry.vala"
	g_return_val_if_fail (static_text != NULL, NULL);
#line 41 "entry.vala"
	self = (UnityEntry*) g_object_new (object_type, "static-text", static_text, NULL);
#line 127 "entry.c"
	return self;
}


#line 39 "entry.vala"
UnityEntry* unity_entry_new (const char* static_text) {
#line 39 "entry.vala"
	return unity_entry_construct (UNITY_TYPE_ENTRY, static_text);
#line 136 "entry.c"
}


#line 64 "entry.vala"
static void unity_entry_on_key_focus_in (UnityEntry* self) {
#line 64 "entry.vala"
	g_return_if_fail (self != NULL);
#line 66 "entry.vala"
	if (_vala_strcmp0 (clutter_text_get_text ((ClutterText*) self), self->priv->_static_text) == 0) {
#line 146 "entry.c"
		ClutterColor _tmp0_ = {0};
		ClutterColor _tmp1_;
#line 68 "entry.vala"
		clutter_text_set_text ((ClutterText*) self, "");
#line 69 "entry.vala"
		clutter_text_set_cursor_visible ((ClutterText*) self, TRUE);
#line 70 "entry.vala"
		clutter_text_set_selection ((ClutterText*) self, (gssize) 0, (gssize) (-1));
#line 71 "entry.vala"
		clutter_text_set_color ((ClutterText*) self, (_tmp1_ = (_tmp0_.red = (guint8) 0x00, _tmp0_.green = (guint8) 0x00, _tmp0_.blue = (guint8) 0x00, _tmp0_.alpha = (guint8) 0xff, _tmp0_), &_tmp1_));
#line 157 "entry.c"
	}
}


#line 75 "entry.vala"
static void unity_entry_on_key_focus_out (UnityEntry* self) {
#line 164 "entry.c"
	ClutterColor _tmp0_ = {0};
	ClutterColor _tmp1_;
#line 75 "entry.vala"
	g_return_if_fail (self != NULL);
#line 77 "entry.vala"
	clutter_text_set_cursor_visible ((ClutterText*) self, FALSE);
#line 78 "entry.vala"
	clutter_text_set_text ((ClutterText*) self, self->priv->_static_text);
#line 79 "entry.vala"
	clutter_text_set_color ((ClutterText*) self, (_tmp1_ = (_tmp0_.red = (guint8) 0x80, _tmp0_.green = (guint8) 0x80, _tmp0_.blue = (guint8) 0x80, _tmp0_.alpha = (guint8) 0xff, _tmp0_), &_tmp1_));
#line 81 "entry.vala"
	unity_shell_grab_keyboard (unity_global_shell, FALSE, clutter_get_current_event_time ());
#line 177 "entry.c"
}


#line 85 "entry.vala"
static void unity_entry_on_activate (UnityEntry* self) {
#line 85 "entry.vala"
	g_return_if_fail (self != NULL);
#line 87 "entry.vala"
	unity_shell_grab_keyboard (unity_global_shell, FALSE, clutter_get_current_event_time ());
#line 89 "entry.vala"
	clutter_ungrab_keyboard ();
#line 189 "entry.c"
}


#line 101 "entry.vala"
static gboolean _unity_entry_on_stage_captured_event_clutter_actor_captured_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
#line 195 "entry.c"
	return unity_entry_on_stage_captured_event (self, event);
}


#line 92 "entry.vala"
static gboolean unity_entry_on_button_press_event (UnityEntry* self, ClutterEvent* event) {
#line 202 "entry.c"
	gboolean result;
#line 92 "entry.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 94 "entry.vala"
	unity_shell_grab_keyboard (unity_global_shell, TRUE, (*event).button.time);
#line 96 "entry.vala"
	g_signal_connect_object (clutter_actor_get_stage ((ClutterActor*) self), "captured-event", (GCallback) _unity_entry_on_stage_captured_event_clutter_actor_captured_event, self, 0);
#line 210 "entry.c"
	result = FALSE;
#line 98 "entry.vala"
	return result;
#line 214 "entry.c"
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


#line 101 "entry.vala"
static gboolean unity_entry_on_stage_captured_event (UnityEntry* self, ClutterEvent* event) {
#line 225 "entry.c"
	gboolean result;
#line 101 "entry.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 103 "entry.vala"
	if ((*event).type == CLUTTER_BUTTON_PRESS) {
#line 231 "entry.c"
		ClutterActor* _tmp0_;
		ClutterStage* stage;
		ClutterActor* actor;
#line 105 "entry.vala"
		stage = _g_object_ref0 ((_tmp0_ = clutter_actor_get_stage ((ClutterActor*) self), CLUTTER_IS_STAGE (_tmp0_) ? ((ClutterStage*) _tmp0_) : NULL));
#line 107 "entry.vala"
		actor = _g_object_ref0 (clutter_stage_get_actor_at_pos (stage, CLUTTER_PICK_REACTIVE, (gint) (*event).button.x, (gint) (*event).button.y));
#line 111 "entry.vala"
		if (actor != CLUTTER_ACTOR (self)) {
#line 241 "entry.c"
			guint _tmp1_;
#line 113 "entry.vala"
			unity_shell_grab_keyboard (unity_global_shell, FALSE, (*event).button.time);
#line 114 "entry.vala"
			g_signal_handlers_disconnect_matched ((ClutterActor*) stage, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, (g_signal_parse_name ("captured-event", CLUTTER_TYPE_ACTOR, &_tmp1_, NULL, FALSE), _tmp1_), 0, NULL, (GCallback) _unity_entry_on_stage_captured_event_clutter_actor_captured_event, self);
#line 116 "entry.vala"
			clutter_ungrab_keyboard ();
#line 249 "entry.c"
		}
		_g_object_unref0 (stage);
		_g_object_unref0 (actor);
	}
	result = FALSE;
#line 120 "entry.vala"
	return result;
#line 257 "entry.c"
}


const char* unity_entry_get_static_text (UnityEntry* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_static_text;
#line 29 "entry.vala"
	return result;
#line 267 "entry.c"
}


void unity_entry_set_static_text (UnityEntry* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
#line 34 "entry.vala"
	self->priv->_static_text = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_static_text), _tmp0_);
#line 35 "entry.vala"
	clutter_text_set_text ((ClutterText*) self, self->priv->_static_text);
#line 278 "entry.c"
	g_object_notify ((GObject *) self, "static-text");
}


#line 64 "entry.vala"
static void _unity_entry_on_key_focus_in_clutter_actor_key_focus_in (ClutterActor* _sender, gpointer self) {
#line 285 "entry.c"
	unity_entry_on_key_focus_in (self);
}


#line 75 "entry.vala"
static void _unity_entry_on_key_focus_out_clutter_actor_key_focus_out (ClutterActor* _sender, gpointer self) {
#line 292 "entry.c"
	unity_entry_on_key_focus_out (self);
}


#line 92 "entry.vala"
static gboolean _unity_entry_on_button_press_event_clutter_actor_button_press_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
#line 299 "entry.c"
	return unity_entry_on_button_press_event (self, event);
}


#line 85 "entry.vala"
static void _unity_entry_on_activate_clutter_text_activate (ClutterText* _sender, gpointer self) {
#line 306 "entry.c"
	unity_entry_on_activate (self);
}


static GObject * unity_entry_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityEntry * self;
	parent_class = G_OBJECT_CLASS (unity_entry_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_ENTRY (obj);
	{
		ClutterColor _tmp0_ = {0};
		ClutterColor _tmp1_;
		ClutterColor _tmp2_ = {0};
		ClutterColor _tmp3_;
		ClutterColor _tmp4_ = {0};
		ClutterColor _tmp5_;
#line 46 "entry.vala"
		clutter_actor_set_reactive ((ClutterActor*) self, TRUE);
#line 47 "entry.vala"
		clutter_text_set_editable ((ClutterText*) self, TRUE);
#line 48 "entry.vala"
		clutter_text_set_selectable ((ClutterText*) self, TRUE);
#line 49 "entry.vala"
		clutter_text_set_activatable ((ClutterText*) self, TRUE);
#line 52 "entry.vala"
		clutter_text_set_cursor_visible ((ClutterText*) self, FALSE);
#line 53 "entry.vala"
		clutter_text_set_cursor_color ((ClutterText*) self, (_tmp1_ = (_tmp0_.red = (guint8) 0x22, _tmp0_.green = (guint8) 0x22, _tmp0_.blue = (guint8) 0x22, _tmp0_.alpha = (guint8) 0xff, _tmp0_), &_tmp1_));
#line 54 "entry.vala"
		clutter_text_set_selection_color ((ClutterText*) self, (_tmp3_ = (_tmp2_.red = (guint8) 0x4d, _tmp2_.green = (guint8) 0x4d, _tmp2_.blue = (guint8) 0x4d, _tmp2_.alpha = (guint8) 0xff, _tmp2_), &_tmp3_));
#line 55 "entry.vala"
		clutter_text_set_color ((ClutterText*) self, (_tmp5_ = (_tmp4_.red = (guint8) 0x80, _tmp4_.green = (guint8) 0x80, _tmp4_.blue = (guint8) 0x80, _tmp4_.alpha = (guint8) 0xff, _tmp4_), &_tmp5_));
#line 57 "entry.vala"
		g_signal_connect_object ((ClutterActor*) self, "key-focus-in", (GCallback) _unity_entry_on_key_focus_in_clutter_actor_key_focus_in, self, 0);
#line 58 "entry.vala"
		g_signal_connect_object ((ClutterActor*) self, "key-focus-out", (GCallback) _unity_entry_on_key_focus_out_clutter_actor_key_focus_out, self, 0);
#line 60 "entry.vala"
		g_signal_connect_object ((ClutterActor*) self, "button-press-event", (GCallback) _unity_entry_on_button_press_event_clutter_actor_button_press_event, self, 0);
#line 61 "entry.vala"
		g_signal_connect_object ((ClutterText*) self, "activate", (GCallback) _unity_entry_on_activate_clutter_text_activate, self, 0);
#line 349 "entry.c"
	}
	return obj;
}


static void unity_entry_class_init (UnityEntryClass * klass) {
	unity_entry_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityEntryPrivate));
	G_OBJECT_CLASS (klass)->get_property = unity_entry_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_entry_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_entry_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_entry_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_ENTRY_STATIC_TEXT, g_param_spec_string ("static-text", "static-text", "static-text", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
}


static void unity_entry_instance_init (UnityEntry * self) {
	self->priv = UNITY_ENTRY_GET_PRIVATE (self);
}


static void unity_entry_finalize (GObject* obj) {
	UnityEntry * self;
	self = UNITY_ENTRY (obj);
	_g_free0 (self->priv->_static_text);
	G_OBJECT_CLASS (unity_entry_parent_class)->finalize (obj);
}


GType unity_entry_get_type (void) {
	static GType unity_entry_type_id = 0;
	if (unity_entry_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityEntry), 0, (GInstanceInitFunc) unity_entry_instance_init, NULL };
		unity_entry_type_id = g_type_register_static (CTK_TYPE_TEXT, "UnityEntry", &g_define_type_info, 0);
	}
	return unity_entry_type_id;
}


static void unity_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityEntry * self;
	self = UNITY_ENTRY (object);
	switch (property_id) {
		case UNITY_ENTRY_STATIC_TEXT:
		g_value_set_string (value, unity_entry_get_static_text (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityEntry * self;
	self = UNITY_ENTRY (object);
	switch (property_id) {
		case UNITY_ENTRY_STATIC_TEXT:
		unity_entry_set_static_text (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




