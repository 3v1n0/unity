/* icon-postprocessor.c generated by valac, the Vala compiler
 * generated from icon-postprocessor.vala, do not modify */

/*
 *      icon-postprocessor.vala
 *      Copyright (C) 2010 Canonical Ltd
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 *      MA 02110-1301, USA.
 *
 *
 *      Authored by Gordon Allott <gord.allott@canonical.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <clutk/clutk.h>
#include <clutter/clutter.h>
#include <cogl/cogl.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>


#define UNITY_TYPE_UNITY_ICON (unity_unity_icon_get_type ())
#define UNITY_UNITY_ICON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_UNITY_ICON, UnityUnityIcon))
#define UNITY_UNITY_ICON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_UNITY_ICON, UnityUnityIconClass))
#define UNITY_IS_UNITY_ICON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_UNITY_ICON))
#define UNITY_IS_UNITY_ICON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_UNITY_ICON))
#define UNITY_UNITY_ICON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_UNITY_ICON, UnityUnityIconClass))

typedef struct _UnityUnityIcon UnityUnityIcon;
typedef struct _UnityUnityIconClass UnityUnityIconClass;
typedef struct _UnityUnityIconPrivate UnityUnityIconPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cogl_handle_unref0(var) ((var == NULL) ? NULL : (var = (cogl_handle_unref (var), NULL)))

#define UNITY_TYPE_THEME_IMAGE (unity_theme_image_get_type ())
#define UNITY_THEME_IMAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_TYPE_THEME_IMAGE, UnityThemeImage))
#define UNITY_THEME_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_TYPE_THEME_IMAGE, UnityThemeImageClass))
#define UNITY_IS_THEME_IMAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_TYPE_THEME_IMAGE))
#define UNITY_IS_THEME_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_TYPE_THEME_IMAGE))
#define UNITY_THEME_IMAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_TYPE_THEME_IMAGE, UnityThemeImageClass))

typedef struct _UnityThemeImage UnityThemeImage;
typedef struct _UnityThemeImageClass UnityThemeImageClass;

struct _UnityUnityIcon {
	CtkActor parent_instance;
	UnityUnityIconPrivate * priv;
};

struct _UnityUnityIconClass {
	CtkActorClass parent_class;
};

struct _UnityUnityIconPrivate {
	ClutterTexture* _icon;
	ClutterTexture* _bg_color;
	ClutterTexture* bg_layer;
	ClutterTexture* fg_layer;
	ClutterTexture* mask;
	CoglHandle* bg_mat;
	CoglHandle* fg_mat;
	CoglHandle* icon_material;
	CoglHandle* bgcol_material;
};


static gpointer unity_unity_icon_parent_class = NULL;

GType unity_unity_icon_get_type (void);
#define UNITY_UNITY_ICON_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_UNITY_ICON, UnityUnityIconPrivate))
enum  {
	UNITY_UNITY_ICON_DUMMY_PROPERTY,
	UNITY_UNITY_ICON_ICON,
	UNITY_UNITY_ICON_BG_COLOR
};
UnityUnityIcon* unity_unity_icon_new (ClutterTexture* icon, ClutterTexture* bg_tex);
UnityUnityIcon* unity_unity_icon_construct (GType object_type, ClutterTexture* icon, ClutterTexture* bg_tex);
static void unity_unity_icon_real_get_preferred_width (ClutterActor* base, float for_height, float* minimum_width, float* natural_width);
static void unity_unity_icon_real_get_preferred_height (ClutterActor* base, float for_width, float* minimum_height, float* natural_height);
ClutterTexture* unity_unity_icon_get_icon (UnityUnityIcon* self);
ClutterTexture* unity_unity_icon_get_bg_color (UnityUnityIcon* self);
static void unity_unity_icon_real_allocate (ClutterActor* base, const ClutterActorBox* box, ClutterAllocationFlags flags);
static void unity_unity_icon_real_pick (ClutterActor* base, const ClutterColor* color);
void unity_unity_icon_paint_real (ClutterActor* actor);
static void _unity_unity_icon_paint_real_ctk_effect_paint_func (ClutterActor* actor);
static void unity_unity_icon_real_paint (ClutterActor* base);
static void unity_unity_icon_real_map (ClutterActor* base);
static void unity_unity_icon_real_unmap (ClutterActor* base);
static void unity_unity_icon_set_icon (UnityUnityIcon* self, ClutterTexture* value);
static void unity_unity_icon_set_bg_color (UnityUnityIcon* self, ClutterTexture* value);
UnityThemeImage* unity_theme_image_new (const char* icon_name);
UnityThemeImage* unity_theme_image_construct (GType object_type, const char* icon_name);
GType unity_theme_image_get_type (void);
static GObject * unity_unity_icon_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void unity_unity_icon_finalize (GObject* obj);
static void unity_unity_icon_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void unity_unity_icon_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);



#line 43 "icon-postprocessor.vala"
UnityUnityIcon* unity_unity_icon_construct (GType object_type, ClutterTexture* icon, ClutterTexture* bg_tex) {
#line 120 "icon-postprocessor.c"
	UnityUnityIcon * self;
#line 45 "icon-postprocessor.vala"
	self = (UnityUnityIcon*) g_object_new (object_type, "icon", icon, "bg-color", bg_tex, NULL);
#line 124 "icon-postprocessor.c"
	return self;
}


#line 43 "icon-postprocessor.vala"
UnityUnityIcon* unity_unity_icon_new (ClutterTexture* icon, ClutterTexture* bg_tex) {
#line 43 "icon-postprocessor.vala"
	return unity_unity_icon_construct (UNITY_TYPE_UNITY_ICON, icon, bg_tex);
#line 133 "icon-postprocessor.c"
}


#line 90 "icon-postprocessor.vala"
static void unity_unity_icon_real_get_preferred_width (ClutterActor* base, float for_height, float* minimum_width, float* natural_width) {
#line 139 "icon-postprocessor.c"
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
#line 94 "icon-postprocessor.vala"
	*natural_width = *minimum_width = (float) 48;
#line 144 "icon-postprocessor.c"
}


#line 97 "icon-postprocessor.vala"
static void unity_unity_icon_real_get_preferred_height (ClutterActor* base, float for_width, float* minimum_height, float* natural_height) {
#line 150 "icon-postprocessor.c"
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
#line 101 "icon-postprocessor.vala"
	*natural_height = *minimum_height = (float) 48;
#line 155 "icon-postprocessor.c"
}


#line 104 "icon-postprocessor.vala"
static void unity_unity_icon_real_allocate (ClutterActor* base, const ClutterActorBox* box, ClutterAllocationFlags flags) {
#line 161 "icon-postprocessor.c"
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
#line 106 "icon-postprocessor.vala"
	CLUTTER_ACTOR_CLASS (unity_unity_icon_parent_class)->allocate ((ClutterActor*) CTK_ACTOR (self), box, flags);
#line 107 "icon-postprocessor.vala"
	clutter_actor_allocate ((ClutterActor*) self->priv->bg_layer, box, flags);
#line 108 "icon-postprocessor.vala"
	clutter_actor_allocate ((ClutterActor*) self->priv->fg_layer, box, flags);
#line 109 "icon-postprocessor.vala"
	clutter_actor_allocate ((ClutterActor*) self->priv->mask, box, flags);
#line 110 "icon-postprocessor.vala"
	if (CLUTTER_IS_TEXTURE (self->priv->_icon)) {
#line 111 "icon-postprocessor.vala"
		clutter_actor_allocate ((ClutterActor*) self->priv->_icon, box, flags);
#line 176 "icon-postprocessor.c"
	}
#line 112 "icon-postprocessor.vala"
	if (CLUTTER_IS_TEXTURE (self->priv->_bg_color)) {
#line 113 "icon-postprocessor.vala"
		clutter_actor_allocate ((ClutterActor*) self->priv->_bg_color, box, flags);
#line 182 "icon-postprocessor.c"
	}
}


#line 116 "icon-postprocessor.vala"
static void unity_unity_icon_real_pick (ClutterActor* base, const ClutterColor* color) {
#line 189 "icon-postprocessor.c"
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
#line 118 "icon-postprocessor.vala"
	ctk_actor_set_effects_painting ((CtkActor*) self, TRUE);
#line 119 "icon-postprocessor.vala"
	CLUTTER_ACTOR_CLASS (unity_unity_icon_parent_class)->pick ((ClutterActor*) CTK_ACTOR (self), color);
#line 120 "icon-postprocessor.vala"
	clutter_actor_paint ((ClutterActor*) self->priv->bg_layer);
#line 121 "icon-postprocessor.vala"
	ctk_actor_set_effects_painting ((CtkActor*) self, FALSE);
#line 200 "icon-postprocessor.c"
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


#line 127 "icon-postprocessor.vala"
void unity_unity_icon_paint_real (ClutterActor* actor) {
#line 211 "icon-postprocessor.c"
	ClutterActor* _tmp0_;
	UnityUnityIcon* _self_;
	ClutterActorBox _tmp1_ = {0};
	ClutterActorBox box;
#line 127 "icon-postprocessor.vala"
	g_return_if_fail (actor != NULL);
#line 129 "icon-postprocessor.vala"
	_self_ = _g_object_ref0 ((_tmp0_ = actor, UNITY_IS_UNITY_ICON (_tmp0_) ? ((UnityUnityIcon*) _tmp0_) : NULL));
#line 131 "icon-postprocessor.vala"
	box = (memset (&_tmp1_, 0, sizeof (ClutterActorBox)), _tmp1_);
#line 132 "icon-postprocessor.vala"
	ctk_actor_get_stored_allocation ((CtkActor*) _self_, &box);
#line 137 "icon-postprocessor.vala"
	cogl_set_source (_self_->priv->bg_mat);
#line 138 "icon-postprocessor.vala"
	cogl_rectangle (box.x1, box.y1, box.x2, box.y2);
#line 140 "icon-postprocessor.vala"
	if (CLUTTER_IS_TEXTURE (_self_->priv->_bg_color)) {
#line 142 "icon-postprocessor.vala"
		cogl_set_source (_self_->priv->bgcol_material);
#line 143 "icon-postprocessor.vala"
		cogl_rectangle (box.x1, box.y1, box.x2, box.y2);
#line 234 "icon-postprocessor.c"
	}
#line 145 "icon-postprocessor.vala"
	if (CLUTTER_IS_TEXTURE (_self_->priv->_icon)) {
#line 147 "icon-postprocessor.vala"
		cogl_set_source (_self_->priv->icon_material);
#line 148 "icon-postprocessor.vala"
		cogl_rectangle (box.x1, box.y1, box.x2, box.y2);
#line 242 "icon-postprocessor.c"
	}
#line 151 "icon-postprocessor.vala"
	cogl_set_source (_self_->priv->fg_mat);
#line 152 "icon-postprocessor.vala"
	cogl_rectangle (box.x1, box.y1, box.x2, box.y2);
#line 248 "icon-postprocessor.c"
	_g_object_unref0 (_self_);
}


#line 127 "icon-postprocessor.vala"
static void _unity_unity_icon_paint_real_ctk_effect_paint_func (ClutterActor* actor) {
#line 255 "icon-postprocessor.c"
	unity_unity_icon_paint_real (actor);
}


#line 155 "icon-postprocessor.vala"
static void unity_unity_icon_real_paint (ClutterActor* base) {
#line 262 "icon-postprocessor.c"
	UnityUnityIcon * self;
	GSList* effects;
	gboolean _tmp0_ = FALSE;
	self = (UnityUnityIcon*) base;
#line 160 "icon-postprocessor.vala"
	effects = ctk_actor_get_effects ((CtkActor*) self);
#line 161 "icon-postprocessor.vala"
	if (!ctk_actor_get_effects_painting ((CtkActor*) self)) {
#line 161 "icon-postprocessor.vala"
		_tmp0_ = effects != NULL;
#line 273 "icon-postprocessor.c"
	} else {
#line 161 "icon-postprocessor.vala"
		_tmp0_ = FALSE;
#line 277 "icon-postprocessor.c"
	}
#line 161 "icon-postprocessor.vala"
	if (_tmp0_) {
#line 281 "icon-postprocessor.c"
		GSList* e;
		e = NULL;
#line 164 "icon-postprocessor.vala"
		ctk_actor_set_effects_painting ((CtkActor*) self, TRUE);
#line 286 "icon-postprocessor.c"
		{
			gboolean _tmp1_;
#line 165 "icon-postprocessor.vala"
			e = effects;
#line 165 "icon-postprocessor.vala"
			_tmp1_ = TRUE;
#line 165 "icon-postprocessor.vala"
			while (TRUE) {
#line 295 "icon-postprocessor.c"
				CtkEffect* effect;
				gboolean _tmp2_ = FALSE;
				gboolean last_effect;
#line 165 "icon-postprocessor.vala"
				if (!_tmp1_) {
#line 165 "icon-postprocessor.vala"
					e = e->next;
#line 303 "icon-postprocessor.c"
				}
#line 165 "icon-postprocessor.vala"
				_tmp1_ = FALSE;
#line 165 "icon-postprocessor.vala"
				if (!(e != NULL)) {
#line 165 "icon-postprocessor.vala"
					break;
#line 311 "icon-postprocessor.c"
				}
#line 167 "icon-postprocessor.vala"
				effect = _g_object_ref0 ((CtkEffect*) e->data);
#line 168 "icon-postprocessor.vala"
				if (e->next != NULL) {
#line 168 "icon-postprocessor.vala"
					_tmp2_ = FALSE;
#line 319 "icon-postprocessor.c"
				} else {
#line 168 "icon-postprocessor.vala"
					_tmp2_ = TRUE;
#line 323 "icon-postprocessor.c"
				}
#line 168 "icon-postprocessor.vala"
				last_effect = _tmp2_;
#line 169 "icon-postprocessor.vala"
				ctk_effect_paint (effect, _unity_unity_icon_paint_real_ctk_effect_paint_func, last_effect);
#line 329 "icon-postprocessor.c"
				_g_object_unref0 (effect);
			}
		}
#line 172 "icon-postprocessor.vala"
		ctk_actor_set_effects_painting ((CtkActor*) self, FALSE);
#line 335 "icon-postprocessor.c"
	} else {
#line 176 "icon-postprocessor.vala"
		unity_unity_icon_paint_real ((ClutterActor*) self);
#line 339 "icon-postprocessor.c"
	}
}


#line 180 "icon-postprocessor.vala"
static void unity_unity_icon_real_map (ClutterActor* base) {
#line 346 "icon-postprocessor.c"
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
#line 182 "icon-postprocessor.vala"
	CLUTTER_ACTOR_CLASS (unity_unity_icon_parent_class)->map ((ClutterActor*) CTK_ACTOR (self));
#line 183 "icon-postprocessor.vala"
	clutter_actor_map ((ClutterActor*) self->priv->bg_layer);
#line 184 "icon-postprocessor.vala"
	clutter_actor_map ((ClutterActor*) self->priv->_icon);
#line 185 "icon-postprocessor.vala"
	clutter_actor_map ((ClutterActor*) self->priv->fg_layer);
#line 357 "icon-postprocessor.c"
}


#line 188 "icon-postprocessor.vala"
static void unity_unity_icon_real_unmap (ClutterActor* base) {
#line 363 "icon-postprocessor.c"
	UnityUnityIcon * self;
	self = (UnityUnityIcon*) base;
#line 190 "icon-postprocessor.vala"
	CLUTTER_ACTOR_CLASS (unity_unity_icon_parent_class)->map ((ClutterActor*) CTK_ACTOR (self));
#line 191 "icon-postprocessor.vala"
	clutter_actor_unmap ((ClutterActor*) self->priv->bg_layer);
#line 192 "icon-postprocessor.vala"
	clutter_actor_unmap ((ClutterActor*) self->priv->_icon);
#line 193 "icon-postprocessor.vala"
	clutter_actor_unmap ((ClutterActor*) self->priv->fg_layer);
#line 374 "icon-postprocessor.c"
}


ClutterTexture* unity_unity_icon_get_icon (UnityUnityIcon* self) {
	ClutterTexture* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_icon;
#line 32 "icon-postprocessor.vala"
	return result;
#line 384 "icon-postprocessor.c"
}


static void unity_unity_icon_set_icon (UnityUnityIcon* self, ClutterTexture* value) {
	ClutterTexture* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_icon = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_icon), _tmp0_);
	g_object_notify ((GObject *) self, "icon");
}


ClutterTexture* unity_unity_icon_get_bg_color (UnityUnityIcon* self) {
	ClutterTexture* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_bg_color;
#line 33 "icon-postprocessor.vala"
	return result;
#line 402 "icon-postprocessor.c"
}


static void unity_unity_icon_set_bg_color (UnityUnityIcon* self, ClutterTexture* value) {
	ClutterTexture* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_bg_color = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_bg_color), _tmp0_);
	g_object_notify ((GObject *) self, "bg-color");
}


static gpointer _cogl_handle_ref0 (gpointer self) {
	return self ? cogl_handle_ref (self) : NULL;
}


static GObject * unity_unity_icon_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UnityUnityIcon * self;
	parent_class = G_OBJECT_CLASS (unity_unity_icon_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = UNITY_UNITY_ICON (obj);
	{
		ClutterTexture* _tmp0_;
		ClutterTexture* _tmp1_;
		ClutterTexture* _tmp2_;
		CoglHandle* mat;
		CoglHandle* tex;
		CoglHandle* _tmp5_;
		CoglHandle* _tmp6_;
		CoglHandle* _tmp7_;
		CoglHandle* _tmp8_;
#line 50 "icon-postprocessor.vala"
		self->priv->bg_layer = (_tmp0_ = (ClutterTexture*) g_object_ref_sink (unity_theme_image_new ("prism_icon_background")), _g_object_unref0 (self->priv->bg_layer), _tmp0_);
#line 51 "icon-postprocessor.vala"
		self->priv->fg_layer = (_tmp1_ = (ClutterTexture*) g_object_ref_sink (unity_theme_image_new ("prism_icon_foreground")), _g_object_unref0 (self->priv->fg_layer), _tmp1_);
#line 52 "icon-postprocessor.vala"
		self->priv->mask = (_tmp2_ = (ClutterTexture*) g_object_ref_sink (unity_theme_image_new ("prism_icon_mask")), _g_object_unref0 (self->priv->mask), _tmp2_);
#line 54 "icon-postprocessor.vala"
		clutter_actor_set_parent ((ClutterActor*) self->priv->bg_layer, (ClutterActor*) self);
#line 55 "icon-postprocessor.vala"
		clutter_actor_set_parent ((ClutterActor*) self->priv->fg_layer, (ClutterActor*) self);
#line 56 "icon-postprocessor.vala"
		clutter_actor_set_parent ((ClutterActor*) self->priv->mask, (ClutterActor*) self);
#line 58 "icon-postprocessor.vala"
		if (CLUTTER_IS_TEXTURE (self->priv->_icon)) {
#line 450 "icon-postprocessor.c"
			CoglHandle* icon_mat;
			CoglHandle* icon_tex;
			CoglHandle* mask_tex;
			CoglHandle* _tmp3_;
#line 60 "icon-postprocessor.vala"
			clutter_actor_set_parent ((ClutterActor*) self->priv->_icon, (ClutterActor*) self);
#line 61 "icon-postprocessor.vala"
			icon_mat = cogl_material_new ();
#line 62 "icon-postprocessor.vala"
			icon_tex = (CoglHandle*) clutter_texture_get_cogl_texture (self->priv->_icon);
#line 63 "icon-postprocessor.vala"
			mask_tex = (CoglHandle*) clutter_texture_get_cogl_texture (self->priv->mask);
#line 64 "icon-postprocessor.vala"
			cogl_material_set_layer (icon_mat, 0, icon_tex);
#line 65 "icon-postprocessor.vala"
			cogl_material_set_layer (icon_mat, 1, mask_tex);
#line 66 "icon-postprocessor.vala"
			self->priv->icon_material = (_tmp3_ = _cogl_handle_ref0 (icon_mat), _cogl_handle_unref0 (self->priv->icon_material), _tmp3_);
#line 469 "icon-postprocessor.c"
			_cogl_handle_unref0 (icon_mat);
			_cogl_handle_unref0 (icon_tex);
			_cogl_handle_unref0 (mask_tex);
		}
#line 68 "icon-postprocessor.vala"
		if (CLUTTER_IS_TEXTURE (self->priv->_bg_color)) {
#line 476 "icon-postprocessor.c"
			CoglHandle* _tmp4_;
			CoglHandle* color;
			CoglHandle* mask_tex;
#line 70 "icon-postprocessor.vala"
			clutter_actor_set_parent ((ClutterActor*) self->priv->_bg_color, (ClutterActor*) self);
#line 71 "icon-postprocessor.vala"
			self->priv->bgcol_material = (_tmp4_ = cogl_material_new (), _cogl_handle_unref0 (self->priv->bgcol_material), _tmp4_);
#line 72 "icon-postprocessor.vala"
			color = (CoglHandle*) clutter_texture_get_cogl_texture (self->priv->_bg_color);
#line 73 "icon-postprocessor.vala"
			mask_tex = (CoglHandle*) clutter_texture_get_cogl_texture (self->priv->mask);
#line 74 "icon-postprocessor.vala"
			cogl_material_set_layer (self->priv->bgcol_material, 0, color);
#line 75 "icon-postprocessor.vala"
			cogl_material_set_layer_filters (self->priv->bgcol_material, 1, COGL_MATERIAL_FILTER_NEAREST, COGL_MATERIAL_FILTER_NEAREST);
#line 76 "icon-postprocessor.vala"
			cogl_material_set_layer (self->priv->bgcol_material, 1, mask_tex);
#line 494 "icon-postprocessor.c"
			_cogl_handle_unref0 (color);
			_cogl_handle_unref0 (mask_tex);
		}
#line 79 "icon-postprocessor.vala"
		mat = cogl_material_new ();
#line 80 "icon-postprocessor.vala"
		tex = (CoglHandle*) clutter_texture_get_cogl_texture (self->priv->bg_layer);
#line 81 "icon-postprocessor.vala"
		cogl_material_set_layer (mat, 0, tex);
#line 82 "icon-postprocessor.vala"
		self->priv->bg_mat = (_tmp5_ = _cogl_handle_ref0 (mat), _cogl_handle_unref0 (self->priv->bg_mat), _tmp5_);
#line 84 "icon-postprocessor.vala"
		mat = (_tmp6_ = cogl_material_new (), _cogl_handle_unref0 (mat), _tmp6_);
#line 85 "icon-postprocessor.vala"
		tex = (_tmp7_ = (CoglHandle*) clutter_texture_get_cogl_texture (self->priv->fg_layer), _cogl_handle_unref0 (tex), _tmp7_);
#line 86 "icon-postprocessor.vala"
		cogl_material_set_layer (mat, 0, tex);
#line 87 "icon-postprocessor.vala"
		self->priv->fg_mat = (_tmp8_ = _cogl_handle_ref0 (mat), _cogl_handle_unref0 (self->priv->fg_mat), _tmp8_);
#line 514 "icon-postprocessor.c"
		_cogl_handle_unref0 (mat);
		_cogl_handle_unref0 (tex);
	}
	return obj;
}


static void unity_unity_icon_class_init (UnityUnityIconClass * klass) {
	unity_unity_icon_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityUnityIconPrivate));
	CLUTTER_ACTOR_CLASS (klass)->get_preferred_width = unity_unity_icon_real_get_preferred_width;
	CLUTTER_ACTOR_CLASS (klass)->get_preferred_height = unity_unity_icon_real_get_preferred_height;
	CLUTTER_ACTOR_CLASS (klass)->allocate = unity_unity_icon_real_allocate;
	CLUTTER_ACTOR_CLASS (klass)->pick = unity_unity_icon_real_pick;
	CLUTTER_ACTOR_CLASS (klass)->paint = unity_unity_icon_real_paint;
	CLUTTER_ACTOR_CLASS (klass)->map = unity_unity_icon_real_map;
	CLUTTER_ACTOR_CLASS (klass)->unmap = unity_unity_icon_real_unmap;
	G_OBJECT_CLASS (klass)->get_property = unity_unity_icon_get_property;
	G_OBJECT_CLASS (klass)->set_property = unity_unity_icon_set_property;
	G_OBJECT_CLASS (klass)->constructor = unity_unity_icon_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_unity_icon_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_UNITY_ICON_ICON, g_param_spec_object ("icon", "icon", "icon", CLUTTER_TYPE_TEXTURE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_UNITY_ICON_BG_COLOR, g_param_spec_object ("bg-color", "bg-color", "bg-color", CLUTTER_TYPE_TEXTURE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void unity_unity_icon_instance_init (UnityUnityIcon * self) {
	self->priv = UNITY_UNITY_ICON_GET_PRIVATE (self);
}


static void unity_unity_icon_finalize (GObject* obj) {
	UnityUnityIcon * self;
	self = UNITY_UNITY_ICON (obj);
	_g_object_unref0 (self->priv->_icon);
	_g_object_unref0 (self->priv->_bg_color);
	_g_object_unref0 (self->priv->bg_layer);
	_g_object_unref0 (self->priv->fg_layer);
	_g_object_unref0 (self->priv->mask);
	_cogl_handle_unref0 (self->priv->bg_mat);
	_cogl_handle_unref0 (self->priv->fg_mat);
	_cogl_handle_unref0 (self->priv->icon_material);
	_cogl_handle_unref0 (self->priv->bgcol_material);
	G_OBJECT_CLASS (unity_unity_icon_parent_class)->finalize (obj);
}


GType unity_unity_icon_get_type (void) {
	static GType unity_unity_icon_type_id = 0;
	if (unity_unity_icon_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityUnityIconClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_unity_icon_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityUnityIcon), 0, (GInstanceInitFunc) unity_unity_icon_instance_init, NULL };
		unity_unity_icon_type_id = g_type_register_static (CTK_TYPE_ACTOR, "UnityUnityIcon", &g_define_type_info, 0);
	}
	return unity_unity_icon_type_id;
}


static void unity_unity_icon_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UnityUnityIcon * self;
	self = UNITY_UNITY_ICON (object);
	switch (property_id) {
		case UNITY_UNITY_ICON_ICON:
		g_value_set_object (value, unity_unity_icon_get_icon (self));
		break;
		case UNITY_UNITY_ICON_BG_COLOR:
		g_value_set_object (value, unity_unity_icon_get_bg_color (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void unity_unity_icon_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UnityUnityIcon * self;
	self = UNITY_UNITY_ICON (object);
	switch (property_id) {
		case UNITY_UNITY_ICON_ICON:
		unity_unity_icon_set_icon (self, g_value_get_object (value));
		break;
		case UNITY_UNITY_ICON_BG_COLOR:
		unity_unity_icon_set_bg_color (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}




